// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
// NOTE: Do *not* edit the -pskel.* files; they are generated automatically from the xsd file.
//       Instead, modify the -pimpl.* files. ~Seth
//
// End prologue.

#include "geo10-pskel.hpp"

namespace sim_mob
{
  namespace xml
  {
  // roadrunner_regions_t_pskel
  //

  void roadrunner_regions_t_pskel::
    region_parser (::sim_mob::xml::roadrunner_region_t_pskel& p)
  {
    this->region_parser_ = &p;
  }

  void roadrunner_regions_t_pskel::
    parsers (::sim_mob::xml::roadrunner_region_t_pskel& region)
  {
    this->region_parser_ = &region;
  }

  roadrunner_regions_t_pskel::
  roadrunner_regions_t_pskel ()
  : region_parser_ (0)
  {
  }

  // roadrunner_region_t_pskel
  //

  void roadrunner_region_t_pskel::
  id_parser (::xml_schema::int_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void roadrunner_region_t_pskel::
  shape_parser (::sim_mob::xml::roadrunner_shape_t_pskel& p)
  {
    this->shape_parser_ = &p;
  }

  void roadrunner_region_t_pskel::
  parsers (::xml_schema::int_pskel& id,
           ::sim_mob::xml::roadrunner_shape_t_pskel& shape)
  {
    this->id_parser_ = &id;
    this->shape_parser_ = &shape;
  }

  roadrunner_region_t_pskel::
  roadrunner_region_t_pskel ()
  : id_parser_ (0),
    shape_parser_ (0)
  {
  }

  // roadrunner_vertex_t_pskel
  //

  void roadrunner_vertex_t_pskel::
  latitude_parser (::xml_schema::double_pskel& p)
  {
    this->latitude_parser_ = &p;
  }

  void roadrunner_vertex_t_pskel::
  longitude_parser (::xml_schema::double_pskel& p)
  {
    this->longitude_parser_ = &p;
  }

  void roadrunner_vertex_t_pskel::
  parsers (::xml_schema::double_pskel& latitude,
           ::xml_schema::double_pskel& longitude)
  {
    this->latitude_parser_ = &latitude;
    this->longitude_parser_ = &longitude;
  }

  roadrunner_vertex_t_pskel::
  roadrunner_vertex_t_pskel ()
  : latitude_parser_ (0),
    longitude_parser_ (0)
  {
  }

  // roadrunner_shape_t_pskel
  //

  void roadrunner_shape_t_pskel::
    vertex_parser (::sim_mob::xml::roadrunner_vertex_t_pskel& p)
  {
    this->vertex_parser_ = &p;
  }

  void roadrunner_shape_t_pskel::
  parsers (::sim_mob::xml::roadrunner_vertex_t_pskel& vertex)
  {
    this->vertex_parser_ = &vertex;
  }

  roadrunner_shape_t_pskel::
  roadrunner_shape_t_pskel ()
  : vertex_parser_ (0)
  {
  }

  // coordinate_map_t_pskel
  //

  void coordinate_map_t_pskel::
  utm_projection_parser (::sim_mob::xml::utm_projection_t_pskel& p)
  {
    this->utm_projection_parser_ = &p;
  }

  void coordinate_map_t_pskel::
  linear_scale_parser (::sim_mob::xml::linear_scale_t_pskel& p)
  {
    this->linear_scale_parser_ = &p;
  }

  void coordinate_map_t_pskel::
  parsers (::sim_mob::xml::utm_projection_t_pskel& utm_projection,
           ::sim_mob::xml::linear_scale_t_pskel& linear_scale)
  {
    this->utm_projection_parser_ = &utm_projection;
    this->linear_scale_parser_ = &linear_scale;
  }

  coordinate_map_t_pskel::
  coordinate_map_t_pskel ()
  : utm_projection_parser_ (0),
    linear_scale_parser_ (0)
  {
  }

  // utm_projection_t_pskel
  //

  void utm_projection_t_pskel::
  coordinate_system_parser (::xml_schema::string_pskel& p)
  {
    this->coordinate_system_parser_ = &p;
  }

  void utm_projection_t_pskel::
  utm_zone_parser (::xml_schema::string_pskel& p)
  {
    this->utm_zone_parser_ = &p;
  }

  void utm_projection_t_pskel::
  parsers (::xml_schema::string_pskel& coordinate_system,
           ::xml_schema::string_pskel& utm_zone)
  {
    this->coordinate_system_parser_ = &coordinate_system;
    this->utm_zone_parser_ = &utm_zone;
  }

  utm_projection_t_pskel::
  utm_projection_t_pskel ()
  : coordinate_system_parser_ (0),
    utm_zone_parser_ (0)
  {
  }

  // linear_scale_t_pskel
  //

  void linear_scale_t_pskel::
  source_parser (::sim_mob::xml::scale_source_t_pskel& p)
  {
    this->source_parser_ = &p;
  }

  void linear_scale_t_pskel::
  destination_parser (::sim_mob::xml::scale_destination_t_pskel& p)
  {
    this->destination_parser_ = &p;
  }

  void linear_scale_t_pskel::
  parsers (::sim_mob::xml::scale_source_t_pskel& source,
           ::sim_mob::xml::scale_destination_t_pskel& destination)
  {
    this->source_parser_ = &source;
    this->destination_parser_ = &destination;
  }

  linear_scale_t_pskel::
  linear_scale_t_pskel ()
  : source_parser_ (0),
    destination_parser_ (0)
  {
  }

  // scale_source_t_pskel
  //

  void scale_source_t_pskel::
  x_range_parser (::xml_schema::string_pskel& p)
  {
    this->x_range_parser_ = &p;
  }

  void scale_source_t_pskel::
  y_range_parser (::xml_schema::string_pskel& p)
  {
    this->y_range_parser_ = &p;
  }

  void scale_source_t_pskel::
  parsers (::xml_schema::string_pskel& x_range,
           ::xml_schema::string_pskel& y_range)
  {
    this->x_range_parser_ = &x_range;
    this->y_range_parser_ = &y_range;
  }

  scale_source_t_pskel::
  scale_source_t_pskel ()
  : x_range_parser_ (0),
    y_range_parser_ (0)
  {
  }

  // scale_destination_t_pskel
  //

  void scale_destination_t_pskel::
  longitude_range_parser (::xml_schema::string_pskel& p)
  {
    this->longitude_range_parser_ = &p;
  }

  void scale_destination_t_pskel::
  latitude_range_parser (::xml_schema::string_pskel& p)
  {
    this->latitude_range_parser_ = &p;
  }

  void scale_destination_t_pskel::
  parsers (::xml_schema::string_pskel& longitude_range,
           ::xml_schema::string_pskel& latitude_range)
  {
    this->longitude_range_parser_ = &longitude_range;
    this->latitude_range_parser_ = &latitude_range;
  }

  scale_destination_t_pskel::
  scale_destination_t_pskel ()
  : longitude_range_parser_ (0),
    latitude_range_parser_ (0)
  {
  }

  // Point2D_t_pskel
  //

  void Point2D_t_pskel::
  xPos_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->xPos_parser_ = &p;
  }

  void Point2D_t_pskel::
  yPos_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->yPos_parser_ = &p;
  }

  void Point2D_t_pskel::
  parsers (::xml_schema::unsigned_int_pskel& xPos,
           ::xml_schema::unsigned_int_pskel& yPos)
  {
    this->xPos_parser_ = &xPos;
    this->yPos_parser_ = &yPos;
  }

  Point2D_t_pskel::
  Point2D_t_pskel ()
  : xPos_parser_ (0),
    yPos_parser_ (0)
  {
  }

  // PolyPoint_t_pskel
  //

  void PolyPoint_t_pskel::
  pointID_parser (::xml_schema::string_pskel& p)
  {
    this->pointID_parser_ = &p;
  }

  void PolyPoint_t_pskel::
  location_parser (::sim_mob::xml::Point2D_t_pskel& p)
  {
    this->location_parser_ = &p;
  }

  void PolyPoint_t_pskel::
  parsers (::xml_schema::string_pskel& pointID,
           ::sim_mob::xml::Point2D_t_pskel& location)
  {
    this->pointID_parser_ = &pointID;
    this->location_parser_ = &location;
  }

  PolyPoint_t_pskel::
  PolyPoint_t_pskel ()
  : pointID_parser_ (0),
    location_parser_ (0)
  {
  }

  // PolyLine_t_pskel
  //

  void PolyLine_t_pskel::
  PolyPoint_parser (::sim_mob::xml::PolyPoint_t_pskel& p)
  {
    this->PolyPoint_parser_ = &p;
  }

  void PolyLine_t_pskel::
  parsers (::sim_mob::xml::PolyPoint_t_pskel& PolyPoint)
  {
    this->PolyPoint_parser_ = &PolyPoint;
  }

  PolyLine_t_pskel::
  PolyLine_t_pskel ()
  : PolyPoint_parser_ (0)
  {
  }

  // lane_t_pskel
  //

  void lane_t_pskel::
  laneID_parser (::xml_schema::unsigned_long_pskel& p)
  {
    this->laneID_parser_ = &p;
  }

  void lane_t_pskel::
  width_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->width_parser_ = &p;
  }

  void lane_t_pskel::
  can_go_straight_parser (::xml_schema::boolean_pskel& p)
  {
    this->can_go_straight_parser_ = &p;
  }

  void lane_t_pskel::
  can_turn_left_parser (::xml_schema::boolean_pskel& p)
  {
    this->can_turn_left_parser_ = &p;
  }

  void lane_t_pskel::
  can_turn_right_parser (::xml_schema::boolean_pskel& p)
  {
    this->can_turn_right_parser_ = &p;
  }

  void lane_t_pskel::
  can_turn_on_red_signal_parser (::xml_schema::boolean_pskel& p)
  {
    this->can_turn_on_red_signal_parser_ = &p;
  }

  void lane_t_pskel::
  can_change_lane_left_parser (::xml_schema::boolean_pskel& p)
  {
    this->can_change_lane_left_parser_ = &p;
  }

  void lane_t_pskel::
  can_change_lane_right_parser (::xml_schema::boolean_pskel& p)
  {
    this->can_change_lane_right_parser_ = &p;
  }

  void lane_t_pskel::
  is_road_shoulder_parser (::xml_schema::boolean_pskel& p)
  {
    this->is_road_shoulder_parser_ = &p;
  }

  void lane_t_pskel::
  is_bicycle_lane_parser (::xml_schema::boolean_pskel& p)
  {
    this->is_bicycle_lane_parser_ = &p;
  }

  void lane_t_pskel::
  is_pedestrian_lane_parser (::xml_schema::boolean_pskel& p)
  {
    this->is_pedestrian_lane_parser_ = &p;
  }

  void lane_t_pskel::
  is_vehicle_lane_parser (::xml_schema::boolean_pskel& p)
  {
    this->is_vehicle_lane_parser_ = &p;
  }

  void lane_t_pskel::
  is_standard_bus_lane_parser (::xml_schema::boolean_pskel& p)
  {
    this->is_standard_bus_lane_parser_ = &p;
  }

  void lane_t_pskel::
  is_whole_day_bus_lane_parser (::xml_schema::boolean_pskel& p)
  {
    this->is_whole_day_bus_lane_parser_ = &p;
  }

  void lane_t_pskel::
  is_high_occupancy_vehicle_lane_parser (::xml_schema::boolean_pskel& p)
  {
    this->is_high_occupancy_vehicle_lane_parser_ = &p;
  }

  void lane_t_pskel::
  can_freely_park_here_parser (::xml_schema::boolean_pskel& p)
  {
    this->can_freely_park_here_parser_ = &p;
  }

  void lane_t_pskel::
  can_stop_here_parser (::xml_schema::boolean_pskel& p)
  {
    this->can_stop_here_parser_ = &p;
  }

  void lane_t_pskel::
  is_u_turn_allowed_parser (::xml_schema::boolean_pskel& p)
  {
    this->is_u_turn_allowed_parser_ = &p;
  }

  void lane_t_pskel::
  PolyLine_parser (::sim_mob::xml::PolyLine_t_pskel& p)
  {
    this->PolyLine_parser_ = &p;
  }

  void lane_t_pskel::
  parsers (::xml_schema::unsigned_long_pskel& laneID,
           ::xml_schema::unsigned_int_pskel& width,
           ::xml_schema::boolean_pskel& can_go_straight,
           ::xml_schema::boolean_pskel& can_turn_left,
           ::xml_schema::boolean_pskel& can_turn_right,
           ::xml_schema::boolean_pskel& can_turn_on_red_signal,
           ::xml_schema::boolean_pskel& can_change_lane_left,
           ::xml_schema::boolean_pskel& can_change_lane_right,
           ::xml_schema::boolean_pskel& is_road_shoulder,
           ::xml_schema::boolean_pskel& is_bicycle_lane,
           ::xml_schema::boolean_pskel& is_pedestrian_lane,
           ::xml_schema::boolean_pskel& is_vehicle_lane,
           ::xml_schema::boolean_pskel& is_standard_bus_lane,
           ::xml_schema::boolean_pskel& is_whole_day_bus_lane,
           ::xml_schema::boolean_pskel& is_high_occupancy_vehicle_lane,
           ::xml_schema::boolean_pskel& can_freely_park_here,
           ::xml_schema::boolean_pskel& can_stop_here,
           ::xml_schema::boolean_pskel& is_u_turn_allowed,
           ::sim_mob::xml::PolyLine_t_pskel& PolyLine)
  {
    this->laneID_parser_ = &laneID;
    this->width_parser_ = &width;
    this->can_go_straight_parser_ = &can_go_straight;
    this->can_turn_left_parser_ = &can_turn_left;
    this->can_turn_right_parser_ = &can_turn_right;
    this->can_turn_on_red_signal_parser_ = &can_turn_on_red_signal;
    this->can_change_lane_left_parser_ = &can_change_lane_left;
    this->can_change_lane_right_parser_ = &can_change_lane_right;
    this->is_road_shoulder_parser_ = &is_road_shoulder;
    this->is_bicycle_lane_parser_ = &is_bicycle_lane;
    this->is_pedestrian_lane_parser_ = &is_pedestrian_lane;
    this->is_vehicle_lane_parser_ = &is_vehicle_lane;
    this->is_standard_bus_lane_parser_ = &is_standard_bus_lane;
    this->is_whole_day_bus_lane_parser_ = &is_whole_day_bus_lane;
    this->is_high_occupancy_vehicle_lane_parser_ = &is_high_occupancy_vehicle_lane;
    this->can_freely_park_here_parser_ = &can_freely_park_here;
    this->can_stop_here_parser_ = &can_stop_here;
    this->is_u_turn_allowed_parser_ = &is_u_turn_allowed;
    this->PolyLine_parser_ = &PolyLine;
  }

  lane_t_pskel::
  lane_t_pskel ()
  : laneID_parser_ (0),
    width_parser_ (0),
    can_go_straight_parser_ (0),
    can_turn_left_parser_ (0),
    can_turn_right_parser_ (0),
    can_turn_on_red_signal_parser_ (0),
    can_change_lane_left_parser_ (0),
    can_change_lane_right_parser_ (0),
    is_road_shoulder_parser_ (0),
    is_bicycle_lane_parser_ (0),
    is_pedestrian_lane_parser_ (0),
    is_vehicle_lane_parser_ (0),
    is_standard_bus_lane_parser_ (0),
    is_whole_day_bus_lane_parser_ (0),
    is_high_occupancy_vehicle_lane_parser_ (0),
    can_freely_park_here_parser_ (0),
    can_stop_here_parser_ (0),
    is_u_turn_allowed_parser_ (0),
    PolyLine_parser_ (0)
  {
  }

  // connector_t_pskel
  //

  void connector_t_pskel::
  laneFrom_parser (::xml_schema::unsigned_long_pskel& p)
  {
    this->laneFrom_parser_ = &p;
  }

  void connector_t_pskel::
  laneTo_parser (::xml_schema::unsigned_long_pskel& p)
  {
    this->laneTo_parser_ = &p;
  }

  void connector_t_pskel::
  parsers (::xml_schema::unsigned_long_pskel& laneFrom,
           ::xml_schema::unsigned_long_pskel& laneTo)
  {
    this->laneFrom_parser_ = &laneFrom;
    this->laneTo_parser_ = &laneTo;
  }

  connector_t_pskel::
  connector_t_pskel ()
  : laneFrom_parser_ (0),
    laneTo_parser_ (0)
  {
  }

  // connectors_t_pskel
  //

  void connectors_t_pskel::
  Connector_parser (::sim_mob::xml::connector_t_pskel& p)
  {
    this->Connector_parser_ = &p;
  }

  void connectors_t_pskel::
  parsers (::sim_mob::xml::connector_t_pskel& Connector)
  {
    this->Connector_parser_ = &Connector;
  }

  connectors_t_pskel::
  connectors_t_pskel ()
  : Connector_parser_ (0)
  {
  }


  // Multi_Connector_t_pskel
  //

  void Multi_Connector_t_pskel::
  RoadSegment_parser (::xml_schema::unsigned_long_pskel& p)
  {
    this->RoadSegment_parser_ = &p;
  }

  void Multi_Connector_t_pskel::
  Connectors_parser (::sim_mob::xml::connectors_t_pskel& p)
  {
    this->Connectors_parser_ = &p;
  }

  void Multi_Connector_t_pskel::
  parsers (::xml_schema::unsigned_long_pskel& RoadSegment,
           ::sim_mob::xml::connectors_t_pskel& Connectors)
  {
    this->RoadSegment_parser_ = &RoadSegment;
    this->Connectors_parser_ = &Connectors;
  }

  Multi_Connector_t_pskel::
  Multi_Connector_t_pskel ()
  : RoadSegment_parser_ (0),
    Connectors_parser_ (0)
  {
  }

  // Multi_Connectors_t_pskel
  //

  void Multi_Connectors_t_pskel::
  MultiConnectors_parser (::sim_mob::xml::Multi_Connector_t_pskel& p)
  {
    this->MultiConnectors_parser_ = &p;
  }

  void Multi_Connectors_t_pskel::
  parsers (::sim_mob::xml::Multi_Connector_t_pskel& MultiConnectors)
  {
    this->MultiConnectors_parser_ = &MultiConnectors;
  }

  Multi_Connectors_t_pskel::
  Multi_Connectors_t_pskel ()
  : MultiConnectors_parser_ (0)
  {
  }

  // fwdBckSegments_t_pskel
  //

  void fwdBckSegments_t_pskel::
  Segment_parser (::sim_mob::xml::segment_t_pskel& p)
  {
    this->Segment_parser_ = &p;
  }

  void fwdBckSegments_t_pskel::
  parsers (::sim_mob::xml::segment_t_pskel& Segment)
  {
    this->Segment_parser_ = &Segment;
  }

  fwdBckSegments_t_pskel::
  fwdBckSegments_t_pskel ()
  : Segment_parser_ (0)
  {
  }

  // RoadSegmentsAt_t_pskel
  //

  void RoadSegmentsAt_t_pskel::
  segmentID_parser (::xml_schema::unsigned_long_pskel& p)
  {
    this->segmentID_parser_ = &p;
  }

  void RoadSegmentsAt_t_pskel::
  parsers (::xml_schema::unsigned_long_pskel& segmentID)
  {
    this->segmentID_parser_ = &segmentID;
  }

  RoadSegmentsAt_t_pskel::
  RoadSegmentsAt_t_pskel ()
  : segmentID_parser_ (0)
  {
  }

  // laneEdgePolyline_cached_t_pskel
  //

  void laneEdgePolyline_cached_t_pskel::
  laneNumber_parser (::xml_schema::short_pskel& p)
  {
    this->laneNumber_parser_ = &p;
  }

  void laneEdgePolyline_cached_t_pskel::
  polyline_parser (::sim_mob::xml::PolyLine_t_pskel& p)
  {
    this->polyline_parser_ = &p;
  }

  void laneEdgePolyline_cached_t_pskel::
  parsers (::xml_schema::short_pskel& laneNumber,
           ::sim_mob::xml::PolyLine_t_pskel& polyline)
  {
    this->laneNumber_parser_ = &laneNumber;
    this->polyline_parser_ = &polyline;
  }

  laneEdgePolyline_cached_t_pskel::
  laneEdgePolyline_cached_t_pskel ()
  : laneNumber_parser_ (0),
    polyline_parser_ (0)
  {
  }

  // laneEdgePolylines_cached_t_pskel
  //

  void laneEdgePolylines_cached_t_pskel::
  laneEdgePolyline_cached_parser (::sim_mob::xml::laneEdgePolyline_cached_t_pskel& p)
  {
    this->laneEdgePolyline_cached_parser_ = &p;
  }

  void laneEdgePolylines_cached_t_pskel::
  parsers (::sim_mob::xml::laneEdgePolyline_cached_t_pskel& laneEdgePolyline_cached)
  {
    this->laneEdgePolyline_cached_parser_ = &laneEdgePolyline_cached;
  }

  laneEdgePolylines_cached_t_pskel::
  laneEdgePolylines_cached_t_pskel ()
  : laneEdgePolyline_cached_parser_ (0)
  {
  }

  // segment_t_pskel
  //

  void segment_t_pskel::
  segmentID_parser (::xml_schema::unsigned_long_pskel& p)
  {
    this->segmentID_parser_ = &p;
  }

  void segment_t_pskel::
  startingNode_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->startingNode_parser_ = &p;
  }

  void segment_t_pskel::
  endingNode_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->endingNode_parser_ = &p;
  }

  void segment_t_pskel::
  maxSpeed_parser (::xml_schema::short_pskel& p)
  {
    this->maxSpeed_parser_ = &p;
  }

  void segment_t_pskel::
  Length_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->Length_parser_ = &p;
  }

  void segment_t_pskel::
  Width_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->Width_parser_ = &p;
  }

  void segment_t_pskel::
  originalDB_ID_parser (::xml_schema::string_pskel& p)
  {
    this->originalDB_ID_parser_ = &p;
  }

  void segment_t_pskel::
  polyline_parser (::sim_mob::xml::PolyLine_t_pskel& p)
  {
    this->polyline_parser_ = &p;
  }

  void segment_t_pskel::
  laneEdgePolylines_cached_parser (::sim_mob::xml::laneEdgePolylines_cached_t_pskel& p)
  {
    this->laneEdgePolylines_cached_parser_ = &p;
  }

  void segment_t_pskel::
  Lanes_parser (::sim_mob::xml::Lanes_pskel& p)
  {
    this->Lanes_parser_ = &p;
  }

  void segment_t_pskel::
  Obstacles_parser (::sim_mob::xml::RoadItems_t_pskel& p)
  {
    this->Obstacles_parser_ = &p;
  }

  void segment_t_pskel::
  KurbLine_parser (::sim_mob::xml::PolyLine_t_pskel& p)
  {
    this->KurbLine_parser_ = &p;
  }

  void segment_t_pskel::
  parsers (::xml_schema::unsigned_long_pskel& segmentID,
           ::xml_schema::unsigned_int_pskel& startingNode,
           ::xml_schema::unsigned_int_pskel& endingNode,
           ::xml_schema::short_pskel& maxSpeed,
           ::xml_schema::unsigned_int_pskel& Length,
           ::xml_schema::unsigned_int_pskel& Width,
           ::xml_schema::string_pskel& originalDB_ID,
           ::sim_mob::xml::PolyLine_t_pskel& polyline,
           ::sim_mob::xml::laneEdgePolylines_cached_t_pskel& laneEdgePolylines_cached,
           ::sim_mob::xml::Lanes_pskel& Lanes,
           ::sim_mob::xml::RoadItems_t_pskel& Obstacles,
           ::sim_mob::xml::PolyLine_t_pskel& KurbLine)
  {
    this->segmentID_parser_ = &segmentID;
    this->startingNode_parser_ = &startingNode;
    this->endingNode_parser_ = &endingNode;
    this->maxSpeed_parser_ = &maxSpeed;
    this->Length_parser_ = &Length;
    this->Width_parser_ = &Width;
    this->originalDB_ID_parser_ = &originalDB_ID;
    this->polyline_parser_ = &polyline;
    this->laneEdgePolylines_cached_parser_ = &laneEdgePolylines_cached;
    this->Lanes_parser_ = &Lanes;
    this->Obstacles_parser_ = &Obstacles;
    this->KurbLine_parser_ = &KurbLine;
  }

  segment_t_pskel::
  segment_t_pskel ()
  : segmentID_parser_ (0),
    startingNode_parser_ (0),
    endingNode_parser_ (0),
    maxSpeed_parser_ (0),
    Length_parser_ (0),
    Width_parser_ (0),
    originalDB_ID_parser_ (0),
    polyline_parser_ (0),
    laneEdgePolylines_cached_parser_ (0),
    Lanes_parser_ (0),
    Obstacles_parser_ (0),
    KurbLine_parser_ (0)
  {
  }

  // link_t_pskel
  //

  void link_t_pskel::
  linkID_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->linkID_parser_ = &p;
  }

  void link_t_pskel::
  roadName_parser (::xml_schema::string_pskel& p)
  {
    this->roadName_parser_ = &p;
  }

  void link_t_pskel::
  StartingNode_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->StartingNode_parser_ = &p;
  }

  void link_t_pskel::
  EndingNode_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->EndingNode_parser_ = &p;
  }

  void link_t_pskel::
  Segments_parser (::sim_mob::xml::fwdBckSegments_t_pskel& p)
  {
    this->Segments_parser_ = &p;
  }

  void link_t_pskel::
  parsers (::xml_schema::unsigned_int_pskel& linkID,
           ::xml_schema::string_pskel& roadName,
           ::xml_schema::unsigned_int_pskel& StartingNode,
           ::xml_schema::unsigned_int_pskel& EndingNode,
           ::sim_mob::xml::fwdBckSegments_t_pskel& Segments)
  {
    this->linkID_parser_ = &linkID;
    this->roadName_parser_ = &roadName;
    this->StartingNode_parser_ = &StartingNode;
    this->EndingNode_parser_ = &EndingNode;
    this->Segments_parser_ = &Segments;
  }

  link_t_pskel::
  link_t_pskel ()
  : linkID_parser_ (0),
    roadName_parser_ (0),
    StartingNode_parser_ (0),
    EndingNode_parser_ (0),
    Segments_parser_ (0)
  {
  }

  // separator_t_pskel
  //

  void separator_t_pskel::
  separator_ID_parser (::xml_schema::unsigned_short_pskel& p)
  {
    this->separator_ID_parser_ = &p;
  }

  void separator_t_pskel::
  separator_value_parser (::xml_schema::boolean_pskel& p)
  {
    this->separator_value_parser_ = &p;
  }

  void separator_t_pskel::
  parsers (::xml_schema::unsigned_short_pskel& separator_ID,
           ::xml_schema::boolean_pskel& separator_value)
  {
    this->separator_ID_parser_ = &separator_ID;
    this->separator_value_parser_ = &separator_value;
  }

  separator_t_pskel::
  separator_t_pskel ()
  : separator_ID_parser_ (0),
    separator_value_parser_ (0)
  {
  }

  // separators_t_pskel
  //

  void separators_t_pskel::
  Separator_parser (::sim_mob::xml::separator_t_pskel& p)
  {
    this->Separator_parser_ = &p;
  }

  void separators_t_pskel::
  parsers (::sim_mob::xml::separator_t_pskel& Separator)
  {
    this->Separator_parser_ = &Separator;
  }

  separators_t_pskel::
  separators_t_pskel ()
  : Separator_parser_ (0)
  {
  }

  // DomainIsland_t_pskel
  //

  void DomainIsland_t_pskel::
  domainIsland_ID_parser (::xml_schema::unsigned_short_pskel& p)
  {
    this->domainIsland_ID_parser_ = &p;
  }

  void DomainIsland_t_pskel::
  domainIsland_value_parser (::xml_schema::boolean_pskel& p)
  {
    this->domainIsland_value_parser_ = &p;
  }

  void DomainIsland_t_pskel::
  parsers (::xml_schema::unsigned_short_pskel& domainIsland_ID,
           ::xml_schema::boolean_pskel& domainIsland_value)
  {
    this->domainIsland_ID_parser_ = &domainIsland_ID;
    this->domainIsland_value_parser_ = &domainIsland_value;
  }

  DomainIsland_t_pskel::
  DomainIsland_t_pskel ()
  : domainIsland_ID_parser_ (0),
    domainIsland_value_parser_ (0)
  {
  }

  // DomainIslands_t_pskel
  //

  void DomainIslands_t_pskel::
  domainIslands_parser (::sim_mob::xml::DomainIsland_t_pskel& p)
  {
    this->domainIslands_parser_ = &p;
  }

  void DomainIslands_t_pskel::
  parsers (::sim_mob::xml::DomainIsland_t_pskel& domainIslands)
  {
    this->domainIslands_parser_ = &domainIslands;
  }

  DomainIslands_t_pskel::
  DomainIslands_t_pskel ()
  : domainIslands_parser_ (0)
  {
  }

  // offset_t_pskel
  //

  void offset_t_pskel::
  offset_ID_parser (::xml_schema::unsigned_short_pskel& p)
  {
    this->offset_ID_parser_ = &p;
  }

  void offset_t_pskel::
  offset_value_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->offset_value_parser_ = &p;
  }

  void offset_t_pskel::
  parsers (::xml_schema::unsigned_short_pskel& offset_ID,
           ::xml_schema::unsigned_int_pskel& offset_value)
  {
    this->offset_ID_parser_ = &offset_ID;
    this->offset_value_parser_ = &offset_value;
  }

  offset_t_pskel::
  offset_t_pskel ()
  : offset_ID_parser_ (0),
    offset_value_parser_ (0)
  {
  }

  // offsets_t_pskel
  //

  void offsets_t_pskel::
  offset_parser (::sim_mob::xml::offset_t_pskel& p)
  {
    this->offset_parser_ = &p;
  }

  void offsets_t_pskel::
  parsers (::sim_mob::xml::offset_t_pskel& offset)
  {
    this->offset_parser_ = &offset;
  }

  offsets_t_pskel::
  offsets_t_pskel ()
  : offset_parser_ (0)
  {
  }

  // ChunkLength_t_pskel
  //

  void ChunkLength_t_pskel::
  chunklength_ID_parser (::xml_schema::unsigned_short_pskel& p)
  {
    this->chunklength_ID_parser_ = &p;
  }

  void ChunkLength_t_pskel::
  chunklength_value_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->chunklength_value_parser_ = &p;
  }

  void ChunkLength_t_pskel::
  parsers (::xml_schema::unsigned_short_pskel& chunklength_ID,
           ::xml_schema::unsigned_int_pskel& chunklength_value)
  {
    this->chunklength_ID_parser_ = &chunklength_ID;
    this->chunklength_value_parser_ = &chunklength_value;
  }

  ChunkLength_t_pskel::
  ChunkLength_t_pskel ()
  : chunklength_ID_parser_ (0),
    chunklength_value_parser_ (0)
  {
  }

  // ChunkLengths_t_pskel
  //

  void ChunkLengths_t_pskel::
  chunklength_parser (::sim_mob::xml::ChunkLength_t_pskel& p)
  {
    this->chunklength_parser_ = &p;
  }

  void ChunkLengths_t_pskel::
  parsers (::sim_mob::xml::ChunkLength_t_pskel& chunklength)
  {
    this->chunklength_parser_ = &chunklength;
  }

  ChunkLengths_t_pskel::
  ChunkLengths_t_pskel ()
  : chunklength_parser_ (0)
  {
  }

  // LanesVector_t_pskel
  //

  void LanesVector_t_pskel::
  laneID_parser (::xml_schema::unsigned_long_pskel& p)
  {
    this->laneID_parser_ = &p;
  }

  void LanesVector_t_pskel::
  parsers (::xml_schema::unsigned_long_pskel& laneID)
  {
    this->laneID_parser_ = &laneID;
  }

  LanesVector_t_pskel::
  LanesVector_t_pskel ()
  : laneID_parser_ (0)
  {
  }

  // EntranceAngle_t_pskel
  //

  void EntranceAngle_t_pskel::
  entranceAngle_ID_parser (::xml_schema::unsigned_short_pskel& p)
  {
    this->entranceAngle_ID_parser_ = &p;
  }

  void EntranceAngle_t_pskel::
  entranceAngle_value_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->entranceAngle_value_parser_ = &p;
  }

  void EntranceAngle_t_pskel::
  parsers (::xml_schema::unsigned_short_pskel& entranceAngle_ID,
           ::xml_schema::unsigned_int_pskel& entranceAngle_value)
  {
    this->entranceAngle_ID_parser_ = &entranceAngle_ID;
    this->entranceAngle_value_parser_ = &entranceAngle_value;
  }

  EntranceAngle_t_pskel::
  EntranceAngle_t_pskel ()
  : entranceAngle_ID_parser_ (0),
    entranceAngle_value_parser_ (0)
  {
  }

  // EntranceAngles_t_pskel
  //

  void EntranceAngles_t_pskel::
  entranceAngle_parser (::sim_mob::xml::EntranceAngle_t_pskel& p)
  {
    this->entranceAngle_parser_ = &p;
  }

  void EntranceAngles_t_pskel::
  parsers (::sim_mob::xml::EntranceAngle_t_pskel& entranceAngle)
  {
    this->entranceAngle_parser_ = &entranceAngle;
  }

  EntranceAngles_t_pskel::
  EntranceAngles_t_pskel ()
  : entranceAngle_parser_ (0)
  {
  }

  // Node_t_pskel
  //

  void Node_t_pskel::
  nodeID_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->nodeID_parser_ = &p;
  }

  void Node_t_pskel::
  location_parser (::sim_mob::xml::Point2D_t_pskel& p)
  {
    this->location_parser_ = &p;
  }

  void Node_t_pskel::
  originalDB_ID_parser (::xml_schema::string_pskel& p)
  {
    this->originalDB_ID_parser_ = &p;
  }

  void Node_t_pskel::
  parsers (::xml_schema::unsigned_int_pskel& nodeID,
           ::sim_mob::xml::Point2D_t_pskel& location,
           ::xml_schema::string_pskel& originalDB_ID)
  {
    this->nodeID_parser_ = &nodeID;
    this->location_parser_ = &location;
    this->originalDB_ID_parser_ = &originalDB_ID;
  }

  Node_t_pskel::
  Node_t_pskel ()
  : nodeID_parser_ (0),
    location_parser_ (0),
    originalDB_ID_parser_ (0)
  {
  }

  // temp_Segmetair_t_pskel
  //

  void temp_Segmetair_t_pskel::
  first_parser (::xml_schema::unsigned_long_pskel& p)
  {
    this->first_parser_ = &p;
  }

  void temp_Segmetair_t_pskel::
  second_parser (::xml_schema::unsigned_long_pskel& p)
  {
    this->second_parser_ = &p;
  }

  void temp_Segmetair_t_pskel::
  parsers (::xml_schema::unsigned_long_pskel& first,
           ::xml_schema::unsigned_long_pskel& second)
  {
    this->first_parser_ = &first;
    this->second_parser_ = &second;
  }

  temp_Segmetair_t_pskel::
  temp_Segmetair_t_pskel ()
  : first_parser_ (0),
    second_parser_ (0)
  {
  }

  // UniNode_t_pskel
  //

  void UniNode_t_pskel::
  firstPair_parser (::sim_mob::xml::temp_Segmetair_t_pskel& p)
  {
    this->firstPair_parser_ = &p;
  }

  void UniNode_t_pskel::
  secondPair_parser (::sim_mob::xml::temp_Segmetair_t_pskel& p)
  {
    this->secondPair_parser_ = &p;
  }

  void UniNode_t_pskel::
  Connectors_parser (::sim_mob::xml::connectors_t_pskel& p)
  {
    this->Connectors_parser_ = &p;
  }

  void UniNode_t_pskel::
  parsers (::xml_schema::unsigned_int_pskel& nodeID,
           ::sim_mob::xml::Point2D_t_pskel& location,
           ::xml_schema::string_pskel& originalDB_ID,
           ::sim_mob::xml::temp_Segmetair_t_pskel& firstPair,
           ::sim_mob::xml::temp_Segmetair_t_pskel& secondPair,
           ::sim_mob::xml::connectors_t_pskel& Connectors)
  {
    this->nodeID_parser_ = &nodeID;
    this->location_parser_ = &location;
    this->originalDB_ID_parser_ = &originalDB_ID;
    this->firstPair_parser_ = &firstPair;
    this->secondPair_parser_ = &secondPair;
    this->Connectors_parser_ = &Connectors;
  }

  UniNode_t_pskel::
  UniNode_t_pskel ()
  : firstPair_parser_ (0),
    secondPair_parser_ (0),
    Connectors_parser_ (0)
  {
  }

  // roundabout_t_pskel
  //

  void roundabout_t_pskel::
  roadSegmentsAt_parser (::sim_mob::xml::RoadSegmentsAt_t_pskel& p)
  {
    this->roadSegmentsAt_parser_ = &p;
  }

  void roundabout_t_pskel::
  Connectors_parser (::sim_mob::xml::Multi_Connectors_t_pskel& p)
  {
    this->Connectors_parser_ = &p;
  }

  void roundabout_t_pskel::
  ChunkLengths_parser (::sim_mob::xml::ChunkLengths_t_pskel& p)
  {
    this->ChunkLengths_parser_ = &p;
  }

  void roundabout_t_pskel::
  Offsets_parser (::sim_mob::xml::offsets_t_pskel& p)
  {
    this->Offsets_parser_ = &p;
  }

  void roundabout_t_pskel::
  Separators_parser (::sim_mob::xml::separators_t_pskel& p)
  {
    this->Separators_parser_ = &p;
  }

  void roundabout_t_pskel::
  addDominantLane_parser (::sim_mob::xml::LanesVector_t_pskel& p)
  {
    this->addDominantLane_parser_ = &p;
  }

  void roundabout_t_pskel::
  roundaboutDominantIslands_parser (::xml_schema::float_pskel& p)
  {
    this->roundaboutDominantIslands_parser_ = &p;
  }

  void roundabout_t_pskel::
  roundaboutNumberOfLanes_parser (::xml_schema::int_pskel& p)
  {
    this->roundaboutNumberOfLanes_parser_ = &p;
  }

  void roundabout_t_pskel::
  entranceAngles_parser (::sim_mob::xml::EntranceAngles_t_pskel& p)
  {
    this->entranceAngles_parser_ = &p;
  }

  void roundabout_t_pskel::
  parsers (::xml_schema::unsigned_int_pskel& nodeID,
           ::sim_mob::xml::Point2D_t_pskel& location,
           ::xml_schema::string_pskel& originalDB_ID,
           ::sim_mob::xml::RoadSegmentsAt_t_pskel& roadSegmentsAt,
           ::sim_mob::xml::Multi_Connectors_t_pskel& Connectors,
           ::sim_mob::xml::ChunkLengths_t_pskel& ChunkLengths,
           ::sim_mob::xml::offsets_t_pskel& Offsets,
           ::sim_mob::xml::separators_t_pskel& Separators,
           ::sim_mob::xml::LanesVector_t_pskel& addDominantLane,
           ::xml_schema::float_pskel& roundaboutDominantIslands,
           ::xml_schema::int_pskel& roundaboutNumberOfLanes,
           ::sim_mob::xml::EntranceAngles_t_pskel& entranceAngles)
  {
    this->nodeID_parser_ = &nodeID;
    this->location_parser_ = &location;
    this->originalDB_ID_parser_ = &originalDB_ID;
    this->roadSegmentsAt_parser_ = &roadSegmentsAt;
    this->Connectors_parser_ = &Connectors;
    this->ChunkLengths_parser_ = &ChunkLengths;
    this->Offsets_parser_ = &Offsets;
    this->Separators_parser_ = &Separators;
    this->addDominantLane_parser_ = &addDominantLane;
    this->roundaboutDominantIslands_parser_ = &roundaboutDominantIslands;
    this->roundaboutNumberOfLanes_parser_ = &roundaboutNumberOfLanes;
    this->entranceAngles_parser_ = &entranceAngles;
  }

  roundabout_t_pskel::
  roundabout_t_pskel ()
  : roadSegmentsAt_parser_ (0),
    Connectors_parser_ (0),
    ChunkLengths_parser_ (0),
    Offsets_parser_ (0),
    Separators_parser_ (0),
    addDominantLane_parser_ (0),
    roundaboutDominantIslands_parser_ (0),
    roundaboutNumberOfLanes_parser_ (0),
    entranceAngles_parser_ (0)
  {
  }

  // intersection_t_pskel
  //

  void intersection_t_pskel::
  roadSegmentsAt_parser (::sim_mob::xml::RoadSegmentsAt_t_pskel& p)
  {
    this->roadSegmentsAt_parser_ = &p;
  }

  void intersection_t_pskel::
  Connectors_parser (::sim_mob::xml::Multi_Connectors_t_pskel& p)
  {
    this->Connectors_parser_ = &p;
  }

  void intersection_t_pskel::
  ChunkLengths_parser (::sim_mob::xml::ChunkLengths_t_pskel& p)
  {
    this->ChunkLengths_parser_ = &p;
  }

  void intersection_t_pskel::
  Offsets_parser (::sim_mob::xml::offsets_t_pskel& p)
  {
    this->Offsets_parser_ = &p;
  }

  void intersection_t_pskel::
  Separators_parser (::sim_mob::xml::separators_t_pskel& p)
  {
    this->Separators_parser_ = &p;
  }

  void intersection_t_pskel::
  additionalDominantLanes_parser (::sim_mob::xml::LanesVector_t_pskel& p)
  {
    this->additionalDominantLanes_parser_ = &p;
  }

  void intersection_t_pskel::
  additionalSubdominantLanes_parser (::sim_mob::xml::LanesVector_t_pskel& p)
  {
    this->additionalSubdominantLanes_parser_ = &p;
  }

  void intersection_t_pskel::
  domainIslands_parser (::sim_mob::xml::DomainIslands_t_pskel& p)
  {
    this->domainIslands_parser_ = &p;
  }

  void intersection_t_pskel::
  parsers (::xml_schema::unsigned_int_pskel& nodeID,
           ::sim_mob::xml::Point2D_t_pskel& location,
           ::xml_schema::string_pskel& originalDB_ID,
           ::sim_mob::xml::RoadSegmentsAt_t_pskel& roadSegmentsAt,
           ::sim_mob::xml::Multi_Connectors_t_pskel& Connectors,
           ::sim_mob::xml::ChunkLengths_t_pskel& ChunkLengths,
           ::sim_mob::xml::offsets_t_pskel& Offsets,
           ::sim_mob::xml::separators_t_pskel& Separators,
           ::sim_mob::xml::LanesVector_t_pskel& additionalDominantLanes,
           ::sim_mob::xml::LanesVector_t_pskel& additionalSubdominantLanes,
           ::sim_mob::xml::DomainIslands_t_pskel& domainIslands)
  {
    this->nodeID_parser_ = &nodeID;
    this->location_parser_ = &location;
    this->originalDB_ID_parser_ = &originalDB_ID;
    this->roadSegmentsAt_parser_ = &roadSegmentsAt;
    this->Connectors_parser_ = &Connectors;
    this->ChunkLengths_parser_ = &ChunkLengths;
    this->Offsets_parser_ = &Offsets;
    this->Separators_parser_ = &Separators;
    this->additionalDominantLanes_parser_ = &additionalDominantLanes;
    this->additionalSubdominantLanes_parser_ = &additionalSubdominantLanes;
    this->domainIslands_parser_ = &domainIslands;
  }

  intersection_t_pskel::
  intersection_t_pskel ()
  : roadSegmentsAt_parser_ (0),
    Connectors_parser_ (0),
    ChunkLengths_parser_ (0),
    Offsets_parser_ (0),
    Separators_parser_ (0),
    additionalDominantLanes_parser_ (0),
    additionalSubdominantLanes_parser_ (0),
    domainIslands_parser_ (0)
  {
  }

  // RoadItem_t_pskel
  //

  void RoadItem_t_pskel::
  id_parser (::xml_schema::unsigned_long_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void RoadItem_t_pskel::
  Offset_parser (::xml_schema::unsigned_short_pskel& p)
  {
    this->Offset_parser_ = &p;
  }

  void RoadItem_t_pskel::
  start_parser (::sim_mob::xml::Point2D_t_pskel& p)
  {
    this->start_parser_ = &p;
  }

  void RoadItem_t_pskel::
  end_parser (::sim_mob::xml::Point2D_t_pskel& p)
  {
    this->end_parser_ = &p;
  }

  void RoadItem_t_pskel::
  parsers (::xml_schema::unsigned_long_pskel& id,
           ::xml_schema::unsigned_short_pskel& Offset,
           ::sim_mob::xml::Point2D_t_pskel& start,
           ::sim_mob::xml::Point2D_t_pskel& end)
  {
    this->id_parser_ = &id;
    this->Offset_parser_ = &Offset;
    this->start_parser_ = &start;
    this->end_parser_ = &end;
  }

  RoadItem_t_pskel::
  RoadItem_t_pskel ()
  : id_parser_ (0),
    Offset_parser_ (0),
    start_parser_ (0),
    end_parser_ (0)
  {
  }

  // BusStop_t_pskel
  //

  void BusStop_t_pskel::
  xPos_parser (::xml_schema::double_pskel& p)
  {
    this->xPos_parser_ = &p;
  }

  void BusStop_t_pskel::
  yPos_parser (::xml_schema::double_pskel& p)
  {
    this->yPos_parser_ = &p;
  }

  void BusStop_t_pskel::
  lane_location_parser (::xml_schema::unsigned_long_pskel& p)
  {
    this->lane_location_parser_ = &p;
  }

  void BusStop_t_pskel::
  is_terminal_parser (::xml_schema::boolean_pskel& p)
  {
    this->is_terminal_parser_ = &p;
  }

  void BusStop_t_pskel::
  is_bay_parser (::xml_schema::boolean_pskel& p)
  {
    this->is_bay_parser_ = &p;
  }

  void BusStop_t_pskel::
  has_shelter_parser (::xml_schema::boolean_pskel& p)
  {
    this->has_shelter_parser_ = &p;
  }

  void BusStop_t_pskel::
  busCapacityAsLength_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->busCapacityAsLength_parser_ = &p;
  }

  void BusStop_t_pskel::
  busstopno_parser (::xml_schema::string_pskel& p)
  {
    this->busstopno_parser_ = &p;
  }

  void BusStop_t_pskel::
  parsers (::xml_schema::unsigned_long_pskel& id,
           ::xml_schema::unsigned_short_pskel& Offset,
           ::sim_mob::xml::Point2D_t_pskel& start,
           ::sim_mob::xml::Point2D_t_pskel& end,
           ::xml_schema::double_pskel& xPos,
           ::xml_schema::double_pskel& yPos,
           ::xml_schema::unsigned_long_pskel& lane_location,
           ::xml_schema::boolean_pskel& is_terminal,
           ::xml_schema::boolean_pskel& is_bay,
           ::xml_schema::boolean_pskel& has_shelter,
           ::xml_schema::unsigned_int_pskel& busCapacityAsLength,
           ::xml_schema::string_pskel& busstopno)
  {
    this->id_parser_ = &id;
    this->Offset_parser_ = &Offset;
    this->start_parser_ = &start;
    this->end_parser_ = &end;
    this->xPos_parser_ = &xPos;
    this->yPos_parser_ = &yPos;
    this->lane_location_parser_ = &lane_location;
    this->is_terminal_parser_ = &is_terminal;
    this->is_bay_parser_ = &is_bay;
    this->has_shelter_parser_ = &has_shelter;
    this->busCapacityAsLength_parser_ = &busCapacityAsLength;
    this->busstopno_parser_ = &busstopno;
  }

  BusStop_t_pskel::
  BusStop_t_pskel ()
  : xPos_parser_ (0),
    yPos_parser_ (0),
    lane_location_parser_ (0),
    is_terminal_parser_ (0),
    is_bay_parser_ (0),
    has_shelter_parser_ (0),
    busCapacityAsLength_parser_ (0),
    busstopno_parser_ (0)
  {
  }

  // ERP_Gantry_t_pskel
  //

  void ERP_Gantry_t_pskel::
  ERP_GantryID_parser (::xml_schema::string_pskel& p)
  {
    this->ERP_GantryID_parser_ = &p;
  }

  void ERP_Gantry_t_pskel::
  parsers (::xml_schema::unsigned_long_pskel& id,
           ::xml_schema::unsigned_short_pskel& Offset,
           ::sim_mob::xml::Point2D_t_pskel& start,
           ::sim_mob::xml::Point2D_t_pskel& end,
           ::xml_schema::string_pskel& ERP_GantryID)
  {
    this->id_parser_ = &id;
    this->Offset_parser_ = &Offset;
    this->start_parser_ = &start;
    this->end_parser_ = &end;
    this->ERP_GantryID_parser_ = &ERP_GantryID;
  }

  ERP_Gantry_t_pskel::
  ERP_Gantry_t_pskel ()
  : ERP_GantryID_parser_ (0)
  {
  }

  // FormType_pskel
  //

  void FormType_pskel::
  TextBox_parser (::xml_schema::int_pskel& p)
  {
    this->TextBox_parser_ = &p;
  }

  void FormType_pskel::
  TextArea_parser (::xml_schema::int_pskel& p)
  {
    this->TextArea_parser_ = &p;
  }

  void FormType_pskel::
  Header_parser (::xml_schema::int_pskel& p)
  {
    this->Header_parser_ = &p;
  }

  void FormType_pskel::
  parsers (::xml_schema::int_pskel& TextBox,
           ::xml_schema::int_pskel& TextArea,
           ::xml_schema::int_pskel& Header)
  {
    this->TextBox_parser_ = &TextBox;
    this->TextArea_parser_ = &TextArea;
    this->Header_parser_ = &Header;
  }

  FormType_pskel::
  FormType_pskel ()
  : TextBox_parser_ (0),
    TextArea_parser_ (0),
    Header_parser_ (0)
  {
  }

  // PointPair_t_pskel
  //

  void PointPair_t_pskel::
  first_parser (::sim_mob::xml::Point2D_t_pskel& p)
  {
    this->first_parser_ = &p;
  }

  void PointPair_t_pskel::
  second_parser (::sim_mob::xml::Point2D_t_pskel& p)
  {
    this->second_parser_ = &p;
  }

  void PointPair_t_pskel::
  parsers (::sim_mob::xml::Point2D_t_pskel& first,
           ::sim_mob::xml::Point2D_t_pskel& second)
  {
    this->first_parser_ = &first;
    this->second_parser_ = &second;
  }

  PointPair_t_pskel::
  PointPair_t_pskel ()
  : first_parser_ (0),
    second_parser_ (0)
  {
  }

  // crossing_t_pskel
  //

  void crossing_t_pskel::
  nearLine_parser (::sim_mob::xml::PointPair_t_pskel& p)
  {
    this->nearLine_parser_ = &p;
  }

  void crossing_t_pskel::
  farLine_parser (::sim_mob::xml::PointPair_t_pskel& p)
  {
    this->farLine_parser_ = &p;
  }

  void crossing_t_pskel::
  parsers (::xml_schema::unsigned_long_pskel& id,
           ::xml_schema::unsigned_short_pskel& Offset,
           ::sim_mob::xml::Point2D_t_pskel& start,
           ::sim_mob::xml::Point2D_t_pskel& end,
           ::sim_mob::xml::PointPair_t_pskel& nearLine,
           ::sim_mob::xml::PointPair_t_pskel& farLine)
  {
    this->id_parser_ = &id;
    this->Offset_parser_ = &Offset;
    this->start_parser_ = &start;
    this->end_parser_ = &end;
    this->nearLine_parser_ = &nearLine;
    this->farLine_parser_ = &farLine;
  }

  crossing_t_pskel::
  crossing_t_pskel ()
  : nearLine_parser_ (0),
    farLine_parser_ (0)
  {
  }

  // RoadBump_t_pskel
  //

  void RoadBump_t_pskel::
  roadBumpID_parser (::xml_schema::string_pskel& p)
  {
    this->roadBumpID_parser_ = &p;
  }

  void RoadBump_t_pskel::
  segmentID_parser (::xml_schema::unsigned_long_pskel& p)
  {
    this->segmentID_parser_ = &p;
  }

  void RoadBump_t_pskel::
  parsers (::xml_schema::unsigned_long_pskel& id,
           ::xml_schema::unsigned_short_pskel& Offset,
           ::sim_mob::xml::Point2D_t_pskel& start,
           ::sim_mob::xml::Point2D_t_pskel& end,
           ::xml_schema::string_pskel& roadBumpID,
           ::xml_schema::unsigned_long_pskel& segmentID)
  {
    this->id_parser_ = &id;
    this->Offset_parser_ = &Offset;
    this->start_parser_ = &start;
    this->end_parser_ = &end;
    this->roadBumpID_parser_ = &roadBumpID;
    this->segmentID_parser_ = &segmentID;
  }

  RoadBump_t_pskel::
  RoadBump_t_pskel ()
  : roadBumpID_parser_ (0),
    segmentID_parser_ (0)
  {
  }

  // RoadNetwork_t_pskel
  //

  void RoadNetwork_t_pskel::
  coordinate_map_parser (::sim_mob::xml::coordinate_map_t_pskel& p)
  {
    this->coordinate_map_parser_ = &p;
  }

  void RoadNetwork_t_pskel::
  roadrunner_regions_parser (::sim_mob::xml::roadrunner_regions_t_pskel& p)
  {
    this->roadrunner_regions_parser_ = &p;
  }

  void RoadNetwork_t_pskel::
  Nodes_parser (::sim_mob::xml::Nodes_pskel& p)
  {
    this->Nodes_parser_ = &p;
  }

  void RoadNetwork_t_pskel::
  Links_parser (::sim_mob::xml::Links_pskel& p)
  {
    this->Links_parser_ = &p;
  }

  void RoadNetwork_t_pskel::
  parsers (::sim_mob::xml::coordinate_map_t_pskel& coordinate_map,
           ::sim_mob::xml::roadrunner_regions_t_pskel& roadrunner_regions,
           ::sim_mob::xml::Nodes_pskel& Nodes,
           ::sim_mob::xml::Links_pskel& Links)
  {
    this->coordinate_map_parser_ = &coordinate_map;
    this->roadrunner_regions_parser_ = &roadrunner_regions;
    this->Nodes_parser_ = &Nodes;
    this->Links_parser_ = &Links;
  }

  RoadNetwork_t_pskel::
  RoadNetwork_t_pskel ()
  : coordinate_map_parser_ (0),
    roadrunner_regions_parser_ (0),
    Nodes_parser_ (0),
    Links_parser_ (0)
  {
  }

  // RoadItems_t_pskel
  //

  void RoadItems_t_pskel::
  BusStop_parser (::sim_mob::xml::BusStop_t_pskel& p)
  {
    this->BusStop_parser_ = &p;
  }

  void RoadItems_t_pskel::
  ERP_Gantry_parser (::sim_mob::xml::ERP_Gantry_t_pskel& p)
  {
    this->ERP_Gantry_parser_ = &p;
  }

  void RoadItems_t_pskel::
  Crossing_parser (::sim_mob::xml::crossing_t_pskel& p)
  {
    this->Crossing_parser_ = &p;
  }

  void RoadItems_t_pskel::
  RoadBump_parser (::sim_mob::xml::RoadBump_t_pskel& p)
  {
    this->RoadBump_parser_ = &p;
  }

  void RoadItems_t_pskel::
  parsers (::sim_mob::xml::BusStop_t_pskel& BusStop,
           ::sim_mob::xml::ERP_Gantry_t_pskel& ERP_Gantry,
           ::sim_mob::xml::crossing_t_pskel& Crossing,
           ::sim_mob::xml::RoadBump_t_pskel& RoadBump)
  {
    this->BusStop_parser_ = &BusStop;
    this->ERP_Gantry_parser_ = &ERP_Gantry;
    this->Crossing_parser_ = &Crossing;
    this->RoadBump_parser_ = &RoadBump;
  }

  RoadItems_t_pskel::
  RoadItems_t_pskel ()
  : BusStop_parser_ (0),
    ERP_Gantry_parser_ (0),
    Crossing_parser_ (0),
    RoadBump_parser_ (0)
  {
  }

  // TripChainItem_t_pskel
  //

  void TripChainItem_t_pskel::
  personID_parser (::xml_schema::string_pskel& p)
  {
    this->personID_parser_ = &p;
  }

  void TripChainItem_t_pskel::
  itemType_parser (::sim_mob::xml::TripchainItemType_pskel& p)
  {
    this->itemType_parser_ = &p;
  }

  void TripChainItem_t_pskel::
  sequenceNumber_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->sequenceNumber_parser_ = &p;
  }

  void TripChainItem_t_pskel::
  requestTime_parser (::xml_schema::integer_pskel& p)
  {
    this->requestTime_parser_ = &p;
  }

  void TripChainItem_t_pskel::
  startTime_parser (::xml_schema::string_pskel& p)
  {
    this->startTime_parser_ = &p;
  }

  void TripChainItem_t_pskel::
  endTime_parser (::xml_schema::string_pskel& p)
  {
    this->endTime_parser_ = &p;
  }

  void TripChainItem_t_pskel::
  parsers (::xml_schema::string_pskel& personID,
           ::sim_mob::xml::TripchainItemType_pskel& itemType,
           ::xml_schema::unsigned_int_pskel& sequenceNumber,
           ::xml_schema::integer_pskel& requestTime,
           ::xml_schema::string_pskel& startTime,
           ::xml_schema::string_pskel& endTime)
  {
    this->personID_parser_ = &personID;
    this->itemType_parser_ = &itemType;
    this->sequenceNumber_parser_ = &sequenceNumber;
    this->requestTime_parser_ = &requestTime;
    this->startTime_parser_ = &startTime;
    this->endTime_parser_ = &endTime;
  }

  TripChainItem_t_pskel::
  TripChainItem_t_pskel ()
  : personID_parser_ (0),
    itemType_parser_ (0),
    sequenceNumber_parser_ (0),
    requestTime_parser_ (0),
    startTime_parser_ (0),
    endTime_parser_ (0)
  {
  }

  // Trip_t_pskel
  //

  void Trip_t_pskel::
  tripID_parser (::xml_schema::integer_pskel& p)
  {
    this->tripID_parser_ = &p;
  }

  void Trip_t_pskel::
  fromLocation_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->fromLocation_parser_ = &p;
  }

  void Trip_t_pskel::
  fromLocationType_parser (::sim_mob::xml::TripchainItemLocationType_pskel& p)
  {
    this->fromLocationType_parser_ = &p;
  }

  void Trip_t_pskel::
  toLocation_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->toLocation_parser_ = &p;
  }

  void Trip_t_pskel::
  toLocationType_parser (::sim_mob::xml::TripchainItemLocationType_pskel& p)
  {
    this->toLocationType_parser_ = &p;
  }

  void Trip_t_pskel::
  subTrips_parser (::sim_mob::xml::SubTrips_t_pskel& p)
  {
    this->subTrips_parser_ = &p;
  }

  void Trip_t_pskel::
  parsers (::xml_schema::string_pskel& personID,
           ::sim_mob::xml::TripchainItemType_pskel& itemType,
           ::xml_schema::unsigned_int_pskel& sequenceNumber,
           ::xml_schema::integer_pskel& requestTime,
           ::xml_schema::string_pskel& startTime,
           ::xml_schema::string_pskel& endTime,
           ::xml_schema::integer_pskel& tripID,
           ::xml_schema::unsigned_int_pskel& fromLocation,
           ::sim_mob::xml::TripchainItemLocationType_pskel& fromLocationType,
           ::xml_schema::unsigned_int_pskel& toLocation,
           ::sim_mob::xml::TripchainItemLocationType_pskel& toLocationType,
           ::sim_mob::xml::SubTrips_t_pskel& subTrips)
  {
    this->personID_parser_ = &personID;
    this->itemType_parser_ = &itemType;
    this->sequenceNumber_parser_ = &sequenceNumber;
    this->requestTime_parser_ = &requestTime;
    this->startTime_parser_ = &startTime;
    this->endTime_parser_ = &endTime;
    this->tripID_parser_ = &tripID;
    this->fromLocation_parser_ = &fromLocation;
    this->fromLocationType_parser_ = &fromLocationType;
    this->toLocation_parser_ = &toLocation;
    this->toLocationType_parser_ = &toLocationType;
    this->subTrips_parser_ = &subTrips;
  }

  Trip_t_pskel::
  Trip_t_pskel ()
  : tripID_parser_ (0),
    fromLocation_parser_ (0),
    fromLocationType_parser_ (0),
    toLocation_parser_ (0),
    toLocationType_parser_ (0),
    subTrips_parser_ (0)
  {
  }

  // SubTrip_t_pskel
  //

  void SubTrip_t_pskel::
  mode_parser (::xml_schema::string_pskel& p)
  {
    this->mode_parser_ = &p;
  }

  void SubTrip_t_pskel::
  isPrimaryMode_parser (::xml_schema::boolean_pskel& p)
  {
    this->isPrimaryMode_parser_ = &p;
  }

  void SubTrip_t_pskel::
  ptLineId_parser (::xml_schema::string_pskel& p)
  {
    this->ptLineId_parser_ = &p;
  }

  void SubTrip_t_pskel::
  parsers (::xml_schema::string_pskel& personID,
           ::sim_mob::xml::TripchainItemType_pskel& itemType,
           ::xml_schema::unsigned_int_pskel& sequenceNumber,
           ::xml_schema::integer_pskel& requestTime,
           ::xml_schema::string_pskel& startTime,
           ::xml_schema::string_pskel& endTime,
           ::xml_schema::integer_pskel& tripID,
           ::xml_schema::unsigned_int_pskel& fromLocation,
           ::sim_mob::xml::TripchainItemLocationType_pskel& fromLocationType,
           ::xml_schema::unsigned_int_pskel& toLocation,
           ::sim_mob::xml::TripchainItemLocationType_pskel& toLocationType,
           ::sim_mob::xml::SubTrips_t_pskel& subTrips,
           ::xml_schema::string_pskel& mode,
           ::xml_schema::boolean_pskel& isPrimaryMode,
           ::xml_schema::string_pskel& ptLineId)
  {
    this->personID_parser_ = &personID;
    this->itemType_parser_ = &itemType;
    this->sequenceNumber_parser_ = &sequenceNumber;
    this->requestTime_parser_ = &requestTime;
    this->startTime_parser_ = &startTime;
    this->endTime_parser_ = &endTime;
    this->tripID_parser_ = &tripID;
    this->fromLocation_parser_ = &fromLocation;
    this->fromLocationType_parser_ = &fromLocationType;
    this->toLocation_parser_ = &toLocation;
    this->toLocationType_parser_ = &toLocationType;
    this->subTrips_parser_ = &subTrips;
    this->mode_parser_ = &mode;
    this->isPrimaryMode_parser_ = &isPrimaryMode;
    this->ptLineId_parser_ = &ptLineId;
  }

  SubTrip_t_pskel::
  SubTrip_t_pskel ()
  : mode_parser_ (0),
    isPrimaryMode_parser_ (0),
    ptLineId_parser_ (0)
  {
  }

  // SubTrips_t_pskel
  //

  void SubTrips_t_pskel::
  subTrip_parser (::sim_mob::xml::SubTrip_t_pskel& p)
  {
    this->subTrip_parser_ = &p;
  }

  void SubTrips_t_pskel::
  parsers (::sim_mob::xml::SubTrip_t_pskel& subTrip)
  {
    this->subTrip_parser_ = &subTrip;
  }

  SubTrips_t_pskel::
  SubTrips_t_pskel ()
  : subTrip_parser_ (0)
  {
  }

  // Activity_t_pskel
  //

  void Activity_t_pskel::
  description_parser (::xml_schema::string_pskel& p)
  {
    this->description_parser_ = &p;
  }

  void Activity_t_pskel::
  location_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->location_parser_ = &p;
  }

  void Activity_t_pskel::
  locationType_parser (::sim_mob::xml::TripchainItemLocationType_pskel& p)
  {
    this->locationType_parser_ = &p;
  }

  void Activity_t_pskel::
  isPrimary_parser (::xml_schema::boolean_pskel& p)
  {
    this->isPrimary_parser_ = &p;
  }

  void Activity_t_pskel::
  isFlexible_parser (::xml_schema::boolean_pskel& p)
  {
    this->isFlexible_parser_ = &p;
  }

  void Activity_t_pskel::
  isMandatory_parser (::xml_schema::boolean_pskel& p)
  {
    this->isMandatory_parser_ = &p;
  }

  void Activity_t_pskel::
  parsers (::xml_schema::string_pskel& personID,
           ::sim_mob::xml::TripchainItemType_pskel& itemType,
           ::xml_schema::unsigned_int_pskel& sequenceNumber,
           ::xml_schema::integer_pskel& requestTime,
           ::xml_schema::string_pskel& startTime,
           ::xml_schema::string_pskel& endTime,
           ::xml_schema::string_pskel& description,
           ::xml_schema::unsigned_int_pskel& location,
           ::sim_mob::xml::TripchainItemLocationType_pskel& locationType,
           ::xml_schema::boolean_pskel& isPrimary,
           ::xml_schema::boolean_pskel& isFlexible,
           ::xml_schema::boolean_pskel& isMandatory)
  {
    this->personID_parser_ = &personID;
    this->itemType_parser_ = &itemType;
    this->sequenceNumber_parser_ = &sequenceNumber;
    this->requestTime_parser_ = &requestTime;
    this->startTime_parser_ = &startTime;
    this->endTime_parser_ = &endTime;
    this->description_parser_ = &description;
    this->location_parser_ = &location;
    this->locationType_parser_ = &locationType;
    this->isPrimary_parser_ = &isPrimary;
    this->isFlexible_parser_ = &isFlexible;
    this->isMandatory_parser_ = &isMandatory;
  }

  Activity_t_pskel::
  Activity_t_pskel ()
  : description_parser_ (0),
    location_parser_ (0),
    locationType_parser_ (0),
    isPrimary_parser_ (0),
    isFlexible_parser_ (0),
    isMandatory_parser_ (0)
  {
  }

  // TripChain_t_pskel
  //

  void TripChain_t_pskel::
  personID_parser (::xml_schema::string_pskel& p)
  {
    this->personID_parser_ = &p;
  }

  void TripChain_t_pskel::
  Trip_parser (::sim_mob::xml::Trip_t_pskel& p)
  {
    this->Trip_parser_ = &p;
  }

  void TripChain_t_pskel::
  Activity_parser (::sim_mob::xml::Activity_t_pskel& p)
  {
    this->Activity_parser_ = &p;
  }

  void TripChain_t_pskel::
  parsers (::xml_schema::string_pskel& personID,
           ::sim_mob::xml::Trip_t_pskel& Trip,
           ::sim_mob::xml::Activity_t_pskel& Activity)
  {
    this->personID_parser_ = &personID;
    this->Trip_parser_ = &Trip;
    this->Activity_parser_ = &Activity;
  }

  TripChain_t_pskel::
  TripChain_t_pskel ()
  : personID_parser_ (0),
    Trip_parser_ (0),
    Activity_parser_ (0)
  {
  }

  // TripChains_t_pskel
  //

  void TripChains_t_pskel::
  TripChain_parser (::sim_mob::xml::TripChain_t_pskel& p)
  {
    this->TripChain_parser_ = &p;
  }

  void TripChains_t_pskel::
  parsers (::sim_mob::xml::TripChain_t_pskel& TripChain)
  {
    this->TripChain_parser_ = &TripChain;
  }

  TripChains_t_pskel::
  TripChains_t_pskel ()
  : TripChain_parser_ (0)
  {
  }

  // linkAndCrossing_t_pskel
  //

  void linkAndCrossing_t_pskel::
  ID_parser (::xml_schema::unsigned_byte_pskel& p)
  {
    this->ID_parser_ = &p;
  }

  void linkAndCrossing_t_pskel::
  linkID_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->linkID_parser_ = &p;
  }

  void linkAndCrossing_t_pskel::
  crossingID_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->crossingID_parser_ = &p;
  }

  void linkAndCrossing_t_pskel::
  angle_parser (::xml_schema::unsigned_byte_pskel& p)
  {
    this->angle_parser_ = &p;
  }

  void linkAndCrossing_t_pskel::
  parsers (::xml_schema::unsigned_byte_pskel& ID,
           ::xml_schema::unsigned_int_pskel& linkID,
           ::xml_schema::unsigned_int_pskel& crossingID,
           ::xml_schema::unsigned_byte_pskel& angle)
  {
    this->ID_parser_ = &ID;
    this->linkID_parser_ = &linkID;
    this->crossingID_parser_ = &crossingID;
    this->angle_parser_ = &angle;
  }

  linkAndCrossing_t_pskel::
  linkAndCrossing_t_pskel ()
  : ID_parser_ (0),
    linkID_parser_ (0),
    crossingID_parser_ (0),
    angle_parser_ (0)
  {
  }

  // linkAndCrossings_t_pskel
  //

  void linkAndCrossings_t_pskel::
  linkAndCrossing_parser (::sim_mob::xml::linkAndCrossing_t_pskel& p)
  {
    this->linkAndCrossing_parser_ = &p;
  }

  void linkAndCrossings_t_pskel::
  parsers (::sim_mob::xml::linkAndCrossing_t_pskel& linkAndCrossing)
  {
    this->linkAndCrossing_parser_ = &linkAndCrossing;
  }

  linkAndCrossings_t_pskel::
  linkAndCrossings_t_pskel ()
  : linkAndCrossing_parser_ (0)
  {
  }

  // plan_t_pskel
  //

  void plan_t_pskel::
  planID_parser (::xml_schema::unsigned_byte_pskel& p)
  {
    this->planID_parser_ = &p;
  }

  void plan_t_pskel::
  PhasePercentage_parser (::xml_schema::double_pskel& p)
  {
    this->PhasePercentage_parser_ = &p;
  }

  void plan_t_pskel::
  parsers (::xml_schema::unsigned_byte_pskel& planID,
           ::xml_schema::double_pskel& PhasePercentage)
  {
    this->planID_parser_ = &planID;
    this->PhasePercentage_parser_ = &PhasePercentage;
  }

  plan_t_pskel::
  plan_t_pskel ()
  : planID_parser_ (0),
    PhasePercentage_parser_ (0)
  {
  }

  // Plans_t_pskel
  //

  void Plans_t_pskel::
  plan_parser (::sim_mob::xml::plan_t_pskel& p)
  {
    this->plan_parser_ = &p;
  }

  void Plans_t_pskel::
  parsers (::sim_mob::xml::plan_t_pskel& plan)
  {
    this->plan_parser_ = &plan;
  }

  Plans_t_pskel::
  Plans_t_pskel ()
  : plan_parser_ (0)
  {
  }

  // ColorDuration_t_pskel
  //

  void ColorDuration_t_pskel::
  TrafficColor_parser (::sim_mob::xml::TrafficColor_t_pskel& p)
  {
    this->TrafficColor_parser_ = &p;
  }

  void ColorDuration_t_pskel::
  Duration_parser (::xml_schema::unsigned_byte_pskel& p)
  {
    this->Duration_parser_ = &p;
  }

  void ColorDuration_t_pskel::
  parsers (::sim_mob::xml::TrafficColor_t_pskel& TrafficColor,
           ::xml_schema::unsigned_byte_pskel& Duration)
  {
    this->TrafficColor_parser_ = &TrafficColor;
    this->Duration_parser_ = &Duration;
  }

  ColorDuration_t_pskel::
  ColorDuration_t_pskel ()
  : TrafficColor_parser_ (0),
    Duration_parser_ (0)
  {
  }

  // ColorSequence_t_pskel
  //

  void ColorSequence_t_pskel::
  TrafficLightType_parser (::xml_schema::string_pskel& p)
  {
    this->TrafficLightType_parser_ = &p;
  }

  void ColorSequence_t_pskel::
  ColorDuration_parser (::sim_mob::xml::ColorDuration_t_pskel& p)
  {
    this->ColorDuration_parser_ = &p;
  }

  void ColorSequence_t_pskel::
  parsers (::xml_schema::string_pskel& TrafficLightType,
           ::sim_mob::xml::ColorDuration_t_pskel& ColorDuration)
  {
    this->TrafficLightType_parser_ = &TrafficLightType;
    this->ColorDuration_parser_ = &ColorDuration;
  }

  ColorSequence_t_pskel::
  ColorSequence_t_pskel ()
  : TrafficLightType_parser_ (0),
    ColorDuration_parser_ (0)
  {
  }

  // links_maps_t_pskel
  //

  void links_maps_t_pskel::
  links_map_parser (::sim_mob::xml::links_map_t_pskel& p)
  {
    this->links_map_parser_ = &p;
  }

  void links_maps_t_pskel::
  parsers (::sim_mob::xml::links_map_t_pskel& links_map)
  {
    this->links_map_parser_ = &links_map;
  }

  links_maps_t_pskel::
  links_maps_t_pskel ()
  : links_map_parser_ (0)
  {
  }

  // links_map_t_pskel
  //

  void links_map_t_pskel::
  LinkFrom_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->LinkFrom_parser_ = &p;
  }

  void links_map_t_pskel::
  LinkTo_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->LinkTo_parser_ = &p;
  }

  void links_map_t_pskel::
  SegmentFrom_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->SegmentFrom_parser_ = &p;
  }

  void links_map_t_pskel::
  SegmentTo_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->SegmentTo_parser_ = &p;
  }

  void links_map_t_pskel::
  ColorSequence_parser (::sim_mob::xml::ColorSequence_t_pskel& p)
  {
    this->ColorSequence_parser_ = &p;
  }

  void links_map_t_pskel::
  parsers (::xml_schema::unsigned_int_pskel& LinkFrom,
           ::xml_schema::unsigned_int_pskel& LinkTo,
           ::xml_schema::unsigned_int_pskel& SegmentFrom,
           ::xml_schema::unsigned_int_pskel& SegmentTo,
           ::sim_mob::xml::ColorSequence_t_pskel& ColorSequence)
  {
    this->LinkFrom_parser_ = &LinkFrom;
    this->LinkTo_parser_ = &LinkTo;
    this->SegmentFrom_parser_ = &SegmentFrom;
    this->SegmentTo_parser_ = &SegmentTo;
    this->ColorSequence_parser_ = &ColorSequence;
  }

  links_map_t_pskel::
  links_map_t_pskel ()
  : LinkFrom_parser_ (0),
    LinkTo_parser_ (0),
    SegmentFrom_parser_ (0),
    SegmentTo_parser_ (0),
    ColorSequence_parser_ (0)
  {
  }

  // crossings_maps_t_pskel
  //

  void crossings_maps_t_pskel::
  crossings_map_parser (::sim_mob::xml::crossings_map_t_pskel& p)
  {
    this->crossings_map_parser_ = &p;
  }

  void crossings_maps_t_pskel::
  parsers (::sim_mob::xml::crossings_map_t_pskel& crossings_map)
  {
    this->crossings_map_parser_ = &crossings_map;
  }

  crossings_maps_t_pskel::
  crossings_maps_t_pskel ()
  : crossings_map_parser_ (0)
  {
  }

  // crossings_map_t_pskel
  //

  void crossings_map_t_pskel::
  linkID_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->linkID_parser_ = &p;
  }

  void crossings_map_t_pskel::
  crossingID_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->crossingID_parser_ = &p;
  }

  void crossings_map_t_pskel::
  ColorSequence_parser (::sim_mob::xml::ColorSequence_t_pskel& p)
  {
    this->ColorSequence_parser_ = &p;
  }

  void crossings_map_t_pskel::
  parsers (::xml_schema::unsigned_int_pskel& linkID,
           ::xml_schema::unsigned_int_pskel& crossingID,
           ::sim_mob::xml::ColorSequence_t_pskel& ColorSequence)
  {
    this->linkID_parser_ = &linkID;
    this->crossingID_parser_ = &crossingID;
    this->ColorSequence_parser_ = &ColorSequence;
  }

  crossings_map_t_pskel::
  crossings_map_t_pskel ()
  : linkID_parser_ (0),
    crossingID_parser_ (0),
    ColorSequence_parser_ (0)
  {
  }

  // Phase_t_pskel
  //

  void Phase_t_pskel::
  phaseID_parser (::xml_schema::unsigned_byte_pskel& p)
  {
    this->phaseID_parser_ = &p;
  }

  void Phase_t_pskel::
  name_parser (::xml_schema::string_pskel& p)
  {
    this->name_parser_ = &p;
  }

  void Phase_t_pskel::
  links_maps_parser (::sim_mob::xml::links_maps_t_pskel& p)
  {
    this->links_maps_parser_ = &p;
  }

  void Phase_t_pskel::
  crossings_maps_parser (::sim_mob::xml::crossings_maps_t_pskel& p)
  {
    this->crossings_maps_parser_ = &p;
  }

  void Phase_t_pskel::
  parsers (::xml_schema::unsigned_byte_pskel& phaseID,
           ::xml_schema::string_pskel& name,
           ::sim_mob::xml::links_maps_t_pskel& links_maps,
           ::sim_mob::xml::crossings_maps_t_pskel& crossings_maps)
  {
    this->phaseID_parser_ = &phaseID;
    this->name_parser_ = &name;
    this->links_maps_parser_ = &links_maps;
    this->crossings_maps_parser_ = &crossings_maps;
  }

  Phase_t_pskel::
  Phase_t_pskel ()
  : phaseID_parser_ (0),
    name_parser_ (0),
    links_maps_parser_ (0),
    crossings_maps_parser_ (0)
  {
  }

  // Phases_t_pskel
  //

  void Phases_t_pskel::
  phase_parser (::sim_mob::xml::Phase_t_pskel& p)
  {
    this->phase_parser_ = &p;
  }

  void Phases_t_pskel::
  parsers (::sim_mob::xml::Phase_t_pskel& phase)
  {
    this->phase_parser_ = &phase;
  }

  Phases_t_pskel::
  Phases_t_pskel ()
  : phase_parser_ (0)
  {
  }

  // SplitPlan_t_pskel
  //

  void SplitPlan_t_pskel::
  splitplanID_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->splitplanID_parser_ = &p;
  }

  void SplitPlan_t_pskel::
  cycleLength_parser (::xml_schema::unsigned_byte_pskel& p)
  {
    this->cycleLength_parser_ = &p;
  }

  void SplitPlan_t_pskel::
  offset_parser (::xml_schema::unsigned_byte_pskel& p)
  {
    this->offset_parser_ = &p;
  }

  void SplitPlan_t_pskel::
  ChoiceSet_parser (::sim_mob::xml::Plans_t_pskel& p)
  {
    this->ChoiceSet_parser_ = &p;
  }

  void SplitPlan_t_pskel::
  parsers (::xml_schema::unsigned_int_pskel& splitplanID,
           ::xml_schema::unsigned_byte_pskel& cycleLength,
           ::xml_schema::unsigned_byte_pskel& offset,
           ::sim_mob::xml::Plans_t_pskel& ChoiceSet)
  {
    this->splitplanID_parser_ = &splitplanID;
    this->cycleLength_parser_ = &cycleLength;
    this->offset_parser_ = &offset;
    this->ChoiceSet_parser_ = &ChoiceSet;
  }

  SplitPlan_t_pskel::
  SplitPlan_t_pskel ()
  : splitplanID_parser_ (0),
    cycleLength_parser_ (0),
    offset_parser_ (0),
    ChoiceSet_parser_ (0)
  {
  }

  // SCATS_t_pskel
  //

  void SCATS_t_pskel::
  signalTimingMode_parser (::sim_mob::xml::signalTimingMode_t_pskel& p)
  {
    this->signalTimingMode_parser_ = &p;
  }

  void SCATS_t_pskel::
  SplitPlan_parser (::sim_mob::xml::SplitPlan_t_pskel& p)
  {
    this->SplitPlan_parser_ = &p;
  }

  void SCATS_t_pskel::
  parsers (::sim_mob::xml::signalTimingMode_t_pskel& signalTimingMode,
           ::sim_mob::xml::SplitPlan_t_pskel& SplitPlan)
  {
    this->signalTimingMode_parser_ = &signalTimingMode;
    this->SplitPlan_parser_ = &SplitPlan;
  }

  SCATS_t_pskel::
  SCATS_t_pskel ()
  : signalTimingMode_parser_ (0),
    SplitPlan_parser_ (0)
  {
  }

  // Signal_t_pskel
  //

  void Signal_t_pskel::
  signalID_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->signalID_parser_ = &p;
  }

  void Signal_t_pskel::
  nodeID_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->nodeID_parser_ = &p;
  }

  void Signal_t_pskel::
  linkAndCrossings_parser (::sim_mob::xml::linkAndCrossings_t_pskel& p)
  {
    this->linkAndCrossings_parser_ = &p;
  }

  void Signal_t_pskel::
  phases_parser (::sim_mob::xml::Phases_t_pskel& p)
  {
    this->phases_parser_ = &p;
  }

  void Signal_t_pskel::
  SCATS_parser (::sim_mob::xml::SCATS_t_pskel& p)
  {
    this->SCATS_parser_ = &p;
  }

  void Signal_t_pskel::
  parsers (::xml_schema::unsigned_int_pskel& signalID,
           ::xml_schema::unsigned_int_pskel& nodeID,
           ::sim_mob::xml::linkAndCrossings_t_pskel& linkAndCrossings,
           ::sim_mob::xml::Phases_t_pskel& phases,
           ::sim_mob::xml::SCATS_t_pskel& SCATS)
  {
    this->signalID_parser_ = &signalID;
    this->nodeID_parser_ = &nodeID;
    this->linkAndCrossings_parser_ = &linkAndCrossings;
    this->phases_parser_ = &phases;
    this->SCATS_parser_ = &SCATS;
  }

  Signal_t_pskel::
  Signal_t_pskel ()
  : signalID_parser_ (0),
    nodeID_parser_ (0),
    linkAndCrossings_parser_ (0),
    phases_parser_ (0),
    SCATS_parser_ (0)
  {
  }

  // Signals_t_pskel
  //

  void Signals_t_pskel::
  Signal_parser (::sim_mob::xml::Signal_t_pskel& p)
  {
    this->Signal_parser_ = &p;
  }

  void Signals_t_pskel::
  parsers (::sim_mob::xml::Signal_t_pskel& Signal)
  {
    this->Signal_parser_ = &Signal;
  }

  Signals_t_pskel::
  Signals_t_pskel ()
  : Signal_parser_ (0)
  {
  }

  // GeoSpatial_t_pskel
  //

  void GeoSpatial_t_pskel::
  RoadNetwork_parser (::sim_mob::xml::RoadNetwork_t_pskel& p)
  {
    this->RoadNetwork_parser_ = &p;
  }

  void GeoSpatial_t_pskel::
  parsers (::sim_mob::xml::RoadNetwork_t_pskel& RoadNetwork)
  {
    this->RoadNetwork_parser_ = &RoadNetwork;
  }

  GeoSpatial_t_pskel::
  GeoSpatial_t_pskel ()
  : RoadNetwork_parser_ (0)
  {
  }

  // SimMobility_t_pskel
  //

  void SimMobility_t_pskel::
  GeoSpatial_parser (::sim_mob::xml::GeoSpatial_t_pskel& p)
  {
    this->GeoSpatial_parser_ = &p;
  }

  void SimMobility_t_pskel::
  TripChains_parser (::sim_mob::xml::TripChains_t_pskel& p)
  {
    this->TripChains_parser_ = &p;
  }

  void SimMobility_t_pskel::
  Signals_parser (::sim_mob::xml::Signals_t_pskel& p)
  {
    this->Signals_parser_ = &p;
  }

  void SimMobility_t_pskel::
  parsers (::sim_mob::xml::GeoSpatial_t_pskel& GeoSpatial,
           ::sim_mob::xml::TripChains_t_pskel& TripChains,
           ::sim_mob::xml::Signals_t_pskel& Signals)
  {
    this->GeoSpatial_parser_ = &GeoSpatial;
    this->TripChains_parser_ = &TripChains;
    this->Signals_parser_ = &Signals;
  }

  SimMobility_t_pskel::
  SimMobility_t_pskel ()
  : GeoSpatial_parser_ (0),
    TripChains_parser_ (0),
    Signals_parser_ (0)
  {
  }

  // Lanes_pskel
  //

  void Lanes_pskel::
  Lane_parser (::sim_mob::xml::lane_t_pskel& p)
  {
    this->Lane_parser_ = &p;
  }

  void Lanes_pskel::
  parsers (::sim_mob::xml::lane_t_pskel& Lane)
  {
    this->Lane_parser_ = &Lane;
  }

  Lanes_pskel::
  Lanes_pskel ()
  : Lane_parser_ (0)
  {
  }

  // Nodes_pskel
  //

  void Nodes_pskel::
  UniNodes_parser (::sim_mob::xml::UniNodes_pskel& p)
  {
    this->UniNodes_parser_ = &p;
  }

  void Nodes_pskel::
  Intersections_parser (::sim_mob::xml::Intersections_pskel& p)
  {
    this->Intersections_parser_ = &p;
  }

  void Nodes_pskel::
  roundabouts_parser (::sim_mob::xml::roundabouts_pskel& p)
  {
    this->roundabouts_parser_ = &p;
  }

  void Nodes_pskel::
  parsers (::sim_mob::xml::UniNodes_pskel& UniNodes,
           ::sim_mob::xml::Intersections_pskel& Intersections,
           ::sim_mob::xml::roundabouts_pskel& roundabouts)
  {
    this->UniNodes_parser_ = &UniNodes;
    this->Intersections_parser_ = &Intersections;
    this->roundabouts_parser_ = &roundabouts;
  }

  Nodes_pskel::
  Nodes_pskel ()
  : UniNodes_parser_ (0),
    Intersections_parser_ (0),
    roundabouts_parser_ (0)
  {
  }

  // Links_pskel
  //

  void Links_pskel::
  Link_parser (::sim_mob::xml::link_t_pskel& p)
  {
    this->Link_parser_ = &p;
  }

  void Links_pskel::
  parsers (::sim_mob::xml::link_t_pskel& Link)
  {
    this->Link_parser_ = &Link;
  }

  Links_pskel::
  Links_pskel ()
  : Link_parser_ (0)
  {
  }

  // UniNodes_pskel
  //

  void UniNodes_pskel::
  UniNode_parser (::sim_mob::xml::UniNode_t_pskel& p)
  {
    this->UniNode_parser_ = &p;
  }

  void UniNodes_pskel::
  parsers (::sim_mob::xml::UniNode_t_pskel& UniNode)
  {
    this->UniNode_parser_ = &UniNode;
  }

  UniNodes_pskel::
  UniNodes_pskel ()
  : UniNode_parser_ (0)
  {
  }

  // Intersections_pskel
  //

  void Intersections_pskel::
  Intersection_parser (::sim_mob::xml::intersection_t_pskel& p)
  {
    this->Intersection_parser_ = &p;
  }

  void Intersections_pskel::
  parsers (::sim_mob::xml::intersection_t_pskel& Intersection)
  {
    this->Intersection_parser_ = &Intersection;
  }

  Intersections_pskel::
  Intersections_pskel ()
  : Intersection_parser_ (0)
  {
  }

  // roundabouts_pskel
  //

  void roundabouts_pskel::
  roundabout_parser (::sim_mob::xml::roundabout_t_pskel& p)
  {
    this->roundabout_parser_ = &p;
  }

  void roundabouts_pskel::
  parsers (::sim_mob::xml::roundabout_t_pskel& roundabout)
  {
    this->roundabout_parser_ = &roundabout;
  }

  roundabouts_pskel::
  roundabouts_pskel ()
  : roundabout_parser_ (0)
  {
  }
}
}

namespace sim_mob
{
  namespace xml
  {
  // roadrunner_regions_t_pskel
  //

  void roadrunner_regions_t_pskel::
  region (const sim_mob::RoadRunnerRegion&)
  {
  }

  bool roadrunner_regions_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "region" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->region_parser_;

      if (this->region_parser_)
        this->region_parser_->pre ();

      return true;
    }

    return false;
  }

  bool roadrunner_regions_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "region" && ns.empty ())
    {
      if (this->region_parser_)
        this->region (this->region_parser_->post_roadrunner_region_t ());

      return true;
    }

    return false;
  }

  // roadrunner_region_t_pskel
  //

  void roadrunner_region_t_pskel::
  id (int)
  {
  }

  void roadrunner_region_t_pskel::
  shape (const std::vector<sim_mob::LatLngLocation>&)
  {
  }

  bool roadrunner_region_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "id" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->id_parser_;

      if (this->id_parser_)
        this->id_parser_->pre ();

      return true;
    }

    if (n == "shape" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->shape_parser_;

      if (this->shape_parser_)
        this->shape_parser_->pre ();

      return true;
    }

    return false;
  }

  bool roadrunner_region_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
        this->id (this->id_parser_->post_int ());

      return true;
    }

    if (n == "shape" && ns.empty ())
    {
      if (this->shape_parser_)
        this->shape (this->shape_parser_->post_roadrunner_shape_t ());

      return true;
    }

    return false;
  }

  // roadrunner_vertex_t_pskel
  //

  void roadrunner_vertex_t_pskel::
  latitude (double)
  {
  }

  void roadrunner_vertex_t_pskel::
  longitude (double)
  {
  }

  bool roadrunner_vertex_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "latitude" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->latitude_parser_;

      if (this->latitude_parser_)
        this->latitude_parser_->pre ();

      return true;
    }

    if (n == "longitude" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->longitude_parser_;

      if (this->longitude_parser_)
        this->longitude_parser_->pre ();

      return true;
    }

    return false;
  }

  bool roadrunner_vertex_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "latitude" && ns.empty ())
    {
      if (this->latitude_parser_)
        this->latitude (this->latitude_parser_->post_double ());

      return true;
    }

    if (n == "longitude" && ns.empty ())
    {
      if (this->longitude_parser_)
        this->longitude (this->longitude_parser_->post_double ());

      return true;
    }

    return false;
  }

  // roadrunner_shape_t_pskel
  //

  void roadrunner_shape_t_pskel::
  vertex (const sim_mob::LatLngLocation&)
  {
  }

  bool roadrunner_shape_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "vertex" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->vertex_parser_;

      if (this->vertex_parser_)
        this->vertex_parser_->pre ();

      return true;
    }

    return false;
  }

  bool roadrunner_shape_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "vertex" && ns.empty ())
    {
      if (this->vertex_parser_)
        this->vertex (this->vertex_parser_->post_roadrunner_vertex_t ());

      return true;
    }

    return false;
  }

  // coordinate_map_t_pskel
  //

  void coordinate_map_t_pskel::
  utm_projection (sim_mob::UTM_Projection*)
  {
  }

  void coordinate_map_t_pskel::
  linear_scale (sim_mob::LinearScale*)
  {
  }

  bool coordinate_map_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "utm_projection" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->utm_projection_parser_;

      if (this->utm_projection_parser_)
        this->utm_projection_parser_->pre ();

      return true;
    }

    if (n == "linear_scale" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->linear_scale_parser_;

      if (this->linear_scale_parser_)
        this->linear_scale_parser_->pre ();

      return true;
    }

    return false;
  }

  bool coordinate_map_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "utm_projection" && ns.empty ())
    {
      if (this->utm_projection_parser_)
        this->utm_projection (this->utm_projection_parser_->post_utm_projection_t ());

      return true;
    }

    if (n == "linear_scale" && ns.empty ())
    {
      if (this->linear_scale_parser_)
        this->linear_scale (this->linear_scale_parser_->post_linear_scale_t ());

      return true;
    }

    return false;
  }

  // utm_projection_t_pskel
  //

  void utm_projection_t_pskel::
  coordinate_system (const ::std::string&)
  {
  }

  void utm_projection_t_pskel::
  utm_zone (const ::std::string&)
  {
  }

  bool utm_projection_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "coordinate_system" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->coordinate_system_parser_;

      if (this->coordinate_system_parser_)
        this->coordinate_system_parser_->pre ();

      return true;
    }

    if (n == "utm_zone" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->utm_zone_parser_;

      if (this->utm_zone_parser_)
        this->utm_zone_parser_->pre ();

      return true;
    }

    return false;
  }

  bool utm_projection_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "coordinate_system" && ns.empty ())
    {
      if (this->coordinate_system_parser_)
        this->coordinate_system (this->coordinate_system_parser_->post_string ());

      return true;
    }

    if (n == "utm_zone" && ns.empty ())
    {
      if (this->utm_zone_parser_)
        this->utm_zone (this->utm_zone_parser_->post_string ());

      return true;
    }

    return false;
  }

  // linear_scale_t_pskel
  //

  void linear_scale_t_pskel::
  source (const std::pair<sim_mob::LinearScale::Range, sim_mob::LinearScale::Range>&)
  {
  }

  void linear_scale_t_pskel::
  destination (const std::pair<sim_mob::LinearScale::Range, sim_mob::LinearScale::Range>&)
  {
  }

  bool linear_scale_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "source" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->source_parser_;

      if (this->source_parser_)
        this->source_parser_->pre ();

      return true;
    }

    if (n == "destination" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->destination_parser_;

      if (this->destination_parser_)
        this->destination_parser_->pre ();

      return true;
    }

    return false;
  }

  bool linear_scale_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "source" && ns.empty ())
    {
      if (this->source_parser_)
        this->source (this->source_parser_->post_scale_source_t ());

      return true;
    }

    if (n == "destination" && ns.empty ())
    {
      if (this->destination_parser_)
        this->destination (this->destination_parser_->post_scale_destination_t ());

      return true;
    }

    return false;
  }

  // scale_source_t_pskel
  //

  void scale_source_t_pskel::
  x_range (const ::std::string&)
  {
  }

  void scale_source_t_pskel::
  y_range (const ::std::string&)
  {
  }

  bool scale_source_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "x_range" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->x_range_parser_;

      if (this->x_range_parser_)
        this->x_range_parser_->pre ();

      return true;
    }

    if (n == "y_range" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->y_range_parser_;

      if (this->y_range_parser_)
        this->y_range_parser_->pre ();

      return true;
    }

    return false;
  }

  bool scale_source_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "x_range" && ns.empty ())
    {
      if (this->x_range_parser_)
        this->x_range (this->x_range_parser_->post_string ());

      return true;
    }

    if (n == "y_range" && ns.empty ())
    {
      if (this->y_range_parser_)
        this->y_range (this->y_range_parser_->post_string ());

      return true;
    }

    return false;
  }

  // scale_destination_t_pskel
  //

  void scale_destination_t_pskel::
  longitude_range (const ::std::string&)
  {
  }

  void scale_destination_t_pskel::
  latitude_range (const ::std::string&)
  {
  }

  bool scale_destination_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "longitude_range" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->longitude_range_parser_;

      if (this->longitude_range_parser_)
        this->longitude_range_parser_->pre ();

      return true;
    }

    if (n == "latitude_range" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->latitude_range_parser_;

      if (this->latitude_range_parser_)
        this->latitude_range_parser_->pre ();

      return true;
    }

    return false;
  }

  bool scale_destination_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "longitude_range" && ns.empty ())
    {
      if (this->longitude_range_parser_)
        this->longitude_range (this->longitude_range_parser_->post_string ());

      return true;
    }

    if (n == "latitude_range" && ns.empty ())
    {
      if (this->latitude_range_parser_)
        this->latitude_range (this->latitude_range_parser_->post_string ());

      return true;
    }

    return false;
  }

  // Point2D_t_pskel
  //

  void Point2D_t_pskel::
  xPos (unsigned int)
  {
  }

  void Point2D_t_pskel::
  yPos (unsigned int)
  {
  }

  bool Point2D_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "xPos" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->xPos_parser_;

      if (this->xPos_parser_)
        this->xPos_parser_->pre ();

      return true;
    }

    if (n == "yPos" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->yPos_parser_;

      if (this->yPos_parser_)
        this->yPos_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Point2D_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "xPos" && ns.empty ())
    {
      if (this->xPos_parser_)
        this->xPos (this->xPos_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "yPos" && ns.empty ())
    {
      if (this->yPos_parser_)
        this->yPos (this->yPos_parser_->post_unsigned_int ());

      return true;
    }

    return false;
  }

  // PolyPoint_t_pskel
  //

  void PolyPoint_t_pskel::
  pointID (const ::std::string&)
  {
  }

  void PolyPoint_t_pskel::
  location (sim_mob::Point2D)
  {
  }

  bool PolyPoint_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "pointID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->pointID_parser_;

      if (this->pointID_parser_)
        this->pointID_parser_->pre ();

      return true;
    }

    if (n == "location" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->location_parser_;

      if (this->location_parser_)
        this->location_parser_->pre ();

      return true;
    }

    return false;
  }

  bool PolyPoint_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "pointID" && ns.empty ())
    {
      if (this->pointID_parser_)
        this->pointID (this->pointID_parser_->post_string ());

      return true;
    }

    if (n == "location" && ns.empty ())
    {
      if (this->location_parser_)
        this->location (this->location_parser_->post_Point2D_t ());

      return true;
    }

    return false;
  }

  // PolyLine_t_pskel
  //

  void PolyLine_t_pskel::
  PolyPoint (sim_mob::Point2D)
  {
  }

  bool PolyLine_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "PolyPoint" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->PolyPoint_parser_;

      if (this->PolyPoint_parser_)
        this->PolyPoint_parser_->pre ();

      return true;
    }

    return false;
  }

  bool PolyLine_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "PolyPoint" && ns.empty ())
    {
      if (this->PolyPoint_parser_)
        this->PolyPoint (this->PolyPoint_parser_->post_PolyPoint_t ());

      return true;
    }

    return false;
  }

  // lane_t_pskel
  //

  void lane_t_pskel::
  laneID (unsigned long long)
  {
  }

  void lane_t_pskel::
  width (unsigned int)
  {
  }

  void lane_t_pskel::
  can_go_straight (bool)
  {
  }

  void lane_t_pskel::
  can_turn_left (bool)
  {
  }

  void lane_t_pskel::
  can_turn_right (bool)
  {
  }

  void lane_t_pskel::
  can_turn_on_red_signal (bool)
  {
  }

  void lane_t_pskel::
  can_change_lane_left (bool)
  {
  }

  void lane_t_pskel::
  can_change_lane_right (bool)
  {
  }

  void lane_t_pskel::
  is_road_shoulder (bool)
  {
  }

  void lane_t_pskel::
  is_bicycle_lane (bool)
  {
  }

  void lane_t_pskel::
  is_pedestrian_lane (bool)
  {
  }

  void lane_t_pskel::
  is_vehicle_lane (bool)
  {
  }

  void lane_t_pskel::
  is_standard_bus_lane (bool)
  {
  }

  void lane_t_pskel::
  is_whole_day_bus_lane (bool)
  {
  }

  void lane_t_pskel::
  is_high_occupancy_vehicle_lane (bool)
  {
  }

  void lane_t_pskel::
  can_freely_park_here (bool)
  {
  }

  void lane_t_pskel::
  can_stop_here (bool)
  {
  }

  void lane_t_pskel::
  is_u_turn_allowed (bool)
  {
  }

  void lane_t_pskel::
  PolyLine (std::vector<sim_mob::Point2D>)
  {
  }

  bool lane_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "laneID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->laneID_parser_;

      if (this->laneID_parser_)
        this->laneID_parser_->pre ();

      return true;
    }

    if (n == "width" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->width_parser_;

      if (this->width_parser_)
        this->width_parser_->pre ();

      return true;
    }

    if (n == "can_go_straight" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->can_go_straight_parser_;

      if (this->can_go_straight_parser_)
        this->can_go_straight_parser_->pre ();

      return true;
    }

    if (n == "can_turn_left" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->can_turn_left_parser_;

      if (this->can_turn_left_parser_)
        this->can_turn_left_parser_->pre ();

      return true;
    }

    if (n == "can_turn_right" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->can_turn_right_parser_;

      if (this->can_turn_right_parser_)
        this->can_turn_right_parser_->pre ();

      return true;
    }

    if (n == "can_turn_on_red_signal" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->can_turn_on_red_signal_parser_;

      if (this->can_turn_on_red_signal_parser_)
        this->can_turn_on_red_signal_parser_->pre ();

      return true;
    }

    if (n == "can_change_lane_left" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->can_change_lane_left_parser_;

      if (this->can_change_lane_left_parser_)
        this->can_change_lane_left_parser_->pre ();

      return true;
    }

    if (n == "can_change_lane_right" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->can_change_lane_right_parser_;

      if (this->can_change_lane_right_parser_)
        this->can_change_lane_right_parser_->pre ();

      return true;
    }

    if (n == "is_road_shoulder" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->is_road_shoulder_parser_;

      if (this->is_road_shoulder_parser_)
        this->is_road_shoulder_parser_->pre ();

      return true;
    }

    if (n == "is_bicycle_lane" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->is_bicycle_lane_parser_;

      if (this->is_bicycle_lane_parser_)
        this->is_bicycle_lane_parser_->pre ();

      return true;
    }

    if (n == "is_pedestrian_lane" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->is_pedestrian_lane_parser_;

      if (this->is_pedestrian_lane_parser_)
        this->is_pedestrian_lane_parser_->pre ();

      return true;
    }

    if (n == "is_vehicle_lane" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->is_vehicle_lane_parser_;

      if (this->is_vehicle_lane_parser_)
        this->is_vehicle_lane_parser_->pre ();

      return true;
    }

    if (n == "is_standard_bus_lane" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->is_standard_bus_lane_parser_;

      if (this->is_standard_bus_lane_parser_)
        this->is_standard_bus_lane_parser_->pre ();

      return true;
    }

    if (n == "is_whole_day_bus_lane" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->is_whole_day_bus_lane_parser_;

      if (this->is_whole_day_bus_lane_parser_)
        this->is_whole_day_bus_lane_parser_->pre ();

      return true;
    }

    if (n == "is_high_occupancy_vehicle_lane" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->is_high_occupancy_vehicle_lane_parser_;

      if (this->is_high_occupancy_vehicle_lane_parser_)
        this->is_high_occupancy_vehicle_lane_parser_->pre ();

      return true;
    }

    if (n == "can_freely_park_here" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->can_freely_park_here_parser_;

      if (this->can_freely_park_here_parser_)
        this->can_freely_park_here_parser_->pre ();

      return true;
    }

    if (n == "can_stop_here" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->can_stop_here_parser_;

      if (this->can_stop_here_parser_)
        this->can_stop_here_parser_->pre ();

      return true;
    }

    if (n == "is_u_turn_allowed" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->is_u_turn_allowed_parser_;

      if (this->is_u_turn_allowed_parser_)
        this->is_u_turn_allowed_parser_->pre ();

      return true;
    }

    if (n == "PolyLine" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->PolyLine_parser_;

      if (this->PolyLine_parser_)
        this->PolyLine_parser_->pre ();

      return true;
    }

    return false;
  }

  bool lane_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "laneID" && ns.empty ())
    {
      if (this->laneID_parser_)
        this->laneID (this->laneID_parser_->post_unsigned_long ());

      return true;
    }

    if (n == "width" && ns.empty ())
    {
      if (this->width_parser_)
        this->width (this->width_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "can_go_straight" && ns.empty ())
    {
      if (this->can_go_straight_parser_)
        this->can_go_straight (this->can_go_straight_parser_->post_boolean ());

      return true;
    }

    if (n == "can_turn_left" && ns.empty ())
    {
      if (this->can_turn_left_parser_)
        this->can_turn_left (this->can_turn_left_parser_->post_boolean ());

      return true;
    }

    if (n == "can_turn_right" && ns.empty ())
    {
      if (this->can_turn_right_parser_)
        this->can_turn_right (this->can_turn_right_parser_->post_boolean ());

      return true;
    }

    if (n == "can_turn_on_red_signal" && ns.empty ())
    {
      if (this->can_turn_on_red_signal_parser_)
        this->can_turn_on_red_signal (this->can_turn_on_red_signal_parser_->post_boolean ());

      return true;
    }

    if (n == "can_change_lane_left" && ns.empty ())
    {
      if (this->can_change_lane_left_parser_)
        this->can_change_lane_left (this->can_change_lane_left_parser_->post_boolean ());

      return true;
    }

    if (n == "can_change_lane_right" && ns.empty ())
    {
      if (this->can_change_lane_right_parser_)
        this->can_change_lane_right (this->can_change_lane_right_parser_->post_boolean ());

      return true;
    }

    if (n == "is_road_shoulder" && ns.empty ())
    {
      if (this->is_road_shoulder_parser_)
        this->is_road_shoulder (this->is_road_shoulder_parser_->post_boolean ());

      return true;
    }

    if (n == "is_bicycle_lane" && ns.empty ())
    {
      if (this->is_bicycle_lane_parser_)
        this->is_bicycle_lane (this->is_bicycle_lane_parser_->post_boolean ());

      return true;
    }

    if (n == "is_pedestrian_lane" && ns.empty ())
    {
      if (this->is_pedestrian_lane_parser_)
        this->is_pedestrian_lane (this->is_pedestrian_lane_parser_->post_boolean ());

      return true;
    }

    if (n == "is_vehicle_lane" && ns.empty ())
    {
      if (this->is_vehicle_lane_parser_)
        this->is_vehicle_lane (this->is_vehicle_lane_parser_->post_boolean ());

      return true;
    }

    if (n == "is_standard_bus_lane" && ns.empty ())
    {
      if (this->is_standard_bus_lane_parser_)
        this->is_standard_bus_lane (this->is_standard_bus_lane_parser_->post_boolean ());

      return true;
    }

    if (n == "is_whole_day_bus_lane" && ns.empty ())
    {
      if (this->is_whole_day_bus_lane_parser_)
        this->is_whole_day_bus_lane (this->is_whole_day_bus_lane_parser_->post_boolean ());

      return true;
    }

    if (n == "is_high_occupancy_vehicle_lane" && ns.empty ())
    {
      if (this->is_high_occupancy_vehicle_lane_parser_)
        this->is_high_occupancy_vehicle_lane (this->is_high_occupancy_vehicle_lane_parser_->post_boolean ());

      return true;
    }

    if (n == "can_freely_park_here" && ns.empty ())
    {
      if (this->can_freely_park_here_parser_)
        this->can_freely_park_here (this->can_freely_park_here_parser_->post_boolean ());

      return true;
    }

    if (n == "can_stop_here" && ns.empty ())
    {
      if (this->can_stop_here_parser_)
        this->can_stop_here (this->can_stop_here_parser_->post_boolean ());

      return true;
    }

    if (n == "is_u_turn_allowed" && ns.empty ())
    {
      if (this->is_u_turn_allowed_parser_)
        this->is_u_turn_allowed (this->is_u_turn_allowed_parser_->post_boolean ());

      return true;
    }

    if (n == "PolyLine" && ns.empty ())
    {
      if (this->PolyLine_parser_)
        this->PolyLine (this->PolyLine_parser_->post_PolyLine_t ());

      return true;
    }

    return false;
  }

  // connector_t_pskel
  //

  void connector_t_pskel::
  laneFrom (unsigned long long)
  {
  }

  void connector_t_pskel::
  laneTo (unsigned long long)
  {
  }

  bool connector_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "laneFrom" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->laneFrom_parser_;

      if (this->laneFrom_parser_)
        this->laneFrom_parser_->pre ();

      return true;
    }

    if (n == "laneTo" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->laneTo_parser_;

      if (this->laneTo_parser_)
        this->laneTo_parser_->pre ();

      return true;
    }

    return false;
  }

  bool connector_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "laneFrom" && ns.empty ())
    {
      if (this->laneFrom_parser_)
        this->laneFrom (this->laneFrom_parser_->post_unsigned_long ());

      return true;
    }

    if (n == "laneTo" && ns.empty ())
    {
      if (this->laneTo_parser_)
        this->laneTo (this->laneTo_parser_->post_unsigned_long ());

      return true;
    }

    return false;
  }

  // connectors_t_pskel
  //

  void connectors_t_pskel::
  Connector (std::pair<unsigned long,unsigned long>)
  {
  }

  bool connectors_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "Connector" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Connector_parser_;

      if (this->Connector_parser_)
        this->Connector_parser_->pre ();

      return true;
    }

    return false;
  }

  bool connectors_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "Connector" && ns.empty ())
    {
      if (this->Connector_parser_)
        this->Connector (this->Connector_parser_->post_connector_t ());

      return true;
    }

    return false;
  }


  // Multi_Connector_t_pskel
  //

  void Multi_Connector_t_pskel::
  RoadSegment (unsigned long long)
  {
  }

  void Multi_Connector_t_pskel::
  Connectors (std::set<std::pair<unsigned long,unsigned long> >)
  {
  }

  bool Multi_Connector_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "RoadSegment" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->RoadSegment_parser_;

      if (this->RoadSegment_parser_)
        this->RoadSegment_parser_->pre ();

      return true;
    }

    if (n == "Connectors" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Connectors_parser_;

      if (this->Connectors_parser_)
        this->Connectors_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Multi_Connector_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "RoadSegment" && ns.empty ())
    {
      if (this->RoadSegment_parser_)
        this->RoadSegment (this->RoadSegment_parser_->post_unsigned_long ());

      return true;
    }

    if (n == "Connectors" && ns.empty ())
    {
      if (this->Connectors_parser_)
        this->Connectors (this->Connectors_parser_->post_connectors_t ());

      return true;
    }

    return false;
  }

  // Multi_Connectors_t_pskel
  //

  void Multi_Connectors_t_pskel::
  MultiConnectors (const std::pair<unsigned long,std::set<std::pair<unsigned long,unsigned long> > >&)
  {
  }

  bool Multi_Connectors_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "MultiConnectors" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->MultiConnectors_parser_;

      if (this->MultiConnectors_parser_)
        this->MultiConnectors_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Multi_Connectors_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "MultiConnectors" && ns.empty ())
    {
      if (this->MultiConnectors_parser_)
        this->MultiConnectors (this->MultiConnectors_parser_->post_Multi_Connector_t ());

      return true;
    }

    return false;
  }

  // fwdBckSegments_t_pskel
  //

  void fwdBckSegments_t_pskel::
  Segment (sim_mob::RoadSegment*)
  {
  }

  bool fwdBckSegments_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "Segment" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Segment_parser_;

      if (this->Segment_parser_)
        this->Segment_parser_->pre ();

      return true;
    }

    return false;
  }

  bool fwdBckSegments_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "Segment" && ns.empty ())
    {
      if (this->Segment_parser_)
        this->Segment (this->Segment_parser_->post_segment_t ());

      return true;
    }

    return false;
  }

  // RoadSegmentsAt_t_pskel
  //

  void RoadSegmentsAt_t_pskel::
  segmentID (unsigned long long)
  {
  }

  bool RoadSegmentsAt_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "segmentID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->segmentID_parser_;

      if (this->segmentID_parser_)
        this->segmentID_parser_->pre ();

      return true;
    }

    return false;
  }

  bool RoadSegmentsAt_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "segmentID" && ns.empty ())
    {
      if (this->segmentID_parser_)
        this->segmentID (this->segmentID_parser_->post_unsigned_long ());

      return true;
    }

    return false;
  }

  // laneEdgePolyline_cached_t_pskel
  //

  void laneEdgePolyline_cached_t_pskel::
  laneNumber (short)
  {
  }

  void laneEdgePolyline_cached_t_pskel::
  polyline (std::vector<sim_mob::Point2D>)
  {
  }

  bool laneEdgePolyline_cached_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "laneNumber" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->laneNumber_parser_;

      if (this->laneNumber_parser_)
        this->laneNumber_parser_->pre ();

      return true;
    }

    if (n == "polyline" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->polyline_parser_;

      if (this->polyline_parser_)
        this->polyline_parser_->pre ();

      return true;
    }

    return false;
  }

  bool laneEdgePolyline_cached_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "laneNumber" && ns.empty ())
    {
      if (this->laneNumber_parser_)
        this->laneNumber (this->laneNumber_parser_->post_short ());

      return true;
    }

    if (n == "polyline" && ns.empty ())
    {
      if (this->polyline_parser_)
        this->polyline (this->polyline_parser_->post_PolyLine_t ());

      return true;
    }

    return false;
  }

  // laneEdgePolylines_cached_t_pskel
  //

  void laneEdgePolylines_cached_t_pskel::
  laneEdgePolyline_cached (std::pair<short,std::vector<sim_mob::Point2D> >)
  {
  }

  bool laneEdgePolylines_cached_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "laneEdgePolyline_cached" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->laneEdgePolyline_cached_parser_;

      if (this->laneEdgePolyline_cached_parser_)
        this->laneEdgePolyline_cached_parser_->pre ();

      return true;
    }

    return false;
  }

  bool laneEdgePolylines_cached_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "laneEdgePolyline_cached" && ns.empty ())
    {
      if (this->laneEdgePolyline_cached_parser_)
        this->laneEdgePolyline_cached (this->laneEdgePolyline_cached_parser_->post_laneEdgePolyline_cached_t ());

      return true;
    }

    return false;
  }

  // segment_t_pskel
  //

  void segment_t_pskel::
  segmentID (unsigned long long)
  {
  }

  void segment_t_pskel::
  startingNode (unsigned int)
  {
  }

  void segment_t_pskel::
  endingNode (unsigned int)
  {
  }

  void segment_t_pskel::
  maxSpeed (short)
  {
  }

  void segment_t_pskel::
  Length (unsigned int)
  {
  }

  void segment_t_pskel::
  Width (unsigned int)
  {
  }

  void segment_t_pskel::
  originalDB_ID (const ::std::string&)
  {
  }

  void segment_t_pskel::
  polyline (std::vector<sim_mob::Point2D>)
  {
  }

  void segment_t_pskel::
  laneEdgePolylines_cached (std::vector<std::vector<sim_mob::Point2D> >)
  {
  }

  void segment_t_pskel::
  Lanes (std::vector<sim_mob::Lane*>)
  {
  }

  void segment_t_pskel::
  Obstacles (std::map<sim_mob::centimeter_t,const RoadItem*>)
  {
  }

  void segment_t_pskel::
  KurbLine (std::vector<sim_mob::Point2D>)
  {
  }

  bool segment_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "segmentID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->segmentID_parser_;

      if (this->segmentID_parser_)
        this->segmentID_parser_->pre ();

      return true;
    }

    if (n == "startingNode" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->startingNode_parser_;

      if (this->startingNode_parser_)
        this->startingNode_parser_->pre ();

      return true;
    }

    if (n == "endingNode" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->endingNode_parser_;

      if (this->endingNode_parser_)
        this->endingNode_parser_->pre ();

      return true;
    }

    if (n == "maxSpeed" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->maxSpeed_parser_;

      if (this->maxSpeed_parser_)
        this->maxSpeed_parser_->pre ();

      return true;
    }

    if (n == "Length" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Length_parser_;

      if (this->Length_parser_)
        this->Length_parser_->pre ();

      return true;
    }

    if (n == "Width" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Width_parser_;

      if (this->Width_parser_)
        this->Width_parser_->pre ();

      return true;
    }

    if (n == "originalDB_ID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->originalDB_ID_parser_;

      if (this->originalDB_ID_parser_)
        this->originalDB_ID_parser_->pre ();

      return true;
    }

    if (n == "polyline" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->polyline_parser_;

      if (this->polyline_parser_)
        this->polyline_parser_->pre ();

      return true;
    }

    if (n == "laneEdgePolylines_cached" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->laneEdgePolylines_cached_parser_;

      if (this->laneEdgePolylines_cached_parser_)
        this->laneEdgePolylines_cached_parser_->pre ();

      return true;
    }

    if (n == "Lanes" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Lanes_parser_;

      if (this->Lanes_parser_)
        this->Lanes_parser_->pre ();

      return true;
    }

    if (n == "Obstacles" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Obstacles_parser_;

      if (this->Obstacles_parser_)
        this->Obstacles_parser_->pre ();

      return true;
    }

    if (n == "KurbLine" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->KurbLine_parser_;

      if (this->KurbLine_parser_)
        this->KurbLine_parser_->pre ();

      return true;
    }

    return false;
  }

  bool segment_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "segmentID" && ns.empty ())
    {
      if (this->segmentID_parser_)
        this->segmentID (this->segmentID_parser_->post_unsigned_long ());

      return true;
    }

    if (n == "startingNode" && ns.empty ())
    {
      if (this->startingNode_parser_)
        this->startingNode (this->startingNode_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "endingNode" && ns.empty ())
    {
      if (this->endingNode_parser_)
        this->endingNode (this->endingNode_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "maxSpeed" && ns.empty ())
    {
      if (this->maxSpeed_parser_)
        this->maxSpeed (this->maxSpeed_parser_->post_short ());

      return true;
    }

    if (n == "Length" && ns.empty ())
    {
      if (this->Length_parser_)
        this->Length (this->Length_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "Width" && ns.empty ())
    {
      if (this->Width_parser_)
        this->Width (this->Width_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "originalDB_ID" && ns.empty ())
    {
      if (this->originalDB_ID_parser_)
        this->originalDB_ID (this->originalDB_ID_parser_->post_string ());

      return true;
    }

    if (n == "polyline" && ns.empty ())
    {
      if (this->polyline_parser_)
        this->polyline (this->polyline_parser_->post_PolyLine_t ());

      return true;
    }

    if (n == "laneEdgePolylines_cached" && ns.empty ())
    {
      if (this->laneEdgePolylines_cached_parser_)
        this->laneEdgePolylines_cached (this->laneEdgePolylines_cached_parser_->post_laneEdgePolylines_cached_t ());

      return true;
    }

    if (n == "Lanes" && ns.empty ())
    {
      if (this->Lanes_parser_)
        this->Lanes (this->Lanes_parser_->post_Lanes ());

      return true;
    }

    if (n == "Obstacles" && ns.empty ())
    {
      if (this->Obstacles_parser_)
        this->Obstacles (this->Obstacles_parser_->post_RoadItems_t ());

      return true;
    }

    if (n == "KurbLine" && ns.empty ())
    {
      if (this->KurbLine_parser_)
        this->KurbLine (this->KurbLine_parser_->post_PolyLine_t ());

      return true;
    }

    return false;
  }

  // link_t_pskel
  //

  void link_t_pskel::
  linkID (unsigned int)
  {
  }

  void link_t_pskel::
  roadName (const ::std::string&)
  {
  }

  void link_t_pskel::
  StartingNode (unsigned int)
  {
  }

  void link_t_pskel::
  EndingNode (unsigned int)
  {
  }

  void link_t_pskel::
  Segments (std::vector<sim_mob::RoadSegment*>)
  {
  }

  bool link_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "linkID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->linkID_parser_;

      if (this->linkID_parser_)
        this->linkID_parser_->pre ();

      return true;
    }

    if (n == "roadName" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->roadName_parser_;

      if (this->roadName_parser_)
        this->roadName_parser_->pre ();

      return true;
    }

    if (n == "StartingNode" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->StartingNode_parser_;

      if (this->StartingNode_parser_)
        this->StartingNode_parser_->pre ();

      return true;
    }

    if (n == "EndingNode" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->EndingNode_parser_;

      if (this->EndingNode_parser_)
        this->EndingNode_parser_->pre ();

      return true;
    }

    if (n == "Segments" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Segments_parser_;

      if (this->Segments_parser_)
        this->Segments_parser_->pre ();

      return true;
    }

    return false;
  }

  bool link_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "linkID" && ns.empty ())
    {
      if (this->linkID_parser_)
        this->linkID (this->linkID_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "roadName" && ns.empty ())
    {
      if (this->roadName_parser_)
        this->roadName (this->roadName_parser_->post_string ());

      return true;
    }

    if (n == "StartingNode" && ns.empty ())
    {
      if (this->StartingNode_parser_)
        this->StartingNode (this->StartingNode_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "EndingNode" && ns.empty ())
    {
      if (this->EndingNode_parser_)
        this->EndingNode (this->EndingNode_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "Segments" && ns.empty ())
    {
      if (this->Segments_parser_)
        this->Segments (this->Segments_parser_->post_fwdBckSegments_t ());

      return true;
    }

    return false;
  }

  // separator_t_pskel
  //

  void separator_t_pskel::
  separator_ID (unsigned short)
  {
  }

  void separator_t_pskel::
  separator_value (bool)
  {
  }

  void separator_t_pskel::
  post_separator_t ()
  {
  }

  bool separator_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "separator_ID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->separator_ID_parser_;

      if (this->separator_ID_parser_)
        this->separator_ID_parser_->pre ();

      return true;
    }

    if (n == "separator_value" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->separator_value_parser_;

      if (this->separator_value_parser_)
        this->separator_value_parser_->pre ();

      return true;
    }

    return false;
  }

  bool separator_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "separator_ID" && ns.empty ())
    {
      if (this->separator_ID_parser_)
        this->separator_ID (this->separator_ID_parser_->post_unsigned_short ());

      return true;
    }

    if (n == "separator_value" && ns.empty ())
    {
      if (this->separator_value_parser_)
        this->separator_value (this->separator_value_parser_->post_boolean ());

      return true;
    }

    return false;
  }

  // separators_t_pskel
  //

  void separators_t_pskel::
  Separator ()
  {
  }

  void separators_t_pskel::
  post_separators_t ()
  {
  }

  bool separators_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "Separator" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Separator_parser_;

      if (this->Separator_parser_)
        this->Separator_parser_->pre ();

      return true;
    }

    return false;
  }

  bool separators_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "Separator" && ns.empty ())
    {
      if (this->Separator_parser_)
      {
        this->Separator_parser_->post_separator_t ();
        this->Separator ();
      }

      return true;
    }

    return false;
  }

  // DomainIsland_t_pskel
  //

  void DomainIsland_t_pskel::
  domainIsland_ID (unsigned short)
  {
  }

  void DomainIsland_t_pskel::
  domainIsland_value (bool)
  {
  }

  void DomainIsland_t_pskel::
  post_DomainIsland_t ()
  {
  }

  bool DomainIsland_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "domainIsland_ID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->domainIsland_ID_parser_;

      if (this->domainIsland_ID_parser_)
        this->domainIsland_ID_parser_->pre ();

      return true;
    }

    if (n == "domainIsland_value" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->domainIsland_value_parser_;

      if (this->domainIsland_value_parser_)
        this->domainIsland_value_parser_->pre ();

      return true;
    }

    return false;
  }

  bool DomainIsland_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "domainIsland_ID" && ns.empty ())
    {
      if (this->domainIsland_ID_parser_)
        this->domainIsland_ID (this->domainIsland_ID_parser_->post_unsigned_short ());

      return true;
    }

    if (n == "domainIsland_value" && ns.empty ())
    {
      if (this->domainIsland_value_parser_)
        this->domainIsland_value (this->domainIsland_value_parser_->post_boolean ());

      return true;
    }

    return false;
  }

  // DomainIslands_t_pskel
  //

  void DomainIslands_t_pskel::
  domainIslands ()
  {
  }

  void DomainIslands_t_pskel::
  post_DomainIslands_t ()
  {
  }

  bool DomainIslands_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "domainIslands" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->domainIslands_parser_;

      if (this->domainIslands_parser_)
        this->domainIslands_parser_->pre ();

      return true;
    }

    return false;
  }

  bool DomainIslands_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "domainIslands" && ns.empty ())
    {
      if (this->domainIslands_parser_)
      {
        this->domainIslands_parser_->post_DomainIsland_t ();
        this->domainIslands ();
      }

      return true;
    }

    return false;
  }

  // offset_t_pskel
  //

  void offset_t_pskel::
  offset_ID (unsigned short)
  {
  }

  void offset_t_pskel::
  offset_value (unsigned int)
  {
  }

  void offset_t_pskel::
  post_offset_t ()
  {
  }

  bool offset_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "offset_ID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->offset_ID_parser_;

      if (this->offset_ID_parser_)
        this->offset_ID_parser_->pre ();

      return true;
    }

    if (n == "offset_value" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->offset_value_parser_;

      if (this->offset_value_parser_)
        this->offset_value_parser_->pre ();

      return true;
    }

    return false;
  }

  bool offset_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "offset_ID" && ns.empty ())
    {
      if (this->offset_ID_parser_)
        this->offset_ID (this->offset_ID_parser_->post_unsigned_short ());

      return true;
    }

    if (n == "offset_value" && ns.empty ())
    {
      if (this->offset_value_parser_)
        this->offset_value (this->offset_value_parser_->post_unsigned_int ());

      return true;
    }

    return false;
  }

  // offsets_t_pskel
  //

  void offsets_t_pskel::
  offset ()
  {
  }

  void offsets_t_pskel::
  post_offsets_t ()
  {
  }

  bool offsets_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "offset" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->offset_parser_;

      if (this->offset_parser_)
        this->offset_parser_->pre ();

      return true;
    }

    return false;
  }

  bool offsets_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "offset" && ns.empty ())
    {
      if (this->offset_parser_)
      {
        this->offset_parser_->post_offset_t ();
        this->offset ();
      }

      return true;
    }

    return false;
  }

  // ChunkLength_t_pskel
  //

  void ChunkLength_t_pskel::
  chunklength_ID (unsigned short)
  {
  }

  void ChunkLength_t_pskel::
  chunklength_value (unsigned int)
  {
  }

  void ChunkLength_t_pskel::
  post_ChunkLength_t ()
  {
  }

  bool ChunkLength_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "chunklength_ID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->chunklength_ID_parser_;

      if (this->chunklength_ID_parser_)
        this->chunklength_ID_parser_->pre ();

      return true;
    }

    if (n == "chunklength_value" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->chunklength_value_parser_;

      if (this->chunklength_value_parser_)
        this->chunklength_value_parser_->pre ();

      return true;
    }

    return false;
  }

  bool ChunkLength_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "chunklength_ID" && ns.empty ())
    {
      if (this->chunklength_ID_parser_)
        this->chunklength_ID (this->chunklength_ID_parser_->post_unsigned_short ());

      return true;
    }

    if (n == "chunklength_value" && ns.empty ())
    {
      if (this->chunklength_value_parser_)
        this->chunklength_value (this->chunklength_value_parser_->post_unsigned_int ());

      return true;
    }

    return false;
  }

  // ChunkLengths_t_pskel
  //

  void ChunkLengths_t_pskel::
  chunklength ()
  {
  }

  void ChunkLengths_t_pskel::
  post_ChunkLengths_t ()
  {
  }

  bool ChunkLengths_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "chunklength" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->chunklength_parser_;

      if (this->chunklength_parser_)
        this->chunklength_parser_->pre ();

      return true;
    }

    return false;
  }

  bool ChunkLengths_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "chunklength" && ns.empty ())
    {
      if (this->chunklength_parser_)
      {
        this->chunklength_parser_->post_ChunkLength_t ();
        this->chunklength ();
      }

      return true;
    }

    return false;
  }

  // LanesVector_t_pskel
  //

  void LanesVector_t_pskel::
  laneID (unsigned long long)
  {
  }

  void LanesVector_t_pskel::
  post_LanesVector_t ()
  {
  }

  bool LanesVector_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "laneID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->laneID_parser_;

      if (this->laneID_parser_)
        this->laneID_parser_->pre ();

      return true;
    }

    return false;
  }

  bool LanesVector_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "laneID" && ns.empty ())
    {
      if (this->laneID_parser_)
        this->laneID (this->laneID_parser_->post_unsigned_long ());

      return true;
    }

    return false;
  }

  // EntranceAngle_t_pskel
  //

  void EntranceAngle_t_pskel::
  entranceAngle_ID (unsigned short)
  {
  }

  void EntranceAngle_t_pskel::
  entranceAngle_value (unsigned int)
  {
  }

  void EntranceAngle_t_pskel::
  post_EntranceAngle_t ()
  {
  }

  bool EntranceAngle_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "entranceAngle_ID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->entranceAngle_ID_parser_;

      if (this->entranceAngle_ID_parser_)
        this->entranceAngle_ID_parser_->pre ();

      return true;
    }

    if (n == "entranceAngle_value" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->entranceAngle_value_parser_;

      if (this->entranceAngle_value_parser_)
        this->entranceAngle_value_parser_->pre ();

      return true;
    }

    return false;
  }

  bool EntranceAngle_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "entranceAngle_ID" && ns.empty ())
    {
      if (this->entranceAngle_ID_parser_)
        this->entranceAngle_ID (this->entranceAngle_ID_parser_->post_unsigned_short ());

      return true;
    }

    if (n == "entranceAngle_value" && ns.empty ())
    {
      if (this->entranceAngle_value_parser_)
        this->entranceAngle_value (this->entranceAngle_value_parser_->post_unsigned_int ());

      return true;
    }

    return false;
  }

  // EntranceAngles_t_pskel
  //

  void EntranceAngles_t_pskel::
  entranceAngle ()
  {
  }

  void EntranceAngles_t_pskel::
  post_EntranceAngles_t ()
  {
  }

  bool EntranceAngles_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "entranceAngle" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->entranceAngle_parser_;

      if (this->entranceAngle_parser_)
        this->entranceAngle_parser_->pre ();

      return true;
    }

    return false;
  }

  bool EntranceAngles_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "entranceAngle" && ns.empty ())
    {
      if (this->entranceAngle_parser_)
      {
        this->entranceAngle_parser_->post_EntranceAngle_t ();
        this->entranceAngle ();
      }

      return true;
    }

    return false;
  }

  // Node_t_pskel
  //

  void Node_t_pskel::
  nodeID (unsigned int)
  {
  }

  void Node_t_pskel::
  location (sim_mob::Point2D)
  {
  }

  void Node_t_pskel::
  originalDB_ID (const ::std::string&)
  {
  }

  bool Node_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "nodeID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->nodeID_parser_;

      if (this->nodeID_parser_)
        this->nodeID_parser_->pre ();

      return true;
    }

    if (n == "location" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->location_parser_;

      if (this->location_parser_)
        this->location_parser_->pre ();

      return true;
    }

    if (n == "originalDB_ID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->originalDB_ID_parser_;

      if (this->originalDB_ID_parser_)
        this->originalDB_ID_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Node_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "nodeID" && ns.empty ())
    {
      if (this->nodeID_parser_)
        this->nodeID (this->nodeID_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "location" && ns.empty ())
    {
      if (this->location_parser_)
        this->location (this->location_parser_->post_Point2D_t ());

      return true;
    }

    if (n == "originalDB_ID" && ns.empty ())
    {
      if (this->originalDB_ID_parser_)
        this->originalDB_ID (this->originalDB_ID_parser_->post_string ());

      return true;
    }

    return false;
  }

  // temp_Segmetair_t_pskel
  //

  void temp_Segmetair_t_pskel::
  first (unsigned long long)
  {
  }

  void temp_Segmetair_t_pskel::
  second (unsigned long long)
  {
  }

  bool temp_Segmetair_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "first" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->first_parser_;

      if (this->first_parser_)
        this->first_parser_->pre ();

      return true;
    }

    if (n == "second" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->second_parser_;

      if (this->second_parser_)
        this->second_parser_->pre ();

      return true;
    }

    return false;
  }

  bool temp_Segmetair_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "first" && ns.empty ())
    {
      if (this->first_parser_)
        this->first (this->first_parser_->post_unsigned_long ());

      return true;
    }

    if (n == "second" && ns.empty ())
    {
      if (this->second_parser_)
        this->second (this->second_parser_->post_unsigned_long ());

      return true;
    }

    return false;
  }

  // UniNode_t_pskel
  //

  void UniNode_t_pskel::
  firstPair (std::pair<unsigned long,unsigned long>)
  {
  }

  void UniNode_t_pskel::
  secondPair (std::pair<unsigned long,unsigned long>)
  {
  }

  void UniNode_t_pskel::
  Connectors (std::set<std::pair<unsigned long,unsigned long> >)
  {
  }


  bool UniNode_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::sim_mob::xml::Node_t_pskel::_start_element_impl (ns, n, t))
      return true;

    if (n == "firstPair" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->firstPair_parser_;

      if (this->firstPair_parser_)
        this->firstPair_parser_->pre ();

      return true;
    }

    if (n == "secondPair" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->secondPair_parser_;

      if (this->secondPair_parser_)
        this->secondPair_parser_->pre ();

      return true;
    }

    if (n == "Connectors" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Connectors_parser_;

      if (this->Connectors_parser_)
        this->Connectors_parser_->pre ();

      return true;
    }

    return false;
  }

  bool UniNode_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::sim_mob::xml::Node_t_pskel::_end_element_impl (ns, n))
      return true;

    if (n == "firstPair" && ns.empty ())
    {
      if (this->firstPair_parser_)
        this->firstPair (this->firstPair_parser_->post_temp_Segmetair_t ());

      return true;
    }

    if (n == "secondPair" && ns.empty ())
    {
      if (this->secondPair_parser_)
        this->secondPair (this->secondPair_parser_->post_temp_Segmetair_t ());

      return true;
    }

    if (n == "Connectors" && ns.empty ())
    {
      if (this->Connectors_parser_)
        this->Connectors (this->Connectors_parser_->post_connectors_t ());

      return true;
    }


    return false;
  }

  // roundabout_t_pskel
  //

  void roundabout_t_pskel::
  roadSegmentsAt (std::set<unsigned long>)
  {
  }

  void roundabout_t_pskel::
  Connectors (const std::map<unsigned long,std::set<std::pair<unsigned long,unsigned long> > >&)
  {
  }

  void roundabout_t_pskel::
  ChunkLengths ()
  {
  }

  void roundabout_t_pskel::
  Offsets ()
  {
  }

  void roundabout_t_pskel::
  Separators ()
  {
  }

  void roundabout_t_pskel::
  addDominantLane ()
  {
  }

  void roundabout_t_pskel::
  roundaboutDominantIslands (float)
  {
  }

  void roundabout_t_pskel::
  roundaboutNumberOfLanes (int)
  {
  }

  void roundabout_t_pskel::
  entranceAngles ()
  {
  }

  bool roundabout_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::sim_mob::xml::Node_t_pskel::_start_element_impl (ns, n, t))
      return true;

    if (n == "roadSegmentsAt" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->roadSegmentsAt_parser_;

      if (this->roadSegmentsAt_parser_)
        this->roadSegmentsAt_parser_->pre ();

      return true;
    }

    if (n == "Connectors" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Connectors_parser_;

      if (this->Connectors_parser_)
        this->Connectors_parser_->pre ();

      return true;
    }

    if (n == "ChunkLengths" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->ChunkLengths_parser_;

      if (this->ChunkLengths_parser_)
        this->ChunkLengths_parser_->pre ();

      return true;
    }

    if (n == "Offsets" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Offsets_parser_;

      if (this->Offsets_parser_)
        this->Offsets_parser_->pre ();

      return true;
    }

    if (n == "Separators" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Separators_parser_;

      if (this->Separators_parser_)
        this->Separators_parser_->pre ();

      return true;
    }

    if (n == "addDominantLane" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->addDominantLane_parser_;

      if (this->addDominantLane_parser_)
        this->addDominantLane_parser_->pre ();

      return true;
    }

    if (n == "roundaboutDominantIslands" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->roundaboutDominantIslands_parser_;

      if (this->roundaboutDominantIslands_parser_)
        this->roundaboutDominantIslands_parser_->pre ();

      return true;
    }

    if (n == "roundaboutNumberOfLanes" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->roundaboutNumberOfLanes_parser_;

      if (this->roundaboutNumberOfLanes_parser_)
        this->roundaboutNumberOfLanes_parser_->pre ();

      return true;
    }

    if (n == "entranceAngles" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->entranceAngles_parser_;

      if (this->entranceAngles_parser_)
        this->entranceAngles_parser_->pre ();

      return true;
    }

    return false;
  }

  bool roundabout_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::sim_mob::xml::Node_t_pskel::_end_element_impl (ns, n))
      return true;

    if (n == "roadSegmentsAt" && ns.empty ())
    {
      if (this->roadSegmentsAt_parser_)
        this->roadSegmentsAt (this->roadSegmentsAt_parser_->post_RoadSegmentsAt_t ());

      return true;
    }

    if (n == "Connectors" && ns.empty ())
    {
      if (this->Connectors_parser_)
        this->Connectors (this->Connectors_parser_->post_Multi_Connectors_t ());

      return true;
    }

    if (n == "ChunkLengths" && ns.empty ())
    {
      if (this->ChunkLengths_parser_)
      {
        this->ChunkLengths_parser_->post_ChunkLengths_t ();
        this->ChunkLengths ();
      }

      return true;
    }

    if (n == "Offsets" && ns.empty ())
    {
      if (this->Offsets_parser_)
      {
        this->Offsets_parser_->post_offsets_t ();
        this->Offsets ();
      }

      return true;
    }

    if (n == "Separators" && ns.empty ())
    {
      if (this->Separators_parser_)
      {
        this->Separators_parser_->post_separators_t ();
        this->Separators ();
      }

      return true;
    }

    if (n == "addDominantLane" && ns.empty ())
    {
      if (this->addDominantLane_parser_)
      {
        this->addDominantLane_parser_->post_LanesVector_t ();
        this->addDominantLane ();
      }

      return true;
    }

    if (n == "roundaboutDominantIslands" && ns.empty ())
    {
      if (this->roundaboutDominantIslands_parser_)
        this->roundaboutDominantIslands (this->roundaboutDominantIslands_parser_->post_float ());

      return true;
    }

    if (n == "roundaboutNumberOfLanes" && ns.empty ())
    {
      if (this->roundaboutNumberOfLanes_parser_)
        this->roundaboutNumberOfLanes (this->roundaboutNumberOfLanes_parser_->post_int ());

      return true;
    }

    if (n == "entranceAngles" && ns.empty ())
    {
      if (this->entranceAngles_parser_)
      {
        this->entranceAngles_parser_->post_EntranceAngles_t ();
        this->entranceAngles ();
      }

      return true;
    }

    return false;
  }

  // intersection_t_pskel
  //

  void intersection_t_pskel::
  roadSegmentsAt (std::set<unsigned long>)
  {
  }

  void intersection_t_pskel::
  Connectors (const std::map<unsigned long,std::set<std::pair<unsigned long,unsigned long> > >&)
  {
  }

  void intersection_t_pskel::
  ChunkLengths ()
  {
  }

  void intersection_t_pskel::
  Offsets ()
  {
  }

  void intersection_t_pskel::
  Separators ()
  {
  }

  void intersection_t_pskel::
  additionalDominantLanes ()
  {
  }

  void intersection_t_pskel::
  additionalSubdominantLanes ()
  {
  }

  void intersection_t_pskel::
  domainIslands ()
  {
  }

  bool intersection_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::sim_mob::xml::Node_t_pskel::_start_element_impl (ns, n, t))
      return true;

    if (n == "roadSegmentsAt" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->roadSegmentsAt_parser_;

      if (this->roadSegmentsAt_parser_)
        this->roadSegmentsAt_parser_->pre ();

      return true;
    }

    if (n == "Connectors" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Connectors_parser_;

      if (this->Connectors_parser_)
        this->Connectors_parser_->pre ();

      return true;
    }

    if (n == "ChunkLengths" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->ChunkLengths_parser_;

      if (this->ChunkLengths_parser_)
        this->ChunkLengths_parser_->pre ();

      return true;
    }

    if (n == "Offsets" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Offsets_parser_;

      if (this->Offsets_parser_)
        this->Offsets_parser_->pre ();

      return true;
    }

    if (n == "Separators" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Separators_parser_;

      if (this->Separators_parser_)
        this->Separators_parser_->pre ();

      return true;
    }

    if (n == "additionalDominantLanes" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->additionalDominantLanes_parser_;

      if (this->additionalDominantLanes_parser_)
        this->additionalDominantLanes_parser_->pre ();

      return true;
    }

    if (n == "additionalSubdominantLanes" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->additionalSubdominantLanes_parser_;

      if (this->additionalSubdominantLanes_parser_)
        this->additionalSubdominantLanes_parser_->pre ();

      return true;
    }

    if (n == "domainIslands" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->domainIslands_parser_;

      if (this->domainIslands_parser_)
        this->domainIslands_parser_->pre ();

      return true;
    }

    return false;
  }

  bool intersection_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::sim_mob::xml::Node_t_pskel::_end_element_impl (ns, n))
      return true;

    if (n == "roadSegmentsAt" && ns.empty ())
    {
      if (this->roadSegmentsAt_parser_)
        this->roadSegmentsAt (this->roadSegmentsAt_parser_->post_RoadSegmentsAt_t ());

      return true;
    }

    if (n == "Connectors" && ns.empty ())
    {
      if (this->Connectors_parser_)
        this->Connectors (this->Connectors_parser_->post_Multi_Connectors_t ());

      return true;
    }

    if (n == "ChunkLengths" && ns.empty ())
    {
      if (this->ChunkLengths_parser_)
      {
        this->ChunkLengths_parser_->post_ChunkLengths_t ();
        this->ChunkLengths ();
      }

      return true;
    }

    if (n == "Offsets" && ns.empty ())
    {
      if (this->Offsets_parser_)
      {
        this->Offsets_parser_->post_offsets_t ();
        this->Offsets ();
      }

      return true;
    }

    if (n == "Separators" && ns.empty ())
    {
      if (this->Separators_parser_)
      {
        this->Separators_parser_->post_separators_t ();
        this->Separators ();
      }

      return true;
    }

    if (n == "additionalDominantLanes" && ns.empty ())
    {
      if (this->additionalDominantLanes_parser_)
      {
        this->additionalDominantLanes_parser_->post_LanesVector_t ();
        this->additionalDominantLanes ();
      }

      return true;
    }

    if (n == "additionalSubdominantLanes" && ns.empty ())
    {
      if (this->additionalSubdominantLanes_parser_)
      {
        this->additionalSubdominantLanes_parser_->post_LanesVector_t ();
        this->additionalSubdominantLanes ();
      }

      return true;
    }

    if (n == "domainIslands" && ns.empty ())
    {
      if (this->domainIslands_parser_)
      {
        this->domainIslands_parser_->post_DomainIslands_t ();
        this->domainIslands ();
      }

      return true;
    }

    return false;
  }

  // RoadItem_t_pskel
  //

  void RoadItem_t_pskel::
  id (unsigned long long)
  {
  }

  void RoadItem_t_pskel::
  Offset (unsigned short)
  {
  }

  void RoadItem_t_pskel::
  start (sim_mob::Point2D)
  {
  }

  void RoadItem_t_pskel::
  end (sim_mob::Point2D)
  {
  }

  bool RoadItem_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "id" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->id_parser_;

      if (this->id_parser_)
        this->id_parser_->pre ();

      return true;
    }

    if (n == "Offset" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Offset_parser_;

      if (this->Offset_parser_)
        this->Offset_parser_->pre ();

      return true;
    }

    if (n == "start" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->start_parser_;

      if (this->start_parser_)
        this->start_parser_->pre ();

      return true;
    }

    if (n == "end" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->end_parser_;

      if (this->end_parser_)
        this->end_parser_->pre ();

      return true;
    }

    return false;
  }

  bool RoadItem_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
        this->id (this->id_parser_->post_unsigned_long ());

      return true;
    }

    if (n == "Offset" && ns.empty ())
    {
      if (this->Offset_parser_)
        this->Offset (this->Offset_parser_->post_unsigned_short ());

      return true;
    }

    if (n == "start" && ns.empty ())
    {
      if (this->start_parser_)
        this->start (this->start_parser_->post_Point2D_t ());

      return true;
    }

    if (n == "end" && ns.empty ())
    {
      if (this->end_parser_)
        this->end (this->end_parser_->post_Point2D_t ());

      return true;
    }

    return false;
  }

  // BusStop_t_pskel
  //

  void BusStop_t_pskel::
  xPos (double)
  {
  }

  void BusStop_t_pskel::
  yPos (double)
  {
  }

  void BusStop_t_pskel::
  lane_location (unsigned long long)
  {
  }

  void BusStop_t_pskel::
  is_terminal (bool)
  {
  }

  void BusStop_t_pskel::
  is_bay (bool)
  {
  }

  void BusStop_t_pskel::
  has_shelter (bool)
  {
  }

  void BusStop_t_pskel::
  busCapacityAsLength (unsigned int)
  {
  }

  void BusStop_t_pskel::
  busstopno (const ::std::string&)
  {
  }

  bool BusStop_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::sim_mob::xml::RoadItem_t_pskel::_start_element_impl (ns, n, t))
      return true;

    if (n == "xPos" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->xPos_parser_;

      if (this->xPos_parser_)
        this->xPos_parser_->pre ();

      return true;
    }

    if (n == "yPos" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->yPos_parser_;

      if (this->yPos_parser_)
        this->yPos_parser_->pre ();

      return true;
    }

    if (n == "lane_location" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->lane_location_parser_;

      if (this->lane_location_parser_)
        this->lane_location_parser_->pre ();

      return true;
    }

    if (n == "is_terminal" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->is_terminal_parser_;

      if (this->is_terminal_parser_)
        this->is_terminal_parser_->pre ();

      return true;
    }

    if (n == "is_bay" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->is_bay_parser_;

      if (this->is_bay_parser_)
        this->is_bay_parser_->pre ();

      return true;
    }

    if (n == "has_shelter" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->has_shelter_parser_;

      if (this->has_shelter_parser_)
        this->has_shelter_parser_->pre ();

      return true;
    }

    if (n == "busCapacityAsLength" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->busCapacityAsLength_parser_;

      if (this->busCapacityAsLength_parser_)
        this->busCapacityAsLength_parser_->pre ();

      return true;
    }

    if (n == "busstopno" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->busstopno_parser_;

      if (this->busstopno_parser_)
        this->busstopno_parser_->pre ();

      return true;
    }

    return false;
  }

  bool BusStop_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::sim_mob::xml::RoadItem_t_pskel::_end_element_impl (ns, n))
      return true;

    if (n == "xPos" && ns.empty ())
    {
      if (this->xPos_parser_)
        this->xPos (this->xPos_parser_->post_double ());

      return true;
    }

    if (n == "yPos" && ns.empty ())
    {
      if (this->yPos_parser_)
        this->yPos (this->yPos_parser_->post_double ());

      return true;
    }

    if (n == "lane_location" && ns.empty ())
    {
      if (this->lane_location_parser_)
        this->lane_location (this->lane_location_parser_->post_unsigned_long ());

      return true;
    }

    if (n == "is_terminal" && ns.empty ())
    {
      if (this->is_terminal_parser_)
        this->is_terminal (this->is_terminal_parser_->post_boolean ());

      return true;
    }

    if (n == "is_bay" && ns.empty ())
    {
      if (this->is_bay_parser_)
        this->is_bay (this->is_bay_parser_->post_boolean ());

      return true;
    }

    if (n == "has_shelter" && ns.empty ())
    {
      if (this->has_shelter_parser_)
        this->has_shelter (this->has_shelter_parser_->post_boolean ());

      return true;
    }

    if (n == "busCapacityAsLength" && ns.empty ())
    {
      if (this->busCapacityAsLength_parser_)
        this->busCapacityAsLength (this->busCapacityAsLength_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "busstopno" && ns.empty ())
    {
      if (this->busstopno_parser_)
        this->busstopno (this->busstopno_parser_->post_string ());

      return true;
    }

    return false;
  }

  // ERP_Gantry_t_pskel
  //

  void ERP_Gantry_t_pskel::
  ERP_GantryID (const ::std::string&)
  {
  }

  void ERP_Gantry_t_pskel::
  post_ERP_Gantry_t ()
  {
  }

  bool ERP_Gantry_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::sim_mob::xml::RoadItem_t_pskel::_start_element_impl (ns, n, t))
      return true;

    if (n == "ERP_GantryID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->ERP_GantryID_parser_;

      if (this->ERP_GantryID_parser_)
        this->ERP_GantryID_parser_->pre ();

      return true;
    }

    return false;
  }

  bool ERP_Gantry_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::sim_mob::xml::RoadItem_t_pskel::_end_element_impl (ns, n))
      return true;

    if (n == "ERP_GantryID" && ns.empty ())
    {
      if (this->ERP_GantryID_parser_)
        this->ERP_GantryID (this->ERP_GantryID_parser_->post_string ());

      return true;
    }

    return false;
  }

  // FormType_pskel
  //

  void FormType_pskel::
  TextBox (int)
  {
  }

  void FormType_pskel::
  TextArea (int)
  {
  }

  void FormType_pskel::
  Header (int)
  {
  }

  void FormType_pskel::
  post_FormType ()
  {
  }

  bool FormType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "TextBox" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->TextBox_parser_;

      if (this->TextBox_parser_)
        this->TextBox_parser_->pre ();

      return true;
    }

    if (n == "TextArea" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->TextArea_parser_;

      if (this->TextArea_parser_)
        this->TextArea_parser_->pre ();

      return true;
    }

    if (n == "Header" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Header_parser_;

      if (this->Header_parser_)
        this->Header_parser_->pre ();

      return true;
    }

    return false;
  }

  bool FormType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "TextBox" && ns.empty ())
    {
      if (this->TextBox_parser_)
        this->TextBox (this->TextBox_parser_->post_int ());

      return true;
    }

    if (n == "TextArea" && ns.empty ())
    {
      if (this->TextArea_parser_)
        this->TextArea (this->TextArea_parser_->post_int ());

      return true;
    }

    if (n == "Header" && ns.empty ())
    {
      if (this->Header_parser_)
        this->Header (this->Header_parser_->post_int ());

      return true;
    }

    return false;
  }

  // PointPair_t_pskel
  //

  void PointPair_t_pskel::
  first (sim_mob::Point2D)
  {
  }

  void PointPair_t_pskel::
  second (sim_mob::Point2D)
  {
  }

  bool PointPair_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "first" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->first_parser_;

      if (this->first_parser_)
        this->first_parser_->pre ();

      return true;
    }

    if (n == "second" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->second_parser_;

      if (this->second_parser_)
        this->second_parser_->pre ();

      return true;
    }

    return false;
  }

  bool PointPair_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "first" && ns.empty ())
    {
      if (this->first_parser_)
        this->first (this->first_parser_->post_Point2D_t ());

      return true;
    }

    if (n == "second" && ns.empty ())
    {
      if (this->second_parser_)
        this->second (this->second_parser_->post_Point2D_t ());

      return true;
    }

    return false;
  }

  // crossing_t_pskel
  //

  void crossing_t_pskel::
  nearLine (std::pair<sim_mob::Point2D,sim_mob::Point2D>)
  {
  }

  void crossing_t_pskel::
  farLine (std::pair<sim_mob::Point2D,sim_mob::Point2D>)
  {
  }

  bool crossing_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::sim_mob::xml::RoadItem_t_pskel::_start_element_impl (ns, n, t))
      return true;

    if (n == "nearLine" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->nearLine_parser_;

      if (this->nearLine_parser_)
        this->nearLine_parser_->pre ();

      return true;
    }

    if (n == "farLine" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->farLine_parser_;

      if (this->farLine_parser_)
        this->farLine_parser_->pre ();

      return true;
    }

    return false;
  }

  bool crossing_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::sim_mob::xml::RoadItem_t_pskel::_end_element_impl (ns, n))
      return true;

    if (n == "nearLine" && ns.empty ())
    {
      if (this->nearLine_parser_)
        this->nearLine (this->nearLine_parser_->post_PointPair_t ());

      return true;
    }

    if (n == "farLine" && ns.empty ())
    {
      if (this->farLine_parser_)
        this->farLine (this->farLine_parser_->post_PointPair_t ());

      return true;
    }

    return false;
  }

  // RoadBump_t_pskel
  //

  void RoadBump_t_pskel::
  roadBumpID (const ::std::string&)
  {
  }

  void RoadBump_t_pskel::
  segmentID (unsigned long long)
  {
  }

  void RoadBump_t_pskel::
  post_RoadBump_t ()
  {
  }

  bool RoadBump_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::sim_mob::xml::RoadItem_t_pskel::_start_element_impl (ns, n, t))
      return true;

    if (n == "roadBumpID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->roadBumpID_parser_;

      if (this->roadBumpID_parser_)
        this->roadBumpID_parser_->pre ();

      return true;
    }

    if (n == "segmentID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->segmentID_parser_;

      if (this->segmentID_parser_)
        this->segmentID_parser_->pre ();

      return true;
    }

    return false;
  }

  bool RoadBump_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::sim_mob::xml::RoadItem_t_pskel::_end_element_impl (ns, n))
      return true;

    if (n == "roadBumpID" && ns.empty ())
    {
      if (this->roadBumpID_parser_)
        this->roadBumpID (this->roadBumpID_parser_->post_string ());

      return true;
    }

    if (n == "segmentID" && ns.empty ())
    {
      if (this->segmentID_parser_)
        this->segmentID (this->segmentID_parser_->post_unsigned_long ());

      return true;
    }

    return false;
  }

  // RoadNetwork_t_pskel
  //

  void RoadNetwork_t_pskel::
  coordinate_map (const std::vector<sim_mob::CoordinateTransform*>&)
  {
  }

  void RoadNetwork_t_pskel::
  roadrunner_regions (const std::map<int, sim_mob::RoadRunnerRegion>&)
  {
  }

  void RoadNetwork_t_pskel::
  Nodes (const helper::NodesRes&)
  {
  }

  void RoadNetwork_t_pskel::
  Links (const std::vector<sim_mob::Link*>&)
  {
  }

  bool RoadNetwork_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "coordinate_map" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->coordinate_map_parser_;

      if (this->coordinate_map_parser_)
        this->coordinate_map_parser_->pre ();

      return true;
    }

    if (n == "roadrunner_regions" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->roadrunner_regions_parser_;

      if (this->roadrunner_regions_parser_)
        this->roadrunner_regions_parser_->pre ();

      return true;
    }

    if (n == "Nodes" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Nodes_parser_;

      if (this->Nodes_parser_)
        this->Nodes_parser_->pre ();

      return true;
    }

    if (n == "Links" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Links_parser_;

      if (this->Links_parser_)
        this->Links_parser_->pre ();

      return true;
    }

    return false;
  }

  bool RoadNetwork_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "coordinate_map" && ns.empty ())
    {
      if (this->coordinate_map_parser_)
        this->coordinate_map (this->coordinate_map_parser_->post_coordinate_map_t ());

      return true;
    }

    if (n == "roadrunner_regions" && ns.empty ())
    {
      if (this->roadrunner_regions_parser_)
        this->roadrunner_regions (this->roadrunner_regions_parser_->post_roadrunner_regions_t ());

      return true;
    }

    if (n == "Nodes" && ns.empty ())
    {
      if (this->Nodes_parser_)
        this->Nodes (this->Nodes_parser_->post_Nodes ());

      return true;
    }

    if (n == "Links" && ns.empty ())
    {
      if (this->Links_parser_)
        this->Links (this->Links_parser_->post_Links ());

      return true;
    }

    return false;
  }

  // RoadItems_t_pskel
  //

  void RoadItems_t_pskel::
  BusStop (std::pair<unsigned long,sim_mob::BusStop*>)
  {
  }

  void RoadItems_t_pskel::
  ERP_Gantry ()
  {
  }

  void RoadItems_t_pskel::
  Crossing (std::pair<unsigned long,sim_mob::Crossing*>)
  {
  }

  void RoadItems_t_pskel::
  RoadBump ()
  {
  }

  bool RoadItems_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "BusStop" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->BusStop_parser_;

      if (this->BusStop_parser_)
        this->BusStop_parser_->pre ();

      return true;
    }

    if (n == "ERP_Gantry" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->ERP_Gantry_parser_;

      if (this->ERP_Gantry_parser_)
        this->ERP_Gantry_parser_->pre ();

      return true;
    }

    if (n == "Crossing" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Crossing_parser_;

      if (this->Crossing_parser_)
        this->Crossing_parser_->pre ();

      return true;
    }

    if (n == "RoadBump" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->RoadBump_parser_;

      if (this->RoadBump_parser_)
        this->RoadBump_parser_->pre ();

      return true;
    }

    return false;
  }

  bool RoadItems_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "BusStop" && ns.empty ())
    {
      if (this->BusStop_parser_)
        this->BusStop (this->BusStop_parser_->post_BusStop_t ());

      return true;
    }

    if (n == "ERP_Gantry" && ns.empty ())
    {
      if (this->ERP_Gantry_parser_)
      {
        this->ERP_Gantry_parser_->post_ERP_Gantry_t ();
        this->ERP_Gantry ();
      }

      return true;
    }

    if (n == "Crossing" && ns.empty ())
    {
      if (this->Crossing_parser_)
        this->Crossing (this->Crossing_parser_->post_crossing_t ());

      return true;
    }

    if (n == "RoadBump" && ns.empty ())
    {
      if (this->RoadBump_parser_)
      {
        this->RoadBump_parser_->post_RoadBump_t ();
        this->RoadBump ();
      }

      return true;
    }

    return false;
  }

  // TripChainItem_t_pskel
  //

  void TripChainItem_t_pskel::
  personID (const ::std::string&)
  {
  }

  void TripChainItem_t_pskel::
  itemType (std::string)
  {
  }

  void TripChainItem_t_pskel::
  sequenceNumber (unsigned int)
  {
  }

  void TripChainItem_t_pskel::
  requestTime (long long)
  {
  }

  void TripChainItem_t_pskel::
  startTime (const ::std::string&)
  {
  }

  void TripChainItem_t_pskel::
  endTime (const ::std::string&)
  {
  }

  bool TripChainItem_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "personID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->personID_parser_;

      if (this->personID_parser_)
        this->personID_parser_->pre ();

      return true;
    }

    if (n == "itemType" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->itemType_parser_;

      if (this->itemType_parser_)
        this->itemType_parser_->pre ();

      return true;
    }

    if (n == "sequenceNumber" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->sequenceNumber_parser_;

      if (this->sequenceNumber_parser_)
        this->sequenceNumber_parser_->pre ();

      return true;
    }

    if (n == "requestTime" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->requestTime_parser_;

      if (this->requestTime_parser_)
        this->requestTime_parser_->pre ();

      return true;
    }

    if (n == "startTime" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->startTime_parser_;

      if (this->startTime_parser_)
        this->startTime_parser_->pre ();

      return true;
    }

    if (n == "endTime" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->endTime_parser_;

      if (this->endTime_parser_)
        this->endTime_parser_->pre ();

      return true;
    }

    return false;
  }

  bool TripChainItem_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "personID" && ns.empty ())
    {
      if (this->personID_parser_)
        this->personID (this->personID_parser_->post_string ());

      return true;
    }

    if (n == "itemType" && ns.empty ())
    {
      if (this->itemType_parser_)
        this->itemType (this->itemType_parser_->post_TripchainItemType ());

      return true;
    }

    if (n == "sequenceNumber" && ns.empty ())
    {
      if (this->sequenceNumber_parser_)
        this->sequenceNumber (this->sequenceNumber_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "requestTime" && ns.empty ())
    {
      if (this->requestTime_parser_)
        this->requestTime (this->requestTime_parser_->post_integer ());

      return true;
    }

    if (n == "startTime" && ns.empty ())
    {
      if (this->startTime_parser_)
        this->startTime (this->startTime_parser_->post_string ());

      return true;
    }

    if (n == "endTime" && ns.empty ())
    {
      if (this->endTime_parser_)
        this->endTime (this->endTime_parser_->post_string ());

      return true;
    }

    return false;
  }

  // Trip_t_pskel
  //

  void Trip_t_pskel::
  tripID (long long)
  {
  }

  void Trip_t_pskel::
  fromLocation (unsigned int)
  {
  }

  void Trip_t_pskel::
  fromLocationType (std::string)
  {
  }

  void Trip_t_pskel::
  toLocation (unsigned int)
  {
  }

  void Trip_t_pskel::
  toLocationType (std::string)
  {
  }

  void Trip_t_pskel::
  subTrips (std::vector<sim_mob::SubTrip>)
  {
  }

  sim_mob::TripChainItem* Trip_t_pskel::
  post_Trip_t ()
  {
    return post_TripChainItem_t ();
  }

  bool Trip_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::sim_mob::xml::TripChainItem_t_pskel::_start_element_impl (ns, n, t))
      return true;

    if (n == "tripID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->tripID_parser_;

      if (this->tripID_parser_)
        this->tripID_parser_->pre ();

      return true;
    }

    if (n == "fromLocation" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->fromLocation_parser_;

      if (this->fromLocation_parser_)
        this->fromLocation_parser_->pre ();

      return true;
    }

    if (n == "fromLocationType" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->fromLocationType_parser_;

      if (this->fromLocationType_parser_)
        this->fromLocationType_parser_->pre ();

      return true;
    }

    if (n == "toLocation" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->toLocation_parser_;

      if (this->toLocation_parser_)
        this->toLocation_parser_->pre ();

      return true;
    }

    if (n == "toLocationType" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->toLocationType_parser_;

      if (this->toLocationType_parser_)
        this->toLocationType_parser_->pre ();

      return true;
    }

    if (n == "subTrips" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->subTrips_parser_;

      if (this->subTrips_parser_)
        this->subTrips_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Trip_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::sim_mob::xml::TripChainItem_t_pskel::_end_element_impl (ns, n))
      return true;

    if (n == "tripID" && ns.empty ())
    {
      if (this->tripID_parser_)
        this->tripID (this->tripID_parser_->post_integer ());

      return true;
    }

    if (n == "fromLocation" && ns.empty ())
    {
      if (this->fromLocation_parser_)
        this->fromLocation (this->fromLocation_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "fromLocationType" && ns.empty ())
    {
      if (this->fromLocationType_parser_)
        this->fromLocationType (this->fromLocationType_parser_->post_TripchainItemLocationType ());

      return true;
    }

    if (n == "toLocation" && ns.empty ())
    {
      if (this->toLocation_parser_)
        this->toLocation (this->toLocation_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "toLocationType" && ns.empty ())
    {
      if (this->toLocationType_parser_)
        this->toLocationType (this->toLocationType_parser_->post_TripchainItemLocationType ());

      return true;
    }

    if (n == "subTrips" && ns.empty ())
    {
      if (this->subTrips_parser_)
        this->subTrips (this->subTrips_parser_->post_SubTrips_t ());

      return true;
    }

    return false;
  }

  // SubTrip_t_pskel
  //

  void SubTrip_t_pskel::
  mode (const ::std::string&)
  {
  }

  void SubTrip_t_pskel::
  isPrimaryMode (bool)
  {
  }

  void SubTrip_t_pskel::
  ptLineId (const ::std::string&)
  {
  }

  bool SubTrip_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::sim_mob::xml::Trip_t_pskel::_start_element_impl (ns, n, t))
      return true;

    if (n == "mode" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->mode_parser_;

      if (this->mode_parser_)
        this->mode_parser_->pre ();

      return true;
    }

    if (n == "isPrimaryMode" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->isPrimaryMode_parser_;

      if (this->isPrimaryMode_parser_)
        this->isPrimaryMode_parser_->pre ();

      return true;
    }

    if (n == "ptLineId" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->ptLineId_parser_;

      if (this->ptLineId_parser_)
        this->ptLineId_parser_->pre ();

      return true;
    }

    return false;
  }

  bool SubTrip_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::sim_mob::xml::Trip_t_pskel::_end_element_impl (ns, n))
      return true;

    if (n == "mode" && ns.empty ())
    {
      if (this->mode_parser_)
        this->mode (this->mode_parser_->post_string ());

      return true;
    }

    if (n == "isPrimaryMode" && ns.empty ())
    {
      if (this->isPrimaryMode_parser_)
        this->isPrimaryMode (this->isPrimaryMode_parser_->post_boolean ());

      return true;
    }

    if (n == "ptLineId" && ns.empty ())
    {
      if (this->ptLineId_parser_)
        this->ptLineId (this->ptLineId_parser_->post_string ());

      return true;
    }

    return false;
  }

  // SubTrips_t_pskel
  //

  void SubTrips_t_pskel::
  subTrip (sim_mob::SubTrip)
  {
  }

  bool SubTrips_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "subTrip" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->subTrip_parser_;

      if (this->subTrip_parser_)
        this->subTrip_parser_->pre ();

      return true;
    }

    return false;
  }

  bool SubTrips_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "subTrip" && ns.empty ())
    {
      if (this->subTrip_parser_)
        this->subTrip (this->subTrip_parser_->post_SubTrip_t ());

      return true;
    }

    return false;
  }

  // Activity_t_pskel
  //

  void Activity_t_pskel::
  description (const ::std::string&)
  {
  }

  void Activity_t_pskel::
  location (unsigned int)
  {
  }

  void Activity_t_pskel::
  locationType (std::string)
  {
  }

  void Activity_t_pskel::
  isPrimary (bool)
  {
  }

  void Activity_t_pskel::
  isFlexible (bool)
  {
  }

  void Activity_t_pskel::
  isMandatory (bool)
  {
  }

  sim_mob::TripChainItem* Activity_t_pskel::
  post_Activity_t ()
  {
    return post_TripChainItem_t ();
  }

  bool Activity_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::sim_mob::xml::TripChainItem_t_pskel::_start_element_impl (ns, n, t))
      return true;

    if (n == "description" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->description_parser_;

      if (this->description_parser_)
        this->description_parser_->pre ();

      return true;
    }

    if (n == "location" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->location_parser_;

      if (this->location_parser_)
        this->location_parser_->pre ();

      return true;
    }

    if (n == "locationType" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->locationType_parser_;

      if (this->locationType_parser_)
        this->locationType_parser_->pre ();

      return true;
    }

    if (n == "isPrimary" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->isPrimary_parser_;

      if (this->isPrimary_parser_)
        this->isPrimary_parser_->pre ();

      return true;
    }

    if (n == "isFlexible" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->isFlexible_parser_;

      if (this->isFlexible_parser_)
        this->isFlexible_parser_->pre ();

      return true;
    }

    if (n == "isMandatory" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->isMandatory_parser_;

      if (this->isMandatory_parser_)
        this->isMandatory_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Activity_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::sim_mob::xml::TripChainItem_t_pskel::_end_element_impl (ns, n))
      return true;

    if (n == "description" && ns.empty ())
    {
      if (this->description_parser_)
        this->description (this->description_parser_->post_string ());

      return true;
    }

    if (n == "location" && ns.empty ())
    {
      if (this->location_parser_)
        this->location (this->location_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "locationType" && ns.empty ())
    {
      if (this->locationType_parser_)
        this->locationType (this->locationType_parser_->post_TripchainItemLocationType ());

      return true;
    }

    if (n == "isPrimary" && ns.empty ())
    {
      if (this->isPrimary_parser_)
        this->isPrimary (this->isPrimary_parser_->post_boolean ());

      return true;
    }

    if (n == "isFlexible" && ns.empty ())
    {
      if (this->isFlexible_parser_)
        this->isFlexible (this->isFlexible_parser_->post_boolean ());

      return true;
    }

    if (n == "isMandatory" && ns.empty ())
    {
      if (this->isMandatory_parser_)
        this->isMandatory (this->isMandatory_parser_->post_boolean ());

      return true;
    }

    return false;
  }

  // TripChain_t_pskel
  //

  void TripChain_t_pskel::
  personID (const ::std::string&)
  {
  }

  void TripChain_t_pskel::
  Trip (sim_mob::TripChainItem*)
  {
  }

  void TripChain_t_pskel::
  Activity (sim_mob::TripChainItem*)
  {
  }

  bool TripChain_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "personID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->personID_parser_;

      if (this->personID_parser_)
        this->personID_parser_->pre ();

      return true;
    }

    if (n == "Trip" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Trip_parser_;

      if (this->Trip_parser_)
        this->Trip_parser_->pre ();

      return true;
    }

    if (n == "Activity" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Activity_parser_;

      if (this->Activity_parser_)
        this->Activity_parser_->pre ();

      return true;
    }

    return false;
  }

  bool TripChain_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "personID" && ns.empty ())
    {
      if (this->personID_parser_)
        this->personID (this->personID_parser_->post_string ());

      return true;
    }

    if (n == "Trip" && ns.empty ())
    {
      if (this->Trip_parser_)
        this->Trip (this->Trip_parser_->post_Trip_t ());

      return true;
    }

    if (n == "Activity" && ns.empty ())
    {
      if (this->Activity_parser_)
        this->Activity (this->Activity_parser_->post_Activity_t ());

      return true;
    }

    return false;
  }

  // TripChains_t_pskel
  //

  void TripChains_t_pskel::
  TripChain (std::pair<std::string, std::vector<sim_mob::TripChainItem*> >)
  {
  }

  void TripChains_t_pskel::
  post_TripChains_t ()
  {
  }

  bool TripChains_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "TripChain" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->TripChain_parser_;

      if (this->TripChain_parser_)
        this->TripChain_parser_->pre ();

      return true;
    }

    return false;
  }

  bool TripChains_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "TripChain" && ns.empty ())
    {
      if (this->TripChain_parser_)
        this->TripChain (this->TripChain_parser_->post_TripChain_t ());

      return true;
    }

    return false;
  }

  // linkAndCrossing_t_pskel
  //

  void linkAndCrossing_t_pskel::
  ID (unsigned char)
  {
  }

  void linkAndCrossing_t_pskel::
  linkID (unsigned int)
  {
  }

  void linkAndCrossing_t_pskel::
  crossingID (unsigned int)
  {
  }

  void linkAndCrossing_t_pskel::
  angle (unsigned char)
  {
  }

  bool linkAndCrossing_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "ID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->ID_parser_;

      if (this->ID_parser_)
        this->ID_parser_->pre ();

      return true;
    }

    if (n == "linkID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->linkID_parser_;

      if (this->linkID_parser_)
        this->linkID_parser_->pre ();

      return true;
    }

    if (n == "crossingID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->crossingID_parser_;

      if (this->crossingID_parser_)
        this->crossingID_parser_->pre ();

      return true;
    }

    if (n == "angle" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->angle_parser_;

      if (this->angle_parser_)
        this->angle_parser_->pre ();

      return true;
    }

    return false;
  }

  bool linkAndCrossing_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "ID" && ns.empty ())
    {
      if (this->ID_parser_)
        this->ID (this->ID_parser_->post_unsigned_byte ());

      return true;
    }

    if (n == "linkID" && ns.empty ())
    {
      if (this->linkID_parser_)
        this->linkID (this->linkID_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "crossingID" && ns.empty ())
    {
      if (this->crossingID_parser_)
        this->crossingID (this->crossingID_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "angle" && ns.empty ())
    {
      if (this->angle_parser_)
        this->angle (this->angle_parser_->post_unsigned_byte ());

      return true;
    }

    return false;
  }

  // linkAndCrossings_t_pskel
  //

  void linkAndCrossings_t_pskel::
    linkAndCrossing (sim_mob::LinkAndCrossing&)
  {
  }

  bool linkAndCrossings_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "linkAndCrossing" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->linkAndCrossing_parser_;

      if (this->linkAndCrossing_parser_)
        this->linkAndCrossing_parser_->pre ();

      return true;
    }

    return false;
  }

  bool linkAndCrossings_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "linkAndCrossing" && ns.empty ())
    {
      if (this->linkAndCrossing_parser_)
        this->linkAndCrossing (this->linkAndCrossing_parser_->post_linkAndCrossing_t ());

      return true;
    }

    return false;
  }

  // plan_t_pskel
  //

  void plan_t_pskel::
  planID (unsigned char)
  {
  }

  void plan_t_pskel::
  PhasePercentage (double)
  {
  }

  bool plan_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "planID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->planID_parser_;

      if (this->planID_parser_)
        this->planID_parser_->pre ();

      return true;
    }

    if (n == "PhasePercentage" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->PhasePercentage_parser_;

      if (this->PhasePercentage_parser_)
        this->PhasePercentage_parser_->pre ();

      return true;
    }

    return false;
  }

  bool plan_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "planID" && ns.empty ())
    {
      if (this->planID_parser_)
        this->planID (this->planID_parser_->post_unsigned_byte ());

      return true;
    }

    if (n == "PhasePercentage" && ns.empty ())
    {
      if (this->PhasePercentage_parser_)
        this->PhasePercentage (this->PhasePercentage_parser_->post_double ());

      return true;
    }

    return false;
  }

  // Plans_t_pskel
  //

  void Plans_t_pskel::
    plan (std::pair<short,std::vector<double> >&)
  {
  }

  bool Plans_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "plan" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->plan_parser_;

      if (this->plan_parser_)
        this->plan_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Plans_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "plan" && ns.empty ())
    {
      if (this->plan_parser_)
          this->plan (this->plan_parser_->post_plan_t ());

      return true;
    }

    return false;
  }

  // ColorDuration_t_pskel
  //

  void ColorDuration_t_pskel::
  TrafficColor (sim_mob::TrafficColor)
  {
  }

  void ColorDuration_t_pskel::
    Duration (int)
  {
  }

  bool ColorDuration_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "TrafficColor" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->TrafficColor_parser_;

      if (this->TrafficColor_parser_)
        this->TrafficColor_parser_->pre ();

      return true;
    }

    if (n == "Duration" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Duration_parser_;

      if (this->Duration_parser_)
        this->Duration_parser_->pre ();

      return true;
    }

    return false;
  }

  bool ColorDuration_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "TrafficColor" && ns.empty ())
    {
      if (this->TrafficColor_parser_)
        this->TrafficColor (this->TrafficColor_parser_->post_TrafficColor_t ());

      return true;
    }

    if (n == "Duration" && ns.empty ())
    {
      if (this->Duration_parser_)
        this->Duration (this->Duration_parser_->post_unsigned_byte ());

      return true;
    }

    return false;
  }

  // ColorSequence_t_pskel
  //

  void ColorSequence_t_pskel::
  TrafficLightType (const ::std::string&)
  {
  }

  void ColorSequence_t_pskel::
    ColorDuration (std::pair<sim_mob::TrafficColor,int>&)
  {
  }

  bool ColorSequence_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "TrafficLightType" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->TrafficLightType_parser_;

      if (this->TrafficLightType_parser_)
        this->TrafficLightType_parser_->pre ();

      return true;
    }

    if (n == "ColorDuration" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->ColorDuration_parser_;

      if (this->ColorDuration_parser_)
        this->ColorDuration_parser_->pre ();

      return true;
    }

    return false;
  }

  bool ColorSequence_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "TrafficLightType" && ns.empty ())
    {
      if (this->TrafficLightType_parser_)
        this->TrafficLightType (this->TrafficLightType_parser_->post_string ());

      return true;
    }

    if (n == "ColorDuration" && ns.empty ())
    {
      if (this->ColorDuration_parser_)
        this->ColorDuration (this->ColorDuration_parser_->post_ColorDuration_t ());

      return true;
    }

    return false;
  }

  // links_maps_t_pskel
  //

  void links_maps_t_pskel::
    links_map (std::pair<sim_mob::Link*,sim_mob::linkToLink>&)
  {
  }

  bool links_maps_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "links_map" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->links_map_parser_;

      if (this->links_map_parser_)
        this->links_map_parser_->pre ();

      return true;
    }

    return false;
  }

  bool links_maps_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "links_map" && ns.empty ())
    {
      if (this->links_map_parser_)
        this->links_map (this->links_map_parser_->post_links_map_t ());

      return true;
    }

    return false;
  }

  // links_map_t_pskel
  //

  void links_map_t_pskel::
  LinkFrom (unsigned int)
  {
  }

  void links_map_t_pskel::
  LinkTo (unsigned int)
  {
  }

  void links_map_t_pskel::
  SegmentFrom (unsigned int)
  {
  }

  void links_map_t_pskel::
  SegmentTo (unsigned int)
  {
  }

  void links_map_t_pskel::
  ColorSequence (std::pair<sim_mob::TrafficLightType, std::vector<std::pair<TrafficColor,int> > >&)
  {
  }

  bool links_map_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "LinkFrom" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->LinkFrom_parser_;

      if (this->LinkFrom_parser_)
        this->LinkFrom_parser_->pre ();

      return true;
    }

    if (n == "LinkTo" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->LinkTo_parser_;

      if (this->LinkTo_parser_)
        this->LinkTo_parser_->pre ();

      return true;
    }

    if (n == "SegmentFrom" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->SegmentFrom_parser_;

      if (this->SegmentFrom_parser_)
        this->SegmentFrom_parser_->pre ();

      return true;
    }

    if (n == "SegmentTo" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->SegmentTo_parser_;

      if (this->SegmentTo_parser_)
        this->SegmentTo_parser_->pre ();

      return true;
    }

    if (n == "ColorSequence" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->ColorSequence_parser_;

      if (this->ColorSequence_parser_)
        this->ColorSequence_parser_->pre ();

      return true;
    }

    return false;
  }

  bool links_map_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "LinkFrom" && ns.empty ())
    {
      if (this->LinkFrom_parser_)
        this->LinkFrom (this->LinkFrom_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "LinkTo" && ns.empty ())
    {
      if (this->LinkTo_parser_)
        this->LinkTo (this->LinkTo_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "SegmentFrom" && ns.empty ())
    {
      if (this->SegmentFrom_parser_)
        this->SegmentFrom (this->SegmentFrom_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "SegmentTo" && ns.empty ())
    {
      if (this->SegmentTo_parser_)
        this->SegmentTo (this->SegmentTo_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "ColorSequence" && ns.empty ())
    {
      if (this->ColorSequence_parser_)
        this->ColorSequence (this->ColorSequence_parser_->post_ColorSequence_t ());

      return true;
    }

    return false;
  }

  // crossings_maps_t_pskel
  //

  void crossings_maps_t_pskel::
  crossings_map (std::pair<sim_mob::Crossing *, sim_mob::Crossings>)
  {
  }

  bool crossings_maps_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "crossings_map" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->crossings_map_parser_;

      if (this->crossings_map_parser_)
        this->crossings_map_parser_->pre ();

      return true;
    }

    return false;
  }

  bool crossings_maps_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "crossings_map" && ns.empty ())
    {
      if (this->crossings_map_parser_)
        this->crossings_map (this->crossings_map_parser_->post_crossings_map_t ());

      return true;
    }

    return false;
  }

  // crossings_map_t_pskel
  //

  void crossings_map_t_pskel::
  linkID (unsigned int)
  {
  }

  void crossings_map_t_pskel::
  crossingID (unsigned int)
  {
  }

  void crossings_map_t_pskel::
    ColorSequence (std::pair<sim_mob::TrafficLightType, std::vector<std::pair<TrafficColor,int> > >&)
  {
  }

  bool crossings_map_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "linkID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->linkID_parser_;

      if (this->linkID_parser_)
        this->linkID_parser_->pre ();

      return true;
    }

    if (n == "crossingID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->crossingID_parser_;

      if (this->crossingID_parser_)
        this->crossingID_parser_->pre ();

      return true;
    }

    if (n == "ColorSequence" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->ColorSequence_parser_;

      if (this->ColorSequence_parser_)
        this->ColorSequence_parser_->pre ();

      return true;
    }

    return false;
  }

  bool crossings_map_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "linkID" && ns.empty ())
    {
      if (this->linkID_parser_)
        this->linkID (this->linkID_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "crossingID" && ns.empty ())
    {
      if (this->crossingID_parser_)
        this->crossingID (this->crossingID_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "ColorSequence" && ns.empty ())
    {
      if (this->ColorSequence_parser_)
        this->ColorSequence (this->ColorSequence_parser_->post_ColorSequence_t ());

      return true;
    }

    return false;
  }

  // Phase_t_pskel
  //

  void Phase_t_pskel::
  phaseID (unsigned char)
  {
  }

  void Phase_t_pskel::
  name (const ::std::string&)
  {
  }

  void Phase_t_pskel::
    links_maps (std::multimap<sim_mob::Link*,sim_mob::linkToLink>&)
  {
  }

  void Phase_t_pskel::
    crossings_maps (std::map<sim_mob::Crossing *, sim_mob::Crossings>&)
  {
  }

  bool Phase_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "phaseID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->phaseID_parser_;

      if (this->phaseID_parser_)
        this->phaseID_parser_->pre ();

      return true;
    }

    if (n == "name" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->name_parser_;

      if (this->name_parser_)
        this->name_parser_->pre ();

      return true;
    }

    if (n == "links_maps" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->links_maps_parser_;

      if (this->links_maps_parser_)
        this->links_maps_parser_->pre ();

      return true;
    }

    if (n == "crossings_maps" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->crossings_maps_parser_;

      if (this->crossings_maps_parser_)
        this->crossings_maps_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Phase_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "phaseID" && ns.empty ())
    {
      if (this->phaseID_parser_)
        this->phaseID (this->phaseID_parser_->post_unsigned_byte ());

      return true;
    }

    if (n == "name" && ns.empty ())
    {
      if (this->name_parser_)
        this->name (this->name_parser_->post_string ());

      return true;
    }

    if (n == "links_maps" && ns.empty ())
    {
      if (this->links_maps_parser_)
        this->links_maps (this->links_maps_parser_->post_links_maps_t ());

      return true;
    }

    if (n == "crossings_maps" && ns.empty ())
    {
      if (this->crossings_maps_parser_)
        this->crossings_maps (this->crossings_maps_parser_->post_crossings_maps_t ());

      return true;
    }

    return false;
  }

  // Phases_t_pskel
  //

  void Phases_t_pskel::
    phase (sim_mob::Phase&)
  {
  }

  bool Phases_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "phase" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->phase_parser_;

      if (this->phase_parser_)
        this->phase_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Phases_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "phase" && ns.empty ())
    {
      if (this->phase_parser_)
        this->phase (this->phase_parser_->post_Phase_t ());

      return true;
    }

    return false;
  }

  // SplitPlan_t_pskel
  //

  void SplitPlan_t_pskel::
  splitplanID (unsigned int)
  {
  }

  void SplitPlan_t_pskel::
  cycleLength (unsigned char)
  {
  }

  void SplitPlan_t_pskel::
  offset (unsigned char)
  {
  }

  void SplitPlan_t_pskel::
    ChoiceSet (std::vector<std::vector<double> >&)
  {
  }

  bool SplitPlan_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "splitplanID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->splitplanID_parser_;

      if (this->splitplanID_parser_)
        this->splitplanID_parser_->pre ();

      return true;
    }

    if (n == "cycleLength" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->cycleLength_parser_;

      if (this->cycleLength_parser_)
        this->cycleLength_parser_->pre ();

      return true;
    }

    if (n == "offset" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->offset_parser_;

      if (this->offset_parser_)
        this->offset_parser_->pre ();

      return true;
    }

    if (n == "ChoiceSet" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->ChoiceSet_parser_;

      if (this->ChoiceSet_parser_)
        this->ChoiceSet_parser_->pre ();

      return true;
    }

    return false;
  }

  bool SplitPlan_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "splitplanID" && ns.empty ())
    {
      if (this->splitplanID_parser_)
        this->splitplanID (this->splitplanID_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "cycleLength" && ns.empty ())
    {
      if (this->cycleLength_parser_)
        this->cycleLength (this->cycleLength_parser_->post_unsigned_byte ());

      return true;
    }

    if (n == "offset" && ns.empty ())
    {
      if (this->offset_parser_)
        this->offset (this->offset_parser_->post_unsigned_byte ());

      return true;
    }

    if (n == "ChoiceSet" && ns.empty ())
    {
      if (this->ChoiceSet_parser_)
        this->ChoiceSet (this->ChoiceSet_parser_->post_Plans_t ());

      return true;
    }

    return false;
  }

  // SCATS_t_pskel
  //

  void SCATS_t_pskel::
  signalTimingMode (int)
  {
  }

  void SCATS_t_pskel::
    SplitPlan (sim_mob::SplitPlan&)
  {
  }

  bool SCATS_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "signalTimingMode" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->signalTimingMode_parser_;

      if (this->signalTimingMode_parser_)
        this->signalTimingMode_parser_->pre ();

      return true;
    }

    if (n == "SplitPlan" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->SplitPlan_parser_;

      if (this->SplitPlan_parser_)
        this->SplitPlan_parser_->pre ();

      return true;
    }

    return false;
  }

  bool SCATS_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "signalTimingMode" && ns.empty ())
    {
      if (this->signalTimingMode_parser_)
        this->signalTimingMode (this->signalTimingMode_parser_->post_signalTimingMode_t ());

      return true;
    }

    if (n == "SplitPlan" && ns.empty ())
    {
      if (this->SplitPlan_parser_)
        this->SplitPlan (this->SplitPlan_parser_->post_SplitPlan_t ());

      return true;
    }

    return false;
  }

  // Signal_t_pskel
  //

  void Signal_t_pskel::
  signalID (unsigned int)
  {
  }

  void Signal_t_pskel::
  nodeID (unsigned int)
  {
  }

  void Signal_t_pskel::
    linkAndCrossings (sim_mob::LinkAndCrossingC&)
  {
  }

  void Signal_t_pskel::
    phases (sim_mob::Signal::phases&)
  {
  }

  void Signal_t_pskel::
    SCATS (sim_mob::xml::helper::SignalHelper::SCATS_Info&)
  {
  }

  bool Signal_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "signalID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->signalID_parser_;

      if (this->signalID_parser_)
        this->signalID_parser_->pre ();

      return true;
    }

    if (n == "nodeID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->nodeID_parser_;

      if (this->nodeID_parser_)
        this->nodeID_parser_->pre ();

      return true;
    }

    if (n == "linkAndCrossings" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->linkAndCrossings_parser_;

      if (this->linkAndCrossings_parser_)
        this->linkAndCrossings_parser_->pre ();

      return true;
    }

    if (n == "phases" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->phases_parser_;

      if (this->phases_parser_)
        this->phases_parser_->pre ();

      return true;
    }

    if (n == "SCATS" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->SCATS_parser_;

      if (this->SCATS_parser_)
        this->SCATS_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Signal_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "signalID" && ns.empty ())
    {
      if (this->signalID_parser_)
        this->signalID (this->signalID_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "nodeID" && ns.empty ())
    {
      if (this->nodeID_parser_)
        this->nodeID (this->nodeID_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "linkAndCrossings" && ns.empty ())
    {
      if (this->linkAndCrossings_parser_)
        this->linkAndCrossings (this->linkAndCrossings_parser_->post_linkAndCrossings_t ());

      return true;
    }

    if (n == "phases" && ns.empty ())
    {
      if (this->phases_parser_)
          this->phases (this->phases_parser_->post_phases_t ());

      return true;
    }

    if (n == "SCATS" && ns.empty ())
    {
      if (this->SCATS_parser_)
        this->SCATS (this->SCATS_parser_->post_SCATS_t ());

      return true;
    }

    return false;
  }

  // Signals_t_pskel
  //

  void Signals_t_pskel::
  Signal (sim_mob::Signal*)
  {
  }

  bool Signals_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "Signal" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Signal_parser_;

      if (this->Signal_parser_)
        this->Signal_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Signals_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "Signal" && ns.empty ())
    {
      if (this->Signal_parser_)
        this->Signal (this->Signal_parser_->post_Signal_t ());

      return true;
    }

    return false;
  }

  // GeoSpatial_t_pskel
  //

  void GeoSpatial_t_pskel::
  RoadNetwork (sim_mob::RoadNetwork&)
  {
  }

  void GeoSpatial_t_pskel::
  post_GeoSpatial_t ()
  {
  }

  bool GeoSpatial_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "RoadNetwork" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->RoadNetwork_parser_;

      if (this->RoadNetwork_parser_)
        this->RoadNetwork_parser_->pre ();

      return true;
    }

    return false;
  }

  bool GeoSpatial_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "RoadNetwork" && ns.empty ())
    {
      if (this->RoadNetwork_parser_)
        this->RoadNetwork (this->RoadNetwork_parser_->post_RoadNetwork_t ());

      return true;
    }

    return false;
  }

  // SimMobility_t_pskel
  //

  void SimMobility_t_pskel::
  GeoSpatial ()
  {
  }

  void SimMobility_t_pskel::
  TripChains ()
  {
  }

  void SimMobility_t_pskel::
    Signals (std::vector<sim_mob::Signal*>&)
  {
  }

  void SimMobility_t_pskel::
  post_SimMobility_t ()
  {
  }

  bool SimMobility_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "GeoSpatial" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->GeoSpatial_parser_;

      if (this->GeoSpatial_parser_)
        this->GeoSpatial_parser_->pre ();

      return true;
    }

    if (n == "TripChains" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->TripChains_parser_;

      if (this->TripChains_parser_)
        this->TripChains_parser_->pre ();

      return true;
    }

    if (n == "Signals" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Signals_parser_;

      if (this->Signals_parser_)
        this->Signals_parser_->pre ();

      return true;
    }

    return false;
  }

  bool SimMobility_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "GeoSpatial" && ns.empty ())
    {
      if (this->GeoSpatial_parser_)
      {
        this->GeoSpatial_parser_->post_GeoSpatial_t ();
        this->GeoSpatial ();
      }

      return true;
    }

    if (n == "TripChains" && ns.empty ())
    {
      if (this->TripChains_parser_)
      {
        this->TripChains_parser_->post_TripChains_t ();
        this->TripChains ();
      }

      return true;
    }

    if (n == "Signals" && ns.empty ())
    {
      if (this->Signals_parser_)
        this->Signals (this->Signals_parser_->post_Signals_t ());

      return true;
    }

    return false;
  }

  // Lanes_pskel
  //

  void Lanes_pskel::
  Lane (sim_mob::Lane*)
  {
  }

  bool Lanes_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "Lane" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Lane_parser_;

      if (this->Lane_parser_)
        this->Lane_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Lanes_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "Lane" && ns.empty ())
    {
      if (this->Lane_parser_)
        this->Lane (this->Lane_parser_->post_lane_t ());

      return true;
    }

    return false;
  }

  // Nodes_pskel
  //

  void Nodes_pskel::
  UniNodes (const std::set<sim_mob::UniNode*>&)
  {
  }

  void Nodes_pskel::
  Intersections (const std::vector<sim_mob::MultiNode*>&)
  {
  }

  void Nodes_pskel::
  roundabouts (const std::vector<sim_mob::MultiNode*>&)
  {
  }

  bool Nodes_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "UniNodes" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->UniNodes_parser_;

      if (this->UniNodes_parser_)
        this->UniNodes_parser_->pre ();

      return true;
    }

    if (n == "Intersections" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Intersections_parser_;

      if (this->Intersections_parser_)
        this->Intersections_parser_->pre ();

      return true;
    }

    if (n == "roundabouts" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->roundabouts_parser_;

      if (this->roundabouts_parser_)
        this->roundabouts_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Nodes_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "UniNodes" && ns.empty ())
    {
      if (this->UniNodes_parser_)
        this->UniNodes (this->UniNodes_parser_->post_UniNodes ());

      return true;
    }

    if (n == "Intersections" && ns.empty ())
    {
      if (this->Intersections_parser_)
        this->Intersections (this->Intersections_parser_->post_Intersections ());

      return true;
    }

    if (n == "roundabouts" && ns.empty ())
    {
      if (this->roundabouts_parser_)
        this->roundabouts (this->roundabouts_parser_->post_roundabouts ());

      return true;
    }

    return false;
  }

  // Links_pskel
  //

  void Links_pskel::
  Link (sim_mob::Link*)
  {
  }

  bool Links_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "Link" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Link_parser_;

      if (this->Link_parser_)
        this->Link_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Links_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "Link" && ns.empty ())
    {
      if (this->Link_parser_)
        this->Link (this->Link_parser_->post_link_t ());

      return true;
    }

    return false;
  }

  // UniNodes_pskel
  //

  void UniNodes_pskel::
  UniNode (sim_mob::UniNode*)
  {
  }

  bool UniNodes_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "UniNode" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->UniNode_parser_;

      if (this->UniNode_parser_)
        this->UniNode_parser_->pre ();

      return true;
    }

    return false;
  }

  bool UniNodes_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "UniNode" && ns.empty ())
    {
      if (this->UniNode_parser_)
        this->UniNode (this->UniNode_parser_->post_UniNode_t ());

      return true;
    }

    return false;
  }

  // Intersections_pskel
  //

  void Intersections_pskel::
  Intersection (sim_mob::MultiNode*)
  {
  }

  bool Intersections_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "Intersection" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Intersection_parser_;

      if (this->Intersection_parser_)
        this->Intersection_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Intersections_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "Intersection" && ns.empty ())
    {
      if (this->Intersection_parser_)
        this->Intersection (this->Intersection_parser_->post_intersection_t ());

      return true;
    }

    return false;
  }

  // roundabouts_pskel
  //

  void roundabouts_pskel::
  roundabout (sim_mob::MultiNode*)
  {
  }

  bool roundabouts_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "roundabout" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->roundabout_parser_;

      if (this->roundabout_parser_)
        this->roundabout_parser_->pre ();

      return true;
    }

    return false;
  }

  bool roundabouts_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "roundabout" && ns.empty ())
    {
      if (this->roundabout_parser_)
        this->roundabout (this->roundabout_parser_->post_roundabout_t ());

      return true;
    }

    return false;
  }
}
}

// Begin epilogue.
//
//
// End epilogue.


