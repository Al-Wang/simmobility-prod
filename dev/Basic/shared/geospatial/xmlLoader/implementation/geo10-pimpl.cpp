// Not copyrighted - public domain.
//
// This sample parser implementation was generated by CodeSynthesis XSD,
// an XML Schema to C++ data binding compiler. You may use it in your
// programs without any restrictions.
//
#include "geo10-pimpl.hpp"

#include <cstdio>
#include <iostream>
#include <boost/bimap.hpp>
#include "util/OpaqueProperty.hpp"


#include <boost/multi_index_container.hpp>
#include <boost/multi_index/member.hpp>
#include <boost/multi_index/ordered_index.hpp>
#include <boost/multi_index/random_access_index.hpp>
#include <boost/multi_index/composite_key.hpp>
#include <boost/multi_index/mem_fun.hpp>
using boost::multi_index::get;


namespace sim_mob {
namespace xml {

//int tmp_cnn_cnt = 0;
//int tmp_rs = 0;
/*struct geo_LinkLoc_mapping
{
	geo_LinkLoc_mapping(unsigned int linkID_=0,std::vector<sim_mob::Node*> node_=std::vector<sim_mob::Node*>(),sim_mob::Node *rawNode_=0):
		linkID(linkID_),
//		node1(node1_),
//		node2(node2_),
		node(node_),
		rawNode(rawNode_){}
	geo_LinkLoc_mapping(unsigned int linkID_=0,sim_mob::Node *rawNode_=0):
		linkID(linkID_),
		rawNode(rawNode_){}
	mutable unsigned long linkID;
//	mutable sim_mob::Node* node1;//can be starting node or ending node
//	mutable sim_mob::Node* node2;//can be starting node or ending node
	mutable std::vector<sim_mob::Node*> node;
	mutable sim_mob::Node *rawNode;//store temporary node created when reading basic node
};
typedef boost::multi_index_container<
		geo_LinkLoc_mapping,
		boost::multi_index::indexed_by<
		boost::multi_index::random_access<>//0
		,boost::multi_index::ordered_unique<boost::multi_index::member<geo_LinkLoc_mapping, unsigned long , &geo_LinkLoc_mapping::linkID> >//1
//		,boost::multi_index::ordered_non_unique<boost::multi_index::member<geo_LinkLoc_mapping, sim_mob::Node* , &geo_LinkLoc_mapping::node1> >//2
//		,boost::multi_index::ordered_non_unique<boost::multi_index::member<geo_LinkLoc_mapping, sim_mob::Node* , &geo_LinkLoc_mapping::node2> >//3
		,boost::multi_index::ordered_non_unique<boost::multi_index::member<geo_LinkLoc_mapping, sim_mob::Node* , &geo_LinkLoc_mapping::rawNode> >//2
									  >
									>geo_LinkLoc;
typedef boost::multi_index::nth_index<geo_LinkLoc, 0>::type geo_LinkLoc_random;
typedef boost::multi_index::nth_index<geo_LinkLoc, 1>::type geo_LinkLoc_linkID;
typedef boost::multi_index::nth_index<geo_LinkLoc, 2>::type geo_LinkLoc_rawNode;
//geo_LinkLoc_linkID::iterator geo_LinkLoc_linkID_it;
geo_LinkLoc geo_LinkLoc_;
std::map<unsigned int,sim_mob::Link*> geo_Links_;
std::map<unsigned long,sim_mob::RoadSegment*> geo_Segments_;
std::map<unsigned long,sim_mob::Lane*> geo_Lanes_;

std::map<unsigned int,std::set<unsigned long> > geo_RoadSegmentsAt; //<nodeId,set<segments>>
std::map<unsigned int, std::pair<std::pair<unsigned long,unsigned long>,std::pair<unsigned long,unsigned long> > > geo_UniNode_SegmentPairs; //map<nodeId, pair< pair<segId,SegId> , pair<segId,segId> >

helper::UniNodeConnectors geo_UniNode_Connectors;//todo
//std::map<unsigned int,helper::UniNodeConnectors> geo_UniNodeConnectorsMap;//<nodeId,helper::UniNodeConnectors>
std::map<unsigned int,helper::MultiNodeConnectors> geo_MultiNodeConnectorsMap;//map <nodeId,helper::MultiNodeConnectors> or map <nodeId,map<roadsegment,set<pair<lanefrom,laneto>> > >

struct BusStopInfo
{
	sim_mob::BusStop *busStop;
	unsigned long lane_location;
	BusStopInfo()
	{
		busStop = 0;
		lane_location = -1;
	}
} bs_info;

std::map<unsigned long,BusStopInfo> geo_BusStop_; // map<busstopid,BusStopInfo>

*/


}} //End namespace sim_mob::xml

