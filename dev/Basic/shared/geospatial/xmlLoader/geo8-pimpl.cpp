// Not copyrighted - public domain.
//
// This sample parser implementation was generated by CodeSynthesis XSD,
// an XML Schema to C++ data binding compiler. You may use it in your
// programs without any restrictions.
//
#include "geo8-pimpl.hpp"
#include <cstdio>
#include <iostream>
#include <boost/bimap.hpp>

namespace geo
{
//std::map<std::string,sim_mob::RoadSegment*> geo_Segments_;
//std::map<std::string,sim_mob::Lane*> geo_Lanes_;
//std::map<std::string,sim_mob::Node*> geo_Nodes_;

typedef boost::bimap<std::string,sim_mob::RoadSegment*> geo_Segments; geo_Segments geo_Segments_;
typedef boost::bimap<std::string,sim_mob::Lane*> geo_Lanes; geo_Lanes geo_Lanes_;
typedef boost::bimap<unsigned int,sim_mob::Node*> geo_Nodes; geo_Nodes geo_Nodes_;

typedef geo_Segments::value_type position_Segments_;
typedef geo_Lanes::value_type position_Lanes_;
typedef geo_Nodes::value_type position_Nodes_;
  // SegmentType_t_pimpl
  //

  void SegmentType_t_pimpl::
  pre ()
  {
  }

  std::string SegmentType_t_pimpl::
  post_SegmentType_t ()
  {
    const ::std::string& v (post_string ());

    // TODO
    //
    // return ... ;
  }

  // ObstacleType_t_pimpl
  //

  void ObstacleType_t_pimpl::
  pre ()
  {
  }

  void ObstacleType_t_pimpl::
  post_ObstacleType_t ()
  {
    const ::std::string& v (post_string ());

    std::cout << "ObstacleType_t: " << v << std::endl;
  }

  // Point2D_t_pimpl
  //

  void Point2D_t_pimpl::
  pre ()
  {
  }

  void Point2D_t_pimpl::
  xPos (unsigned int xPos)
  {
    point2D.setX(xPos);
  }

  void Point2D_t_pimpl::
  yPos (unsigned int yPos)
  {
    point2D.setY(yPos);
  }

  sim_mob::Point2D Point2D_t_pimpl::
  post_Point2D_t ()
  {
	  return point2D;
  }

  // PolyPoint_t_pimpl
  //

  void PolyPoint_t_pimpl::
  pre ()
  {
  }

  void PolyPoint_t_pimpl::
  pointID (const ::std::string& pointID)
  {
  }

  void PolyPoint_t_pimpl::
  location (sim_mob::Point2D location)
  {
	  point2D = location;
  }

  sim_mob::Point2D PolyPoint_t_pimpl::
  post_PolyPoint_t ()
  {
	  return point2D;
  }

  // PolyLine_t_pimpl
  //

  void PolyLine_t_pimpl::
  pre ()
  {
  }

  void PolyLine_t_pimpl::
  PolyPoint (sim_mob::Point2D PolyPoint)
  {
	  polyLine.push_back(PolyPoint);
  }

  std::vector<sim_mob::Point2D> PolyLine_t_pimpl::
  post_PolyLine_t ()
  {
     return polyLine ;
  }

  // lane_t_pimpl
  //

  void lane_t_pimpl::
  pre ()
  {
	  this->lane = new sim_mob::Lane();
  }

  void lane_t_pimpl::
  laneID (const ::std::string& laneID)
  {
	  this->lane->laneID_ = atoi(laneID.c_str());
	  //add it to the book keeper;
//	  geo_Lanes_[laneID] = this->lane;
	  geo_Lanes_.insert(position_Lanes_(laneID,this->lane));
  }

  void lane_t_pimpl::
  width (unsigned int width)
  {
	  this->lane->width_ = width;
  }

  void lane_t_pimpl::
  can_go_straight (bool can_go_straight)
  {
	  this->lane->can_go_straight(can_go_straight);
  }

  void lane_t_pimpl::
  can_turn_left (bool can_turn_left)
  {
	  this->lane->can_turn_left(can_turn_left);
  }

  void lane_t_pimpl::
  can_turn_right (bool can_turn_right)
  {
	  this->lane->can_turn_right(can_turn_right);
  }

  void lane_t_pimpl::
  can_turn_on_red_signal (bool can_turn_on_red_signal)
  {
	  this->lane->can_turn_on_red_signal(can_turn_on_red_signal);
  }

  void lane_t_pimpl::
  can_change_lane_left (bool can_change_lane_left)
  {
	  this->lane->can_change_lane_left(can_change_lane_left);
  }

  void lane_t_pimpl::
  can_change_lane_right (bool can_change_lane_right)
  {
	  this->lane->can_change_lane_right(can_change_lane_right);
  }

  void lane_t_pimpl::
  is_road_shoulder (bool is_road_shoulder)
  {
	  this->lane->is_road_shoulder(is_road_shoulder);
  }

  void lane_t_pimpl::
  is_bicycle_lane (bool is_bicycle_lane)
  {
	  this->lane->is_bicycle_lane(is_bicycle_lane);
  }

  void lane_t_pimpl::
  is_pedestrian_lane (bool is_pedestrian_lane)
  {
	  this->lane->is_pedestrian_lane(is_pedestrian_lane);
  }

  void lane_t_pimpl::
  is_vehicle_lane (bool is_vehicle_lane)
  {
	  this->lane->is_vehicle_lane(is_vehicle_lane);
  }

  void lane_t_pimpl::
  is_standard_bus_lane (bool is_standard_bus_lane)
  {
	  this->lane->is_standard_bus_lane(is_standard_bus_lane);
  }

  void lane_t_pimpl::
  is_whole_day_bus_lane (bool is_whole_day_bus_lane)
  {
	  this->lane->is_whole_day_bus_lane(is_whole_day_bus_lane);
  }

  void lane_t_pimpl::
  is_high_occupancy_vehicle_lane (bool is_high_occupancy_vehicle_lane)
  {
	  this->lane->is_high_occupancy_vehicle_lane(is_high_occupancy_vehicle_lane);
  }

  void lane_t_pimpl::
  can_freely_park_here (bool can_freely_park_here)
  {
	  this->lane->can_freely_park_here(can_freely_park_here);
  }

  void lane_t_pimpl::
  can_stop_here (bool can_stop_here)
  {
	  this->lane->can_stop_here(can_stop_here);
  }

  void lane_t_pimpl::
  is_u_turn_allowed (bool is_u_turn_allowed)
  {
	  this->lane->is_u_turn_allowed(is_u_turn_allowed);
  }

  void lane_t_pimpl::
  PolyLine (std::vector<sim_mob::Point2D> PolyLine)
  {
	  this->lane->polyline_ = PolyLine;
  }

  sim_mob::Lane* lane_t_pimpl::
  post_lane_t ()
  {
//	  std::cout<< "Lane returning\n";
    return this->lane;
  }

  // connector_t_pimpl
  //

  void connector_t_pimpl::
  pre ()
  {
	  laneConnector = new sim_mob::LaneConnector;
  }

  void connector_t_pimpl::
  laneFrom (const ::std::string& laneFrom)
  {
	  laneConnector->laneFrom = geo_Lanes_.left.at(const_cast<std::string &>(laneFrom));
  }

  void connector_t_pimpl::
  laneTo (const ::std::string& laneTo)
  {
	  laneConnector->laneTo =  geo_Lanes_.left.at(laneTo);
  }

  sim_mob::LaneConnector* connector_t_pimpl::
  post_connector_t ()
  {
	  return laneConnector;
  }

  // connectors_t_pimpl
  //

  void connectors_t_pimpl::
  pre ()
  {
	  this->ConnectorSet.clear();
  }

  void connectors_t_pimpl::
  Connector (sim_mob::LaneConnector* Connector)
  {
	  this->ConnectorSet.insert(Connector);
  }

  std::set<sim_mob::LaneConnector*> connectors_t_pimpl::
  post_connectors_t ()
  {
	  return this->ConnectorSet;
    // TODO
    //
    // return ... ;
  }

  // Multi_Connector_t_pimpl
  //

  void Multi_Connector_t_pimpl::
  pre ()
  {
  }

  void Multi_Connector_t_pimpl::
  RoadSegment (const ::std::string& RoadSegment)
  {
	  this->RoadSegment_ = RoadSegment;
  }

  void Multi_Connector_t_pimpl::
  Connectors (std::set<sim_mob::LaneConnector*> Connectors)
  {
	  temp_pair = std::make_pair(this->RoadSegment_,Connectors);
  }

  std::pair<std::string,std::set<sim_mob::LaneConnector*> >   Multi_Connector_t_pimpl::
  post_Multi_Connector_t ()
  {
	  return temp_pair;
  }

  // Multi_Connectors_t_pimpl
  //

  void Multi_Connectors_t_pimpl::
  pre ()
  {
  }

  void Multi_Connectors_t_pimpl::
  MultiConnectors (const std::pair<std::string,std::set<sim_mob::LaneConnector*> >  & MultiConnectors)
  {
	  temp_map[geo_Segments_.left.at(MultiConnectors.first)] = MultiConnectors.second;
  }

  std::map<const sim_mob::RoadSegment*,std::set<sim_mob::LaneConnector*> > Multi_Connectors_t_pimpl::
  post_Multi_Connectors_t ()
  {
	  return temp_map;
  }

  // fwdBckSegments_t_pimpl
  //

  void fwdBckSegments_t_pimpl::
  pre ()
  {
  }

  void fwdBckSegments_t_pimpl::
  Segment (sim_mob::RoadSegment* Segment)
  {
	  Segments.push_back(Segment);
  }

  std::vector<sim_mob::RoadSegment*> fwdBckSegments_t_pimpl::
  post_fwdBckSegments_t ()
  {
//	  std::cout << "In post_fwdBckSegments_t\n";
	  return Segments;
  }

  // RoadSegmentsAt_t_pimpl
  //

  void RoadSegmentsAt_t_pimpl::
  pre ()
  {
  }

  void RoadSegmentsAt_t_pimpl::
  segmentID (const ::std::string& segmentID)
  {
    std::cout << "segmentID: " << segmentID << std::endl;
    RoadSegments.insert(geo_Segments_.left.at(segmentID));
  }

  std::set<sim_mob::RoadSegment*> RoadSegmentsAt_t_pimpl::
  post_RoadSegmentsAt_t ()
  {
	  return RoadSegments;
    // TODO
    //
    // return ... ;
  }

  // segment_t_pimpl
  //

  void segment_t_pimpl::
  pre ()
  {
	  rs = new sim_mob::RoadSegment();
  }

  void segment_t_pimpl::
  segmentID (const ::std::string& segmentID)
  {
	  this->rs->segmentID = segmentID;
	  geo_Segments_.insert(position_Segments_(this->rs->segmentID,rs));
  }

  void segment_t_pimpl::
  startingNode (const ::std::string& startingNode)
  {
	  if(this->rs->start)//nodes are loaded after links-segment-lane... so this is null
		  this->rs->start->setID(atoi(startingNode.c_str()));
  }

  void segment_t_pimpl::
  endingNode (const ::std::string& endingNode)
  {
	  if (this->rs->end)
		  this->rs->end->setID(atoi(endingNode.c_str()));
  }

  void segment_t_pimpl::
  maxSpeed (short maxSpeed)
  {
	  this->rs->maxSpeed = maxSpeed;
  }

  void segment_t_pimpl::
  Length (unsigned int Length)
  {
	  this->rs->length = Length;
  }

  void segment_t_pimpl::
  Width (unsigned int Width)
  {
	  this->rs->width = Width;
  }

  void segment_t_pimpl::
  Lanes (std::vector<sim_mob::Lane*> Lanes)
  {
	  this->rs->lanes =  Lanes;
  }

  void segment_t_pimpl::
  Obstacles ()
  {
  }

  void segment_t_pimpl::
  KurbLine (std::vector<sim_mob::Point2D> KurbLine)
  {
    // TODO
    //
  }

  sim_mob::RoadSegment* segment_t_pimpl::
  post_segment_t ()
  {
	  return rs;
  }

  // link_t_pimpl
  //

  void link_t_pimpl::
  pre ()
  {
	  link = new sim_mob::Link();
  }

  void link_t_pimpl::
  linkID (const ::std::string& linkID)
  {
	  std::cout << "In linkID \n";
	  link->linkID = linkID;
  }

  void link_t_pimpl::
  roadName (const ::std::string& roadName)
  {
	  link->roadName = roadName;
  }

  void link_t_pimpl::
  StartingNode (const ::std::string& StartingNode)
  {
  }

  void link_t_pimpl::
  EndingNode (const ::std::string& EndingNode)
  {
  }

  void link_t_pimpl::
  Segments (std::pair<std::vector<sim_mob::RoadSegment*>,std::vector<sim_mob::RoadSegment*> > Segments)
  {
	  std::cout << "In link_t_pimpl::Segments()\n";
	  link->fwdSegments = Segments.first;
	  link->revSegments = Segments.second;
  }

  sim_mob::Link* link_t_pimpl::
  post_link_t ()
  {
    return link;
  }

  // separator_t_pimpl
  //

  void separator_t_pimpl::
  pre ()
  {
  }

  void separator_t_pimpl::
  separator_ID (unsigned short separator_ID)
  {
    std::cout << "separator_ID: " << separator_ID << std::endl;
  }

  void separator_t_pimpl::
  separator_value (bool separator_value)
  {
    std::cout << "separator_value: " << separator_value << std::endl;
  }

  void separator_t_pimpl::
  post_separator_t ()
  {
  }

  // separators_t_pimpl
  //

  void separators_t_pimpl::
  pre ()
  {
  }

  void separators_t_pimpl::
  Separator ()
  {
  }

  void separators_t_pimpl::
  post_separators_t ()
  {
  }

  // DomainIsland_t_pimpl
  //

  void DomainIsland_t_pimpl::
  pre ()
  {
  }

  void DomainIsland_t_pimpl::
  domainIsland_ID (unsigned short domainIsland_ID)
  {
    std::cout << "domainIsland_ID: " << domainIsland_ID << std::endl;
  }

  void DomainIsland_t_pimpl::
  domainIsland_value (bool domainIsland_value)
  {
    std::cout << "domainIsland_value: " << domainIsland_value << std::endl;
  }

  void DomainIsland_t_pimpl::
  post_DomainIsland_t ()
  {
  }

  // DomainIslands_t_pimpl
  //

  void DomainIslands_t_pimpl::
  pre ()
  {
  }

  void DomainIslands_t_pimpl::
  domainIslands ()
  {
  }

  void DomainIslands_t_pimpl::
  post_DomainIslands_t ()
  {
  }

  // offset_t_pimpl
  //

  void offset_t_pimpl::
  pre ()
  {
  }

  void offset_t_pimpl::
  offset_ID (unsigned short offset_ID)
  {
    std::cout << "offset_ID: " << offset_ID << std::endl;
  }

  void offset_t_pimpl::
  offset_value (unsigned int offset_value)
  {
    std::cout << "offset_value: " << offset_value << std::endl;
  }

  void offset_t_pimpl::
  post_offset_t ()
  {
  }

  // offsets_t_pimpl
  //

  void offsets_t_pimpl::
  pre ()
  {
  }

  void offsets_t_pimpl::
  offset ()
  {
  }

  void offsets_t_pimpl::
  post_offsets_t ()
  {
  }

  // ChunkLength_t_pimpl
  //

  void ChunkLength_t_pimpl::
  pre ()
  {
  }

  void ChunkLength_t_pimpl::
  chunklength_ID (unsigned short chunklength_ID)
  {
    std::cout << "chunklength_ID: " << chunklength_ID << std::endl;
  }

  void ChunkLength_t_pimpl::
  chunklength_value (unsigned int chunklength_value)
  {
    std::cout << "chunklength_value: " << chunklength_value << std::endl;
  }

  void ChunkLength_t_pimpl::
  post_ChunkLength_t ()
  {
  }

  // ChunkLengths_t_pimpl
  //

  void ChunkLengths_t_pimpl::
  pre ()
  {
  }

  void ChunkLengths_t_pimpl::
  chunklength ()
  {
  }

  void ChunkLengths_t_pimpl::
  post_ChunkLengths_t ()
  {
  }

  // LanesVector_t_pimpl
  //

  void LanesVector_t_pimpl::
  pre ()
  {
  }

  void LanesVector_t_pimpl::
  laneID (const ::std::string& laneID)
  {
    std::cout << "laneID: " << laneID << std::endl;
  }

  void LanesVector_t_pimpl::
  post_LanesVector_t ()
  {
  }

  // EntranceAngle_t_pimpl
  //

  void EntranceAngle_t_pimpl::
  pre ()
  {
  }

  void EntranceAngle_t_pimpl::
  entranceAngle_ID (unsigned short entranceAngle_ID)
  {
    std::cout << "entranceAngle_ID: " << entranceAngle_ID << std::endl;
  }

  void EntranceAngle_t_pimpl::
  entranceAngle_value (unsigned int entranceAngle_value)
  {
    std::cout << "entranceAngle_value: " << entranceAngle_value << std::endl;
  }

  void EntranceAngle_t_pimpl::
  post_EntranceAngle_t ()
  {
  }

  // EntranceAngles_t_pimpl
  //

  void EntranceAngles_t_pimpl::
  pre ()
  {
  }

  void EntranceAngles_t_pimpl::
  entranceAngle ()
  {
  }

  void EntranceAngles_t_pimpl::
  post_EntranceAngles_t ()
  {
  }

  // UniNode_t_pimpl
  //

  void UniNode_t_pimpl::
  pre ()
  {
	  //can't create the lane in here coz we yet have to obtain location x,y
  }

  void UniNode_t_pimpl::
  nodeID (const ::std::string& nodeID)
  {
    this->nodeId = atoi(nodeID.c_str());
  }

  void UniNode_t_pimpl::
  location (sim_mob::Point2D location)
  {
	  this->location_ = location;
  }

  void UniNode_t_pimpl::
  Connectors (std::set<sim_mob::LaneConnector*> Connectors)
  {
	  std::cout << "Uninode Connector size " << Connectors.size() << std::endl;
	  std::set<sim_mob::LaneConnector*>::iterator it = Connectors.begin();
	  //uninode class uses map not set so ...convert...
	  for(; it != Connectors.end(); it++)
	  {
		  this->connectors_[(*it)->laneFrom] = (*it)->laneTo;
	  }
  }

  sim_mob::UniNode* UniNode_t_pimpl::
  post_UniNode_t ()
  {
	  this->uniNode = new sim_mob::UniNode(this->location_.getX(),this->location_.getY());
	  this->uniNode->setID(this->nodeId);
	  this->uniNode->connectors = this->connectors_;
	  geo_Nodes_.insert(position_Nodes_(this->nodeId, this->uniNode));
	  return this->uniNode;
  }

  // roundabout_t_pimpl
  //

  void roundabout_t_pimpl::
  pre ()
  {
  }

  void roundabout_t_pimpl::
  nodeID (const ::std::string& nodeID)
  {
    std::cout << "nodeID: " << nodeID << std::endl;
  }

  void roundabout_t_pimpl::
  location (sim_mob::Point2D location)
  {
    // TODO
    //
  }

  void roundabout_t_pimpl::
  roadSegmentsAt (std::set<sim_mob::RoadSegment*> roadSegmentsAt)
  {
    // TODO
    //
  }

  void roundabout_t_pimpl::
  Connectors (const std::map<const sim_mob::RoadSegment*,std::set<sim_mob::LaneConnector *> >& Connectors)
  {
    // TODO
    //
  }

  void roundabout_t_pimpl::
  ChunkLengths ()
  {
  }

  void roundabout_t_pimpl::
  Offsets ()
  {
  }

  void roundabout_t_pimpl::
  Separators ()
  {
  }

  void roundabout_t_pimpl::
  addDominantLane ()
  {
  }

  void roundabout_t_pimpl::
  roundaboutDominantIslands (float roundaboutDominantIslands)
  {
    std::cout << "roundaboutDominantIslands: " << roundaboutDominantIslands << std::endl;
  }

  void roundabout_t_pimpl::
  roundaboutNumberOfLanes (int roundaboutNumberOfLanes)
  {
    std::cout << "roundaboutNumberOfLanes: " << roundaboutNumberOfLanes << std::endl;
  }

  void roundabout_t_pimpl::
  entranceAngles ()
  {
  }

  sim_mob::MultiNode* roundabout_t_pimpl::
  post_roundabout_t ()
  {
    // TODO
    //
    // return ... ;
  }

  // intersection_t_pimpl
  //

  void intersection_t_pimpl::
  pre ()
  {
	  std::cout << "intersection_t_pimpl::pre()\n";
  }

  void intersection_t_pimpl::
  nodeID (const ::std::string& nodeID)
  {
	  std::cout << "intersection_t_pimpl::location()\n";
	    this->nodeId = atoi(nodeID.c_str());
  }

  void intersection_t_pimpl::
  location (sim_mob::Point2D location)
  {
	  std::cout << "intersection_pimpl::location()\n";
	  this->location_ = location;
	  //here you can create the sim_mob object(you can do that in post_ function also but if you create it here, you can save a lot of space and copy time
	  this->intersection = new sim_mob::Intersection(this->location_.getX(), this->location_.getY());
	  this->intersection->setID(this->nodeId);
	  geo_Nodes_.insert(position_Nodes_(this->nodeId, this->intersection));
  }

  void intersection_t_pimpl::
  roadSegmentsAt (std::set<sim_mob::RoadSegment*> roadSegmentsAt)
  {
	  std::cout << "intersection_pimpl::roadSegmentsAt()\n";
	  this->intersection->roadSegmentsAt = roadSegmentsAt;
  }

  void intersection_t_pimpl::
  Connectors (const std::map<const sim_mob::RoadSegment*,std::set<sim_mob::LaneConnector *> >& Connectors)

  {
	  this->intersection->connectors = Connectors;
  }

  void intersection_t_pimpl::
  ChunkLengths ()
  {
  }

  void intersection_t_pimpl::
  Offsets ()
  {
  }

  void intersection_t_pimpl::
  Separators ()
  {
  }

  void intersection_t_pimpl::
  additionalDominantLanes ()
  {
  }

  void intersection_t_pimpl::
  additionalSubdominantLanes ()
  {
  }

  void intersection_t_pimpl::
  domainIslands ()
  {
  }

  sim_mob::MultiNode* intersection_t_pimpl::
  post_intersection_t ()
  {
	  std::cout << "intersection_pimpl::post_intersection_t()\n";
	  return this->intersection;
  }

  // RoadItem_No_Attr_t_pimpl
  //

  void RoadItem_No_Attr_t_pimpl::
  pre ()
  {
  }

  void RoadItem_No_Attr_t_pimpl::
  start (sim_mob::Point2D start)
  {
    // TODO
    //
  }

  void RoadItem_No_Attr_t_pimpl::
  end (sim_mob::Point2D end)
  {
    // TODO
    //
  }

  void RoadItem_No_Attr_t_pimpl::
  post_RoadItem_No_Attr_t ()
  {
  }

  // RoadItem_t_pimpl
  //

  void RoadItem_t_pimpl::
  pre ()
  {
  }

  void RoadItem_t_pimpl::
  Offset (unsigned short Offset)
  {
    std::cout << "Offset: " << Offset << std::endl;
  }

  void RoadItem_t_pimpl::
  start (sim_mob::Point2D start)
  {
    // TODO
    //
  }

  void RoadItem_t_pimpl::
  end (sim_mob::Point2D end)
  {
    // TODO
    //
  }

  sim_mob::RoadItem* RoadItem_t_pimpl::
  post_RoadItem_t ()
  {
    // TODO
    //
    // return ... ;
  }

  // BusStop_t_pimpl
  //

  void BusStop_t_pimpl::
  pre ()
  {
  }

  void BusStop_t_pimpl::
  busStopID (const ::std::string& busStopID)
  {
    std::cout << "busStopID: " << busStopID << std::endl;
  }

  void BusStop_t_pimpl::
  lane_location (const ::std::string& lane_location)
  {
    std::cout << "lane_location: " << lane_location << std::endl;
  }

  void BusStop_t_pimpl::
  is_Terminal (bool is_Terminal)
  {
    std::cout << "is_Terminal: " << is_Terminal << std::endl;
  }

  void BusStop_t_pimpl::
  is_Bay (bool is_Bay)
  {
    std::cout << "is_Bay: " << is_Bay << std::endl;
  }

  void BusStop_t_pimpl::
  has_shelter (bool has_shelter)
  {
    std::cout << "has_shelter: " << has_shelter << std::endl;
  }

  void BusStop_t_pimpl::
  busCapacityAsLength (unsigned int busCapacityAsLength)
  {
    std::cout << "busCapacityAsLength: " << busCapacityAsLength << std::endl;
  }

  void BusStop_t_pimpl::
  post_BusStop_t ()
  {
    sim_mob::RoadItem* v (post_RoadItem_t ());

    // TODO
    //
  }

  // ERP_Gantry_t_pimpl
  //

  void ERP_Gantry_t_pimpl::
  pre ()
  {
  }

  void ERP_Gantry_t_pimpl::
  ERP_GantryID (const ::std::string& ERP_GantryID)
  {
    std::cout << "ERP_GantryID: " << ERP_GantryID << std::endl;
  }

  void ERP_Gantry_t_pimpl::
  post_ERP_Gantry_t ()
  {
    sim_mob::RoadItem* v (post_RoadItem_t ());

    // TODO
    //
  }

  // FormType_pimpl
  //

  void FormType_pimpl::
  pre ()
  {
  }

  void FormType_pimpl::
  TextBox (int TextBox)
  {
    std::cout << "TextBox: " << TextBox << std::endl;
  }

  void FormType_pimpl::
  TextArea (int TextArea)
  {
    std::cout << "TextArea: " << TextArea << std::endl;
  }

  void FormType_pimpl::
  Header (int Header)
  {
    std::cout << "Header: " << Header << std::endl;
  }

  void FormType_pimpl::
  post_FormType ()
  {
  }

  // PointPair_t_pimpl
  //

  void PointPair_t_pimpl::
  pre ()
  {
  }

  void PointPair_t_pimpl::
  first (sim_mob::Point2D first)
  {
	  pointPair.first = first;
  }

  void PointPair_t_pimpl::
  second (sim_mob::Point2D second)
  {
	  pointPair.second = second;
  }

  std::pair<sim_mob::Point2D,sim_mob::Point2D> PointPair_t_pimpl::
  post_PointPair_t ()
  {
	  return pointPair;
  }

  // crossing_t_pimpl
  //

  void crossing_t_pimpl::
  pre ()
  {
	  crossing = new sim_mob::Crossing();
  }

  void crossing_t_pimpl::
  crossingID (const ::std::string& crossingID)
  {
	  std::cout << "crossingID: " << crossingID << std::endl;
    this->crossing->crossingID = atoi(crossingID.c_str());
  }

  void crossing_t_pimpl::
  nearLine (std::pair<sim_mob::Point2D,sim_mob::Point2D> nearLine)
  {
	  crossing->nearLine.first = nearLine.first;
  }

  void crossing_t_pimpl::
  farLine (std::pair<sim_mob::Point2D,sim_mob::Point2D> farLine)
  {
	  crossing->farLine.second = farLine.second;
  }

  sim_mob::Crossing* crossing_t_pimpl::
  post_crossing_t ()
  {
    sim_mob::RoadItem* v (post_RoadItem_t ());
    return crossing;
  }

  // RoadBump_t_pimpl
  //

  void RoadBump_t_pimpl::
  pre ()
  {
  }

  void RoadBump_t_pimpl::
  roadBumpID (const ::std::string& roadBumpID)
  {
    std::cout << "roadBumpID: " << roadBumpID << std::endl;
  }

  void RoadBump_t_pimpl::
  segmentID (const ::std::string& segmentID)
  {
    std::cout << "segmentID: " << segmentID << std::endl;
  }

  void RoadBump_t_pimpl::
  post_RoadBump_t ()
  {
    sim_mob::RoadItem* v (post_RoadItem_t ());

    // TODO
    //
  }

  // RoadNetwork_t_pimpl
  //

  void RoadNetwork_t_pimpl::
  pre ()
  {
	  rn = sim_mob::ConfigParams::GetInstance().getNetworkRW();
	  std::cout << "In RoadNetwork_t_pimpl::pre\n";
  }

  void RoadNetwork_t_pimpl::
  Links (std::vector<sim_mob::Link*> Links)
  {
	  rn.links = Links;
	  std::cout << "Links Done	\n";
  }

  void RoadNetwork_t_pimpl::
  Nodes ()
  {
  }

  void RoadNetwork_t_pimpl::
  post_RoadNetwork_t ()
  {
  }

  // RoadItems_t_pimpl
  //

  void RoadItems_t_pimpl::
  pre ()
  {
  }

  void RoadItems_t_pimpl::
  BusStop ()
  {
  }

  void RoadItems_t_pimpl::
  ERP_Gantry ()
  {
  }

  void RoadItems_t_pimpl::
  Crossing (sim_mob::Crossing* Crossing)
  {
    // TODO
    //
  }

  void RoadItems_t_pimpl::
  RoadBump ()
  {
  }

  void RoadItems_t_pimpl::
  post_RoadItems_t ()
  {
  }

  // GeoSpatial_t_pimpl
  //
//non_Automated funcions
  void GeoSpatial_t_pimpl::setStartEndNode()
  {
	  setStartEndNode_Links();
	  setStartEndNode_Segments();
	  setStartEndNode_Lanes();
  }
  void GeoSpatial_t_pimpl::setStartEndNode_Links()
  {
  }
  void GeoSpatial_t_pimpl::setStartEndNode_Segments()
  {
	  for(geo_Segments::right_iterator it = geo_Segments_.right.begin(), it_end(geo_Segments_.right.end()); it != it_end; it++)
	  {
//		  (*it)->
//		  geo_Nodes::
	  }
  }
  void GeoSpatial_t_pimpl::setStartEndNode_Lanes()
  {

  }
  void GeoSpatial_t_pimpl::
  pre ()
  {
	  std::cout << "In GeoSpatial_t_pimpl.pre\n";
  }

  void GeoSpatial_t_pimpl::
  RoadNetwork ()
  {
	  setStartEndNode();
  }

  void GeoSpatial_t_pimpl::
  post_GeoSpatial_t ()
  {
  }

  // SimMobility_t_pimpl
  //

  void SimMobility_t_pimpl::
  pre ()
  {
	  std::cout << "In SimMobility_t_pimpl.pre()\n";
  }

  void SimMobility_t_pimpl::
  GeoSpatial ()
  {
	  std::cout << "In SimMobility_t_pimpl::GeoSpatial ()\n";
  }

  void SimMobility_t_pimpl::
  post_SimMobility_t ()
  {
  }

  // Lanes_pimpl
  //

  void Lanes_pimpl::
  pre ()
  {
  }

  void Lanes_pimpl::
  Lane (sim_mob::Lane* Lane)
  {
	  this->lanes.push_back(Lane);
  }

  std::vector<sim_mob::Lane*> Lanes_pimpl::
  post_Lanes ()
  {
//	  std::cout<< "Returning Lanes\n";
	  return this->lanes;
  }

  // Segments_pimpl
  //

  void Segments_pimpl::
  pre ()
  {
  }

  void Segments_pimpl::
  FWDSegments (std::vector<sim_mob::RoadSegment*> FWDSegments)
  {
	  fwd = FWDSegments;
  }

  void Segments_pimpl::
  BKDSegments (std::vector<sim_mob::RoadSegment*> BKDSegments)
  {
	  bck = BKDSegments;
  }

  std::pair<std::vector<sim_mob::RoadSegment*>,std::vector<sim_mob::RoadSegment*> > Segments_pimpl::
  post_Segments ()
  {
	  return (std::make_pair(fwd,bck));
  }

  // Links_pimpl
  //

  void Links_pimpl::
  pre ()
  {
  }

  void Links_pimpl::
  Link (sim_mob::Link* Link)
  {
	  links.push_back(Link);
	  std::cout << "Link Pushed\n";
  }

  std::vector<sim_mob::Link*> Links_pimpl::
  post_Links ()
  {
	  return links;
  }

  // Nodes_pimpl
  //
  void Nodes_pimpl::
  pre ()
  {
//	  this->instance = sim_mob::ConfigParams::GetInstance();
//	  std::cout << "Nodes_pimpl::pre()\n";
  }

  void Nodes_pimpl::
  UniNodes (std::set<sim_mob::UniNode*> UniNodes)
  {
	  rn.segmentnodes = UniNodes;
    // TODO
    //
  }

  void Nodes_pimpl::
  Intersections (std::vector<sim_mob::MultiNode*> Intersections)
  {

	  rn.nodes.insert(rn.nodes.begin(),Intersections.begin(),Intersections.end());
	  std::cout<< "Intersections inserted\n";
    // TODO
    //
  }

  void Nodes_pimpl::
  roundabouts (std::vector<sim_mob::MultiNode*> roundabouts)
  {
	  std::cout<< "roundabouts inserting size " << roundabouts.size() << std::endl;
	  if((roundabouts.begin() != roundabouts.end())&& roundabouts.size() > 0 )
		  rn.nodes.insert(rn.nodes.end(),roundabouts.begin(),roundabouts.end());
	  std::cout<< "roundabouts inserted\n";
    // TODO
    //
  }

  void Nodes_pimpl::
  post_Nodes ()
  {
	  std::cout<< "post_Nodes called\n";
  }

  // UniNodes_pimpl
  //

  void UniNodes_pimpl::
  pre ()
  {
	  std::cout << "UniNodes_pimpl::pre()\n";
  }

  void UniNodes_pimpl::
  UniNode (sim_mob::UniNode* UniNode)
  {
	  uniNodes.insert(UniNode);
  }

  std::set<sim_mob::UniNode*> UniNodes_pimpl::
  post_UniNodes ()
  {
	  std::cout << "UniNodes_pimpl::post_UniNodes()\n";
	  return uniNodes;
  }

  // Intersections_pimpl
  //

  void Intersections_pimpl::
  pre ()
  {
	  std::cout << "Intersections_pimpl::pre()\n";
  }

  void Intersections_pimpl::
  Intersection (sim_mob::MultiNode* Intersection)
  {
	  intersections.push_back(Intersection);
  }

  std::vector<sim_mob::MultiNode*> Intersections_pimpl::
  post_Intersections ()
  {
	  return intersections;
  }

  // roundabouts_pimpl
  //

  void roundabouts_pimpl::
  pre ()
  {
  }

  void roundabouts_pimpl::
  roundabout (sim_mob::MultiNode* roundabout)
  {
	  roundabouts.push_back(roundabout);
    // TODO
    //
  }

  std::vector<sim_mob::MultiNode*> roundabouts_pimpl::
  post_roundabouts ()
  {
	  return roundabouts;
  }
}

