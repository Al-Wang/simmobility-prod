// Not copyrighted - public domain.
//
// This sample parser implementation was generated by CodeSynthesis XSD,
// an XML Schema to C++ data binding compiler. You may use it in your
// programs without any restrictions.
//
#include "geo8-pimpl.hpp"
#include <cstdio>
#include <iostream>
#include <boost/bimap.hpp>

namespace geo
{
std::map<std::string,sim_mob::RoadSegment*> geo_Segments_;
std::map<std::string,sim_mob::Lane*> geo_Lanes_;
std::map<std::string,sim_mob::Node*> geo_Nodes_;
std::multimap<unsigned int,std::string> geo_RoadSegmentsAt; //<nodeId,segments>

typedef std::set<std::pair<std::string,std::string> > geo_UniNode_Connectors_type;//set<pair<lanefrom,laneto> >
geo_UniNode_Connectors_type geo_UniNode_Connectors;//todo
std::map<unsigned int,geo_UniNode_Connectors_type> geo_UniNodeConnectorsMap;//<nodeId,geo_UniNode_Connectors_type>

typedef std::map<std::string, geo_UniNode_Connectors_type > geo_MultiNode_Connectors_type; //map<roadsegment,set<pair<lanefrom,laneto>> >
geo_MultiNode_Connectors_type geo_MultiNode_Connectors;
std::map<unsigned int,geo_MultiNode_Connectors_type> geo_MultiNodeConnectorsMap;//<nodeId,geo_MultiNode_Connectors_type>

//typedef boost::bimap<std::string,sim_mob::RoadSegment*> geo_Segments; geo_Segments geo_Segments_;
//typedef boost::bimap<std::string,sim_mob::Lane*> geo_Lanes; geo_Lanes geo_Lanes_;
//typedef boost::bimap<unsigned int,sim_mob::Node*> geo_Nodes; geo_Nodes geo_Nodes_;

//typedef geo_Segments::value_type position_Segments_;
//typedef geo_Lanes::value_type position_Lanes_;
//typedef geo_Nodes::value_type position_Nodes_;
  // SegmentType_t_pimpl
  //


// Point2D_t_pimpl
  //

  void Point2D_t_pimpl::
  pre ()
  {
  }

  void Point2D_t_pimpl::
  xPos (unsigned int xPos)
  {
    point2D.setX(xPos);
  }

  void Point2D_t_pimpl::
  yPos (unsigned int yPos)
  {
    point2D.setY(yPos);
  }

  sim_mob::Point2D Point2D_t_pimpl::
  post_Point2D_t ()
  {
	  return point2D;
  }

  // PolyPoint_t_pimpl
  //

  void PolyPoint_t_pimpl::
  pre ()
  {
  }

  void PolyPoint_t_pimpl::
  pointID (const ::std::string& pointID)
  {
	  //todo
  }

  void PolyPoint_t_pimpl::
  location (sim_mob::Point2D location)
  {
	  point2D = location;
  }

  sim_mob::Point2D PolyPoint_t_pimpl::
  post_PolyPoint_t ()
  {
	  return point2D;
  }

  // PolyLine_t_pimpl
  //

  void PolyLine_t_pimpl::
  pre ()
  {
  }

  void PolyLine_t_pimpl::
  PolyPoint (sim_mob::Point2D PolyPoint)
  {
	  polyLine.push_back(PolyPoint);
  }

  std::vector<sim_mob::Point2D> PolyLine_t_pimpl::
  post_PolyLine_t ()
  {
     return polyLine ;
  }

  // lane_t_pimpl
  //

  void lane_t_pimpl::
  pre ()
  {
	  this->lane = new sim_mob::Lane();
  }

  void lane_t_pimpl::
  laneID (const ::std::string& laneID)
  {
	  this->lane->laneID_ = atoi(laneID.c_str());
	  //add it to the book keeper;
	  geo_Lanes_[laneID] = this->lane;
  }

  void lane_t_pimpl::
  width (unsigned int width)
  {
	  this->lane->width_ = width;
  }

  void lane_t_pimpl::
  can_go_straight (bool can_go_straight)
  {
	  this->lane->can_go_straight(can_go_straight);
  }

  void lane_t_pimpl::
  can_turn_left (bool can_turn_left)
  {
	  this->lane->can_turn_left(can_turn_left);
  }

  void lane_t_pimpl::
  can_turn_right (bool can_turn_right)
  {
	  this->lane->can_turn_right(can_turn_right);
  }

  void lane_t_pimpl::
  can_turn_on_red_signal (bool can_turn_on_red_signal)
  {
	  this->lane->can_turn_on_red_signal(can_turn_on_red_signal);
  }

  void lane_t_pimpl::
  can_change_lane_left (bool can_change_lane_left)
  {
	  this->lane->can_change_lane_left(can_change_lane_left);
  }

  void lane_t_pimpl::
  can_change_lane_right (bool can_change_lane_right)
  {
	  this->lane->can_change_lane_right(can_change_lane_right);
  }

  void lane_t_pimpl::
  is_road_shoulder (bool is_road_shoulder)
  {
	  this->lane->is_road_shoulder(is_road_shoulder);
  }

  void lane_t_pimpl::
  is_bicycle_lane (bool is_bicycle_lane)
  {
	  this->lane->is_bicycle_lane(is_bicycle_lane);
  }

  void lane_t_pimpl::
  is_pedestrian_lane (bool is_pedestrian_lane)
  {
	  this->lane->is_pedestrian_lane(is_pedestrian_lane);
  }

  void lane_t_pimpl::
  is_vehicle_lane (bool is_vehicle_lane)
  {
	  this->lane->is_vehicle_lane(is_vehicle_lane);
  }

  void lane_t_pimpl::
  is_standard_bus_lane (bool is_standard_bus_lane)
  {
	  this->lane->is_standard_bus_lane(is_standard_bus_lane);
  }

  void lane_t_pimpl::
  is_whole_day_bus_lane (bool is_whole_day_bus_lane)
  {
	  this->lane->is_whole_day_bus_lane(is_whole_day_bus_lane);
  }

  void lane_t_pimpl::
  is_high_occupancy_vehicle_lane (bool is_high_occupancy_vehicle_lane)
  {
	  this->lane->is_high_occupancy_vehicle_lane(is_high_occupancy_vehicle_lane);
  }

  void lane_t_pimpl::
  can_freely_park_here (bool can_freely_park_here)
  {
	  this->lane->can_freely_park_here(can_freely_park_here);
  }

  void lane_t_pimpl::
  can_stop_here (bool can_stop_here)
  {
	  this->lane->can_stop_here(can_stop_here);
  }

  void lane_t_pimpl::
  is_u_turn_allowed (bool is_u_turn_allowed)
  {
	  this->lane->is_u_turn_allowed(is_u_turn_allowed);
  }

  void lane_t_pimpl::
  PolyLine (std::vector<sim_mob::Point2D> PolyLine)
  {
	  this->lane->polyline_ = PolyLine;
  }

  sim_mob::Lane* lane_t_pimpl::
  post_lane_t ()
  {
    return this->lane;
  }

  // connector_t_pimpl
  //

  void connector_t_pimpl::
  pre ()
  {
	  this->connector.first = this->connector.second = "";
  }

  void connector_t_pimpl::
  laneFrom (const ::std::string& laneFrom)
  {
	  this->connector.first = laneFrom;
  }

  void connector_t_pimpl::
  laneTo (const ::std::string& laneTo)
  {
	  this->connector.second = laneTo;
  }

  std::pair<std::string,std::string> connector_t_pimpl::
  post_connector_t ()
  {
	  return this->connector;
  }

  // connectors_t_pimpl
  //

  void connectors_t_pimpl::
  pre ()
  {
  }

  void connectors_t_pimpl::
  Connector (std::pair<std::string,std::string> Connector)
  {
	  this->Connectors.insert(Connector);
  }

  std::set<std::pair<std::string,std::string > > connectors_t_pimpl::
  post_connectors_t ()
  {
	  return this->Connectors;
  }

  // Multi_Connector_t_pimpl
  //

  void Multi_Connector_t_pimpl::
  pre ()
  {
  }

  void Multi_Connector_t_pimpl::
  RoadSegment (const ::std::string& RoadSegment)
  {
	  temp_pair.first = RoadSegment;
  }

  void Multi_Connector_t_pimpl::
  Connectors (std::set<std::pair<std::string,std::string > > Connectors)
  {
	  temp_pair.second = Connectors;
  }

  std::pair<std::string,std::set<std::pair<std::string,std::string> > > Multi_Connector_t_pimpl::
  post_Multi_Connector_t ()
  {
	  return temp_pair;
  }

  // Multi_Connectors_t_pimpl
  //

  void Multi_Connectors_t_pimpl::
  pre ()
  {
  }

  void Multi_Connectors_t_pimpl::
  MultiConnectors (const std::pair<std::string,std::set<std::pair<std::string,std::string> > >& MultiConnectors)
  {
	  geo_MultiNode_Connectors[MultiConnectors.first] = MultiConnectors.second;
  }

  std::map<std::string,std::set<std::pair<std::string,std::string> > > Multi_Connectors_t_pimpl::
  post_Multi_Connectors_t ()
  {
	  return geo_MultiNode_Connectors;
  }

  // fwdBckSegments_t_pimpl
  //

  void fwdBckSegments_t_pimpl::
  pre ()
  {
	  std::cout << "in fwdBckSegments_t_pimpl::pre () " << std::endl;
  }

  void fwdBckSegments_t_pimpl::
  Segment (sim_mob::RoadSegment* Segment)
  {
	  std::cout << "in fwdBckSegments_t_pimpl::Segment () " << std::endl;
	  Segments.push_back(Segment);
  }

  std::vector<sim_mob::RoadSegment*> fwdBckSegments_t_pimpl::
  post_fwdBckSegments_t ()
  {
	  std::cout << "in fwdBckSegments_t_pimpl::post_fwdBckSegments_t () " << std::endl;
	  return Segments;
  }

  // RoadSegmentsAt_t_pimpl
  //

  void RoadSegmentsAt_t_pimpl::
  pre ()
  {
  }

  void RoadSegmentsAt_t_pimpl::
  segmentID (const ::std::string& segmentID)
  {
    std::cout << "segmentID: " << segmentID << std::endl;
    RoadSegments.insert(segmentID);
  }

  std::set<std::string> RoadSegmentsAt_t_pimpl::
  post_RoadSegmentsAt_t ()
  {
	  return RoadSegments;
  }

  // segment_t_pimpl
  //

  void segment_t_pimpl::
  pre ()
  {
	  std::cout << "In segment_t_pimpl:: pre ()\n";
	  rs = new sim_mob::RoadSegment();
  }

  void segment_t_pimpl::
  segmentID (const ::std::string& segmentID)
  {
	  std::cout << "In segment_t_pimpl:: segmentID ()\n";
	  this->rs->segmentID = segmentID;
	  geo_Segments_[this->rs->segmentID] = rs;
  }

  void segment_t_pimpl::
  startingNode (const ::std::string& startingNode)
  {
	  std::cout << "In segment_t_pimpl::   startingNode ()\n";
	  this->rs->start = geo_Nodes_[startingNode];
  }

  void segment_t_pimpl::
  endingNode (const ::std::string& endingNode)
  {
	  std::cout << "In segment_t_pimpl::   endingNode ()\n";
	  this->rs->end = geo_Nodes_[endingNode];
  }

  void segment_t_pimpl::
  maxSpeed (short maxSpeed)
  {
	  this->rs->maxSpeed = maxSpeed;
  }

  void segment_t_pimpl::
  Length (unsigned int Length)
  {
	  this->rs->length = Length;
  }

  void segment_t_pimpl::
  Width (unsigned int Width)
  {
	  this->rs->width = Width;
  }

  void segment_t_pimpl::
  Lanes (std::vector<sim_mob::Lane*> Lanes)
  {
	  std::cout << "In segment_t_pimpl:: Lanes ()\n";
	  this->rs->lanes =  Lanes;
	  std::cout << "In segment_t_pimpl:: Lanes ()--done\n";
  }

  void segment_t_pimpl::
  Obstacles (std::map<centimeter_t,const RoadItem*>& Obstacles)
  {
	  std::cout << "in segment_t_pimpl::Obstacles () " << std::endl;
	  this->rs->obstacles = Obstacles;
  }

  void segment_t_pimpl::
  KurbLine (std::vector<sim_mob::Point2D> KurbLine)
  {
    // TODO
    //
  }

  sim_mob::RoadSegment* segment_t_pimpl::
  post_segment_t ()
  {
	  return rs;
  }

  // link_t_pimpl
  //

  void link_t_pimpl::
  pre ()
  {
	  link = new sim_mob::Link();
  }

  void link_t_pimpl::
  linkID (const ::std::string& linkID)
  {
	  std::cout << "In linkID \n";
	  link->linkID = linkID;
  }

  void link_t_pimpl::
  roadName (const ::std::string& roadName)
  {
	  link->roadName = roadName;
  }

  void link_t_pimpl::
  StartingNode (const ::std::string& StartingNode)
  {
	  this->link->start = geo_Nodes_[StartingNode];
  }

  void link_t_pimpl::
  EndingNode (const ::std::string& EndingNode)
  {
	  this->link->end = geo_Nodes_[EndingNode];
  }

  void link_t_pimpl::
  Segments (std::pair<std::vector<sim_mob::RoadSegment*>,std::vector<sim_mob::RoadSegment*> > Segments)
  {
	  std::cout << "In link_t_pimpl::Segments()\n";
	  link->fwdSegments = Segments.first;
	  link->revSegments = Segments.second;
  }

  sim_mob::Link* link_t_pimpl::
  post_link_t ()
  {
    return link;
  }

  // separator_t_pimpl
  //

  void separator_t_pimpl::
  pre ()
  {
  }

  void separator_t_pimpl::
  separator_ID (unsigned short separator_ID)
  {
    std::cout << "separator_ID: " << separator_ID << std::endl;
  }

  void separator_t_pimpl::
  separator_value (bool separator_value)
  {
    std::cout << "separator_value: " << separator_value << std::endl;
  }

  void separator_t_pimpl::
  post_separator_t ()
  {
  }

  // separators_t_pimpl
  //

  void separators_t_pimpl::
  pre ()
  {
  }

  void separators_t_pimpl::
  Separator ()
  {
  }

  void separators_t_pimpl::
  post_separators_t ()
  {
  }

  // DomainIsland_t_pimpl
  //

  void DomainIsland_t_pimpl::
  pre ()
  {
  }

  void DomainIsland_t_pimpl::
  domainIsland_ID (unsigned short domainIsland_ID)
  {
    std::cout << "domainIsland_ID: " << domainIsland_ID << std::endl;
  }

  void DomainIsland_t_pimpl::
  domainIsland_value (bool domainIsland_value)
  {
    std::cout << "domainIsland_value: " << domainIsland_value << std::endl;
  }

  void DomainIsland_t_pimpl::
  post_DomainIsland_t ()
  {
  }

  // DomainIslands_t_pimpl
  //

  void DomainIslands_t_pimpl::
  pre ()
  {
  }

  void DomainIslands_t_pimpl::
  domainIslands ()
  {
  }

  void DomainIslands_t_pimpl::
  post_DomainIslands_t ()
  {
  }

  // offset_t_pimpl
  //

  void offset_t_pimpl::
  pre ()
  {
  }

  void offset_t_pimpl::
  offset_ID (unsigned short offset_ID)
  {
    std::cout << "offset_ID: " << offset_ID << std::endl;
  }

  void offset_t_pimpl::
  offset_value (unsigned int offset_value)
  {
    std::cout << "offset_value: " << offset_value << std::endl;
  }

  void offset_t_pimpl::
  post_offset_t ()
  {
  }

  // offsets_t_pimpl
  //

  void offsets_t_pimpl::
  pre ()
  {
  }

  void offsets_t_pimpl::
  offset ()
  {
  }

  void offsets_t_pimpl::
  post_offsets_t ()
  {
  }

  // ChunkLength_t_pimpl
  //

  void ChunkLength_t_pimpl::
  pre ()
  {
  }

  void ChunkLength_t_pimpl::
  chunklength_ID (unsigned short chunklength_ID)
  {
    std::cout << "chunklength_ID: " << chunklength_ID << std::endl;
  }

  void ChunkLength_t_pimpl::
  chunklength_value (unsigned int chunklength_value)
  {
    std::cout << "chunklength_value: " << chunklength_value << std::endl;
  }

  void ChunkLength_t_pimpl::
  post_ChunkLength_t ()
  {
  }

  // ChunkLengths_t_pimpl
  //

  void ChunkLengths_t_pimpl::
  pre ()
  {
  }

  void ChunkLengths_t_pimpl::
  chunklength ()
  {
  }

  void ChunkLengths_t_pimpl::
  post_ChunkLengths_t ()
  {
  }

  // LanesVector_t_pimpl
  //

  void LanesVector_t_pimpl::
  pre ()
  {
  }

  void LanesVector_t_pimpl::
  laneID (const ::std::string& laneID)
  {
    std::cout << "laneID: " << laneID << std::endl;
  }

  void LanesVector_t_pimpl::
  post_LanesVector_t ()
  {
  }

  // EntranceAngle_t_pimpl
  //

  void EntranceAngle_t_pimpl::
  pre ()
  {
  }

  void EntranceAngle_t_pimpl::
  entranceAngle_ID (unsigned short entranceAngle_ID)
  {
    std::cout << "entranceAngle_ID: " << entranceAngle_ID << std::endl;
  }

  void EntranceAngle_t_pimpl::
  entranceAngle_value (unsigned int entranceAngle_value)
  {
    std::cout << "entranceAngle_value: " << entranceAngle_value << std::endl;
  }

  void EntranceAngle_t_pimpl::
  post_EntranceAngle_t ()
  {
  }

  // EntranceAngles_t_pimpl
  //

  void EntranceAngles_t_pimpl::
  pre ()
  {
  }

  void EntranceAngles_t_pimpl::
  entranceAngle ()
  {
  }

  void EntranceAngles_t_pimpl::
  post_EntranceAngles_t ()
  {
  }

  // UniNode_t_pimpl
  //

  void UniNode_t_pimpl::
  pre ()
  {
	  //can't create the lane in here coz we yet have to obtain location x,y
  }

  void UniNode_t_pimpl::
  nodeID (const ::std::string& nodeID)
  {
    this->nodeId = nodeID;
  }

  void UniNode_t_pimpl::
  location (sim_mob::Point2D location)
  {
	  this->location_ = location;
  }

  void UniNode_t_pimpl::
  Connectors (std::set<std::pair<std::string,std::string> > Connectors)
  {
	  geo_UniNodeConnectorsMap[atoi(this->nodeId.c_str())] = Connectors;
//	  std::cout << "Uninode Connector size " << Connectors.size() << std::endl;
//	  std::set<sim_mob::LaneConnector*>::iterator it = Connectors.begin();
//	  //uninode class uses map not set so ...convert...
//	  for(; it != Connectors.end(); it++)
//	  {
//		  this->connectors_[(*it)->laneFrom] = (*it)->laneTo;
//	  }

  }

  sim_mob::UniNode* UniNode_t_pimpl::
  post_UniNode_t ()
  {
	  this->uniNode = new sim_mob::UniNode(this->location_.getX(),this->location_.getY());
	  this->uniNode->setID(atoi(this->nodeId.c_str()));
	  this->uniNode->connectors = this->connectors_;
//	  geo_Nodes_.insert(position_Nodes_(this->nodeId, this->uniNode));
	  geo_Nodes_[this->nodeId] = this->uniNode;
	  return this->uniNode;
  }

  // roundabout_t_pimpl
  //

  void roundabout_t_pimpl::
  pre ()
  {
  }

  void roundabout_t_pimpl::
  nodeID (const ::std::string& nodeID)
  {
    std::cout << "nodeID: " << nodeID << std::endl;
  }

  void roundabout_t_pimpl::
  location (sim_mob::Point2D location)
  {
    // TODO
    //
  }

  void roundabout_t_pimpl::
  roadSegmentsAt (std::set<std::string> roadSegmentsAt)
  {
    // TODO
    //
  }

  void roundabout_t_pimpl::
  Connectors (const std::map<std::string,std::set<std::pair<std::string,std::string> > >& Connectors)
  {
    // TODO
    //
  }

  void roundabout_t_pimpl::
  ChunkLengths ()
  {
  }

  void roundabout_t_pimpl::
  Offsets ()
  {
  }

  void roundabout_t_pimpl::
  Separators ()
  {
  }

  void roundabout_t_pimpl::
  addDominantLane ()
  {
  }

  void roundabout_t_pimpl::
  roundaboutDominantIslands (float roundaboutDominantIslands)
  {
    std::cout << "roundaboutDominantIslands: " << roundaboutDominantIslands << std::endl;
  }

  void roundabout_t_pimpl::
  roundaboutNumberOfLanes (int roundaboutNumberOfLanes)
  {
    std::cout << "roundaboutNumberOfLanes: " << roundaboutNumberOfLanes << std::endl;
  }

  void roundabout_t_pimpl::
  entranceAngles ()
  {
  }

  sim_mob::MultiNode* roundabout_t_pimpl::
  post_roundabout_t ()
  {
    // TODO
    //
    // return ... ;
  }

  // intersection_t_pimpl
  //

  void intersection_t_pimpl::
  pre ()
  {
	  std::cout << "intersection_t_pimpl::pre()\n";
  }

  void intersection_t_pimpl::
  nodeID (const ::std::string& nodeID)
  {
	  std::cout << "intersection_t_pimpl::location()\n";
	    this->nodeId_str = nodeID;
	    this->nodeId = atoi(this->nodeId_str.c_str());//trade space for calculation
  }

  void intersection_t_pimpl::
  location (sim_mob::Point2D location)
  {
	  std::cout << "intersection_pimpl::location()\n";
	  this->location_ = location;
	  //here you can create the sim_mob object(you can do that in post_ function also but if you create it here, you can save a lot of space and copy time
	  this->intersection = new sim_mob::Intersection(this->location_.getX(), this->location_.getY());
	  this->intersection->setID(this->nodeId);
	  geo_Nodes_[this->nodeId_str] = this->intersection;
  }

  void intersection_t_pimpl::
  roadSegmentsAt (std::set<std::string> roadSegmentsAt)
  {
	  std::cout << "intersection_pimpl::roadSegmentsAt()\n";
	  for(std::set<std::string>::iterator it = roadSegmentsAt.begin(), it_end(roadSegmentsAt.end()); it != it_end ; it++)
		  geo_RoadSegmentsAt.insert(std::pair<unsigned int,std::string>(this->intersection->getID(),(*it)));//with assumption that nodes precede links in XML
  }

  void intersection_t_pimpl::
  Connectors (const std::map<std::string,std::set<std::pair<std::string,std::string> > >& Connectors)
  {
	  geo_MultiNodeConnectorsMap[this->nodeId] = Connectors;
  }

  void intersection_t_pimpl::
  ChunkLengths ()
  {
  }

  void intersection_t_pimpl::
  Offsets ()
  {
  }

  void intersection_t_pimpl::
  Separators ()
  {
  }

  void intersection_t_pimpl::
  additionalDominantLanes ()
  {
  }

  void intersection_t_pimpl::
  additionalSubdominantLanes ()
  {
  }

  void intersection_t_pimpl::
  domainIslands ()
  {
  }

  sim_mob::MultiNode* intersection_t_pimpl::
  post_intersection_t ()
  {
	  std::cout << "intersection_pimpl::post_intersection_t()\n";
	  return this->intersection;
  }

  // RoadItem_No_Attr_t_pimpl
  //

  void RoadItem_No_Attr_t_pimpl::
  pre ()
  {
  }

  void RoadItem_No_Attr_t_pimpl::
  start (sim_mob::Point2D start)
  {
    // TODO
    //
  }

  void RoadItem_No_Attr_t_pimpl::
  end (sim_mob::Point2D end)
  {
    // TODO
    //
  }

  void RoadItem_No_Attr_t_pimpl::
  post_RoadItem_No_Attr_t ()
  {
  }

  // RoadItem_t_pimpl
  //

  void RoadItem_t_pimpl::
  pre ()
  {
	    std::cout << "in RoadItem_t_pimpl::pre  " << std::endl;
  }

  void RoadItem_t_pimpl::
  Offset (unsigned short Offset)
  {
    std::cout << "in RoadItem_t_pimpl::Offset: " << Offset << std::endl;
  }

  void RoadItem_t_pimpl::
  start (sim_mob::Point2D start)
  {
	  std::cout << "in RoadItem_t_pimpl::start\n";
  }

  void RoadItem_t_pimpl::
  end (sim_mob::Point2D end)
  {
	  std::cout << "in RoadItem_t_pimpl::end\n";
  }

  sim_mob::RoadItem* RoadItem_t_pimpl::
  post_RoadItem_t ()
  {
	  std::cout << "in RoadItem_t_pimpl::post_RoadItem_t\n";
    // TODO
    //
    // return ... ;
  }

  // BusStop_t_pimpl
  //

  void BusStop_t_pimpl::
  pre ()
  {
	    std::cout << "in BusStop_t_pimpl::pre ()\n";
  }

  void BusStop_t_pimpl::
  busStopID (const ::std::string& busStopID)
  {
    std::cout << "busStopID: " << busStopID << std::endl;
  }

  void BusStop_t_pimpl::
  lane_location (const ::std::string& lane_location)
  {
    std::cout << "lane_location: " << lane_location << std::endl;
  }

  void BusStop_t_pimpl::
  is_Terminal (bool is_Terminal)
  {
    std::cout << "is_Terminal: " << is_Terminal << std::endl;
  }

  void BusStop_t_pimpl::
  is_Bay (bool is_Bay)
  {
    std::cout << "is_Bay: " << is_Bay << std::endl;
  }

  void BusStop_t_pimpl::
  has_shelter (bool has_shelter)
  {
    std::cout << "has_shelter: " << has_shelter << std::endl;
  }

  void BusStop_t_pimpl::
  busCapacityAsLength (unsigned int busCapacityAsLength)
  {
    std::cout << "busCapacityAsLength: " << busCapacityAsLength << std::endl;
  }

  void BusStop_t_pimpl::
  post_BusStop_t ()
  {
    sim_mob::RoadItem* v (post_RoadItem_t ());

    // TODO
    //
  }

  // ERP_Gantry_t_pimpl
  //

  void ERP_Gantry_t_pimpl::
  pre ()
  {
  }

  void ERP_Gantry_t_pimpl::
  ERP_GantryID (const ::std::string& ERP_GantryID)
  {
    std::cout << "ERP_GantryID: " << ERP_GantryID << std::endl;
  }

  void ERP_Gantry_t_pimpl::
  post_ERP_Gantry_t ()
  {
    sim_mob::RoadItem* v (post_RoadItem_t ());

    // TODO
    //
  }

  // FormType_pimpl
  //

  void FormType_pimpl::
  pre ()
  {
  }

  void FormType_pimpl::
  TextBox (int TextBox)
  {
    std::cout << "TextBox: " << TextBox << std::endl;
  }

  void FormType_pimpl::
  TextArea (int TextArea)
  {
    std::cout << "TextArea: " << TextArea << std::endl;
  }

  void FormType_pimpl::
  Header (int Header)
  {
    std::cout << "Header: " << Header << std::endl;
  }

  void FormType_pimpl::
  post_FormType ()
  {
  }

  // PointPair_t_pimpl
  //

  void PointPair_t_pimpl::
  pre ()
  {
  }

  void PointPair_t_pimpl::
  first (sim_mob::Point2D first)
  {
	  pointPair.first = first;
  }

  void PointPair_t_pimpl::
  second (sim_mob::Point2D second)
  {
	  pointPair.second = second;
  }

  std::pair<sim_mob::Point2D,sim_mob::Point2D> PointPair_t_pimpl::
  post_PointPair_t ()
  {
	  return pointPair;
  }

  // crossing_t_pimpl
  //

  void crossing_t_pimpl::
  pre ()
  {

	  std::cout << "in crossing_t_pimpl::pre () " << std::endl;
	  crossing = new sim_mob::Crossing();
  }

  void crossing_t_pimpl::
  crossingID (const ::std::string& crossingID)
  {
	  std::cout << "in crossing_t_pimpl::crossingID: " << crossingID << std::endl;
    this->crossing->crossingID = atoi(crossingID.c_str());
  }

  void crossing_t_pimpl::
  nearLine (std::pair<sim_mob::Point2D,sim_mob::Point2D> nearLine)
  {
	  crossing->nearLine.first = nearLine.first;
  }

  void crossing_t_pimpl::
  farLine (std::pair<sim_mob::Point2D,sim_mob::Point2D> farLine)
  {
	  crossing->farLine.second = farLine.second;
  }

  sim_mob::Crossing* crossing_t_pimpl::
  post_crossing_t ()
  {
	  std::cout << "in crossing_t_pimpl::post_crossing_t () " << std::endl;
    sim_mob::RoadItem* v (post_RoadItem_t ());
    std::cout << "in crossing_t_pimpl::post_crossing_t Again() " << std::endl;
    return crossing;
  }

  // RoadBump_t_pimpl
  //

  void RoadBump_t_pimpl::
  pre ()
  {
  }

  void RoadBump_t_pimpl::
  roadBumpID (const ::std::string& roadBumpID)
  {
    std::cout << "roadBumpID: " << roadBumpID << std::endl;
  }

  void RoadBump_t_pimpl::
  segmentID (const ::std::string& segmentID)
  {
    std::cout << "segmentID: " << segmentID << std::endl;
  }

  void RoadBump_t_pimpl::
  post_RoadBump_t ()
  {
    sim_mob::RoadItem* v (post_RoadItem_t ());

    // TODO
    //
  }

  // RoadNetwork_t_pimpl
  //

  void RoadNetwork_t_pimpl::
  pre ()
  {
	  rn = sim_mob::ConfigParams::GetInstance().getNetworkRW();
	  std::cout << "In RoadNetwork_t_pimpl::pre\n";
  }

  void RoadNetwork_t_pimpl::
  Nodes ()
  {
  }

  void RoadNetwork_t_pimpl::
  Links (std::vector<sim_mob::Link*> Links)
  {
	  rn.links = Links;
	  std::cout << "Links Done	\n";
  }

  void RoadNetwork_t_pimpl::
  post_RoadNetwork_t ()
  {
  }

  // RoadItems_t_pimpl
  //

  void RoadItems_t_pimpl::
  pre ()
  {
	  std::cout << "in RoadItems_t_pimpl::pre () " << std::endl;
  }

  void RoadItems_t_pimpl::
  BusStop ()
  {
  }

  void RoadItems_t_pimpl::
  ERP_Gantry ()
  {
  }

  void RoadItems_t_pimpl::
  Crossing (sim_mob::Crossing* Crossing)
  {
	  std::cout << "in RoadItems_t_pimpl::Crossing () " << std::endl;
  }

  void RoadItems_t_pimpl::
  RoadBump ()
  {
  }

  std::map<centimeter_t,const RoadItem*> RoadItems_t_pimpl::
  post_RoadItems_t ()
  {
	  return RoadItems;
	  std::cout << "in RoadItems_t_pimpl::post_RoadItems_t () " << std::endl;
  }

  // GeoSpatial_t_pimpl
  //

  void GeoSpatial_t_pimpl::
  pre ()
  {
	  std::cout << "In GeoSpatial_t_pimpl.pre\n";
  }

  void GeoSpatial_t_pimpl::
  RoadNetwork ()
  {
//	  Now Take care of items like lane 'connectors' , 'road segments at' multinodes etc
	  std::pair<std::multimap<unsigned int,std::string>::iterator, std::multimap<unsigned int,std::string>::iterator> ppp;

	  //multinodes
	  std::vector<sim_mob::MultiNode*>& mNodes = ConfigParams::GetInstance().getNetworkRW().getNodesRW();
	  for(std::vector<sim_mob::MultiNode*>::iterator node_it = mNodes.begin(); node_it != mNodes.end(); node_it ++)
	  {
		  ppp = geo_RoadSegmentsAt.equal_range((*node_it)->getID());
		  for(std::multimap<unsigned int,std::string>::iterator rs_it = ppp.first ; rs_it != ppp.second ; ++ rs_it)
		  {
			  //RoadSegmetsAt
			  (*node_it)->roadSegmentsAt.insert(geo_Segments_[rs_it->second]);

		  }
	  }
	  //multi node connectors
	  for(std::vector<sim_mob::MultiNode*>::iterator node_it = mNodes.begin(); node_it != mNodes.end(); node_it ++)
	  {
		  geo_MultiNode_Connectors_type & geo_MultiNode_Connectors_ = geo_MultiNodeConnectorsMap[(*node_it)->getID()];
		  for(geo_MultiNode_Connectors_type::iterator rs_cnn_it = geo_MultiNode_Connectors_.begin(); rs_cnn_it != geo_MultiNode_Connectors_.end(); rs_cnn_it++)
		  {
			  std::set<sim_mob::LaneConnector*> connectors;
			  geo_UniNode_Connectors_type & geo_UniNode_Connectors_ = rs_cnn_it->second; //we don't have uninode here. it is just a name paw
			  geo_UniNode_Connectors_type::iterator lane_cnn_it;
			  for(lane_cnn_it = geo_UniNode_Connectors_.begin(); lane_cnn_it != geo_UniNode_Connectors_.end(); lane_cnn_it++)
			  {
				  sim_mob::LaneConnector* lc = new sim_mob::LaneConnector();
				  lc->laneFrom = geo_Lanes_[(*lane_cnn_it).first];
				  lc->laneTo = geo_Lanes_[(*lane_cnn_it).second];
				  connectors.insert(lc);
			  }
			  sim_mob::RoadSegment * rs = geo_Segments_[rs_cnn_it->first];
			  (*node_it)->connectors[rs] = connectors;
		  }
	  }
	  //uni node connectors
	  std::set<sim_mob::UniNode*>& uNodes = ConfigParams::GetInstance().getNetworkRW().getUniNodesRW();
	  for(std::set<sim_mob::UniNode*>::iterator node_it = uNodes.begin(); node_it != uNodes.end(); node_it ++)
	  {
		  geo_UniNode_Connectors_type geo_UniNode_Connectors_ = geo_UniNodeConnectorsMap[(*node_it)->getID()];
		  std::map<const sim_mob::Lane*, sim_mob::Lane*> & connectors = (*node_it)->connectors;
		  for(geo_UniNode_Connectors_type::iterator  lane_cnn_it = geo_UniNode_Connectors_.begin(); lane_cnn_it != geo_UniNode_Connectors_.end(); lane_cnn_it++)
			  connectors[geo_Lanes_[(*lane_cnn_it).first]] = geo_Lanes_[(*lane_cnn_it).second];
	  }
	  std::cout << "In GeoSpatial_t_pimpl.RoadNetwork()...Done\n";
  }

  void GeoSpatial_t_pimpl::
  post_GeoSpatial_t ()
  {

  }

  // SimMobility_t_pimpl
  //

  void SimMobility_t_pimpl::
  pre ()
  {
	  std::cout << "In SimMobility_t_pimpl.pre()\n";
  }

  void SimMobility_t_pimpl::
  GeoSpatial ()
  {
	  std::cout << "In SimMobility_t_pimpl::GeoSpatial ()\n";
  }

  void SimMobility_t_pimpl::
  post_SimMobility_t ()
  {
  }

  // Lanes_pimpl
  //

  void Lanes_pimpl::
  pre ()
  {
  }

  void Lanes_pimpl::
  Lane (sim_mob::Lane* Lane)
  {
	  this->lanes.push_back(Lane);
  }

  std::vector<sim_mob::Lane*> Lanes_pimpl::
  post_Lanes ()
  {
//	  std::cout<< "Returning Lanes\n";
	  return this->lanes;
  }

  // Segments_pimpl
  //

  void Segments_pimpl::
  pre ()
  {
  }

  void Segments_pimpl::
  FWDSegments (std::vector<sim_mob::RoadSegment*> FWDSegments)
  {
	  fwd = FWDSegments;
  }

  void Segments_pimpl::
  BKDSegments (std::vector<sim_mob::RoadSegment*> BKDSegments)
  {
	  bck = BKDSegments;
  }

  std::pair<std::vector<sim_mob::RoadSegment*>,std::vector<sim_mob::RoadSegment*> > Segments_pimpl::
  post_Segments ()
  {
	  return (std::make_pair(fwd,bck));
  }

  // Nodes_pimpl
  //

  void Nodes_pimpl::
  pre ()
  {
  }

  void Nodes_pimpl::
  UniNodes (std::set<sim_mob::UniNode*>& UniNodes)
  {
	  rn.segmentnodes = UniNodes;
    // TODO
    //
  }

  void Nodes_pimpl::
  Intersections (std::vector<sim_mob::MultiNode*>& Intersections)
  {

	  rn.nodes.insert(rn.nodes.begin(),Intersections.begin(),Intersections.end());
	  std::cout<< "Intersections inserted\n";
    // TODO
    //
  }

  void Nodes_pimpl::
  roundabouts (std::vector<sim_mob::MultiNode*>& roundabouts)
  {
	  std::cout<< "roundabouts inserting size " << roundabouts.size() << std::endl;
	  if((roundabouts.begin() != roundabouts.end())&& roundabouts.size() > 0 )
		  rn.nodes.insert(rn.nodes.end(),roundabouts.begin(),roundabouts.end());
	  std::cout<< "roundabouts inserted\n";
    // TODO
    //
  }

  void Nodes_pimpl::
  post_Nodes ()
  {
	  std::cout<< "post_Nodes called\n";
  }

  // Links_pimpl
  //

  void Links_pimpl::
  pre ()
  {
  }

  void Links_pimpl::
  Link (sim_mob::Link* Link)
  {
	  links.push_back(Link);
	  std::cout << "Link Pushed\n";
  }

  std::vector<sim_mob::Link*> Links_pimpl::
  post_Links ()
  {
	  return links;
  }

  // UniNodes_pimpl
  //

  void UniNodes_pimpl::
  pre ()
  {
	  std::cout << "UniNodes_pimpl::pre()\n";
  }

  void UniNodes_pimpl::
  UniNode (sim_mob::UniNode* UniNode)
  {
	  uniNodes.insert(UniNode);
  }

  std::set<sim_mob::UniNode*>& UniNodes_pimpl::
  post_UniNodes ()
  {
	  std::cout << "UniNodes_pimpl::post_UniNodes()\n";
	  return uniNodes;
  }

  // Intersections_pimpl
  //

  void Intersections_pimpl::
  pre ()
  {
	  std::cout << "Intersections_pimpl::pre()\n";
  }

  void Intersections_pimpl::
  Intersection (sim_mob::MultiNode* Intersection)
  {
	  intersections.push_back(Intersection);
  }

  std::vector<sim_mob::MultiNode*>& Intersections_pimpl::
  post_Intersections ()
  {
	  return intersections;
  }

  // roundabouts_pimpl
  //

  void roundabouts_pimpl::
  pre ()
  {
  }

  void roundabouts_pimpl::
  roundabout (sim_mob::MultiNode* roundabout)
  {
	  roundabouts.push_back(roundabout);
    // TODO
    //
  }

  std::vector<sim_mob::MultiNode*>& roundabouts_pimpl::
  post_roundabouts ()
  {
	  return roundabouts;
  }
}

