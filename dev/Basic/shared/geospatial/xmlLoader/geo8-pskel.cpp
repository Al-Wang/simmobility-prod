// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "geo8-pskel.hpp"

namespace geo
{
  // Point2D_t_pskel
  //

  void Point2D_t_pskel::
  xPos_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->xPos_parser_ = &p;
  }

  void Point2D_t_pskel::
  yPos_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->yPos_parser_ = &p;
  }

  void Point2D_t_pskel::
  parsers (::xml_schema::unsigned_int_pskel& xPos,
           ::xml_schema::unsigned_int_pskel& yPos)
  {
    this->xPos_parser_ = &xPos;
    this->yPos_parser_ = &yPos;
  }

  Point2D_t_pskel::
  Point2D_t_pskel ()
  : xPos_parser_ (0),
    yPos_parser_ (0)
  {
  }

  // PolyPoint_t_pskel
  //

  void PolyPoint_t_pskel::
  pointID_parser (::xml_schema::string_pskel& p)
  {
    this->pointID_parser_ = &p;
  }

  void PolyPoint_t_pskel::
  location_parser (::geo::Point2D_t_pskel& p)
  {
    this->location_parser_ = &p;
  }

  void PolyPoint_t_pskel::
  parsers (::xml_schema::string_pskel& pointID,
           ::geo::Point2D_t_pskel& location)
  {
    this->pointID_parser_ = &pointID;
    this->location_parser_ = &location;
  }

  PolyPoint_t_pskel::
  PolyPoint_t_pskel ()
  : pointID_parser_ (0),
    location_parser_ (0)
  {
  }

  // PolyLine_t_pskel
  //

  void PolyLine_t_pskel::
  PolyPoint_parser (::geo::PolyPoint_t_pskel& p)
  {
    this->PolyPoint_parser_ = &p;
  }

  void PolyLine_t_pskel::
  parsers (::geo::PolyPoint_t_pskel& PolyPoint)
  {
    this->PolyPoint_parser_ = &PolyPoint;
  }

  PolyLine_t_pskel::
  PolyLine_t_pskel ()
  : PolyPoint_parser_ (0)
  {
  }

  // lane_t_pskel
  //

  void lane_t_pskel::
  laneID_parser (::xml_schema::string_pskel& p)
  {
    this->laneID_parser_ = &p;
  }

  void lane_t_pskel::
  width_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->width_parser_ = &p;
  }

  void lane_t_pskel::
  can_go_straight_parser (::xml_schema::boolean_pskel& p)
  {
    this->can_go_straight_parser_ = &p;
  }

  void lane_t_pskel::
  can_turn_left_parser (::xml_schema::boolean_pskel& p)
  {
    this->can_turn_left_parser_ = &p;
  }

  void lane_t_pskel::
  can_turn_right_parser (::xml_schema::boolean_pskel& p)
  {
    this->can_turn_right_parser_ = &p;
  }

  void lane_t_pskel::
  can_turn_on_red_signal_parser (::xml_schema::boolean_pskel& p)
  {
    this->can_turn_on_red_signal_parser_ = &p;
  }

  void lane_t_pskel::
  can_change_lane_left_parser (::xml_schema::boolean_pskel& p)
  {
    this->can_change_lane_left_parser_ = &p;
  }

  void lane_t_pskel::
  can_change_lane_right_parser (::xml_schema::boolean_pskel& p)
  {
    this->can_change_lane_right_parser_ = &p;
  }

  void lane_t_pskel::
  is_road_shoulder_parser (::xml_schema::boolean_pskel& p)
  {
    this->is_road_shoulder_parser_ = &p;
  }

  void lane_t_pskel::
  is_bicycle_lane_parser (::xml_schema::boolean_pskel& p)
  {
    this->is_bicycle_lane_parser_ = &p;
  }

  void lane_t_pskel::
  is_pedestrian_lane_parser (::xml_schema::boolean_pskel& p)
  {
    this->is_pedestrian_lane_parser_ = &p;
  }

  void lane_t_pskel::
  is_vehicle_lane_parser (::xml_schema::boolean_pskel& p)
  {
    this->is_vehicle_lane_parser_ = &p;
  }

  void lane_t_pskel::
  is_standard_bus_lane_parser (::xml_schema::boolean_pskel& p)
  {
    this->is_standard_bus_lane_parser_ = &p;
  }

  void lane_t_pskel::
  is_whole_day_bus_lane_parser (::xml_schema::boolean_pskel& p)
  {
    this->is_whole_day_bus_lane_parser_ = &p;
  }

  void lane_t_pskel::
  is_high_occupancy_vehicle_lane_parser (::xml_schema::boolean_pskel& p)
  {
    this->is_high_occupancy_vehicle_lane_parser_ = &p;
  }

  void lane_t_pskel::
  can_freely_park_here_parser (::xml_schema::boolean_pskel& p)
  {
    this->can_freely_park_here_parser_ = &p;
  }

  void lane_t_pskel::
  can_stop_here_parser (::xml_schema::boolean_pskel& p)
  {
    this->can_stop_here_parser_ = &p;
  }

  void lane_t_pskel::
  is_u_turn_allowed_parser (::xml_schema::boolean_pskel& p)
  {
    this->is_u_turn_allowed_parser_ = &p;
  }

  void lane_t_pskel::
  PolyLine_parser (::geo::PolyLine_t_pskel& p)
  {
    this->PolyLine_parser_ = &p;
  }

  void lane_t_pskel::
  parsers (::xml_schema::string_pskel& laneID,
           ::xml_schema::unsigned_int_pskel& width,
           ::xml_schema::boolean_pskel& can_go_straight,
           ::xml_schema::boolean_pskel& can_turn_left,
           ::xml_schema::boolean_pskel& can_turn_right,
           ::xml_schema::boolean_pskel& can_turn_on_red_signal,
           ::xml_schema::boolean_pskel& can_change_lane_left,
           ::xml_schema::boolean_pskel& can_change_lane_right,
           ::xml_schema::boolean_pskel& is_road_shoulder,
           ::xml_schema::boolean_pskel& is_bicycle_lane,
           ::xml_schema::boolean_pskel& is_pedestrian_lane,
           ::xml_schema::boolean_pskel& is_vehicle_lane,
           ::xml_schema::boolean_pskel& is_standard_bus_lane,
           ::xml_schema::boolean_pskel& is_whole_day_bus_lane,
           ::xml_schema::boolean_pskel& is_high_occupancy_vehicle_lane,
           ::xml_schema::boolean_pskel& can_freely_park_here,
           ::xml_schema::boolean_pskel& can_stop_here,
           ::xml_schema::boolean_pskel& is_u_turn_allowed,
           ::geo::PolyLine_t_pskel& PolyLine)
  {
    this->laneID_parser_ = &laneID;
    this->width_parser_ = &width;
    this->can_go_straight_parser_ = &can_go_straight;
    this->can_turn_left_parser_ = &can_turn_left;
    this->can_turn_right_parser_ = &can_turn_right;
    this->can_turn_on_red_signal_parser_ = &can_turn_on_red_signal;
    this->can_change_lane_left_parser_ = &can_change_lane_left;
    this->can_change_lane_right_parser_ = &can_change_lane_right;
    this->is_road_shoulder_parser_ = &is_road_shoulder;
    this->is_bicycle_lane_parser_ = &is_bicycle_lane;
    this->is_pedestrian_lane_parser_ = &is_pedestrian_lane;
    this->is_vehicle_lane_parser_ = &is_vehicle_lane;
    this->is_standard_bus_lane_parser_ = &is_standard_bus_lane;
    this->is_whole_day_bus_lane_parser_ = &is_whole_day_bus_lane;
    this->is_high_occupancy_vehicle_lane_parser_ = &is_high_occupancy_vehicle_lane;
    this->can_freely_park_here_parser_ = &can_freely_park_here;
    this->can_stop_here_parser_ = &can_stop_here;
    this->is_u_turn_allowed_parser_ = &is_u_turn_allowed;
    this->PolyLine_parser_ = &PolyLine;
  }

  lane_t_pskel::
  lane_t_pskel ()
  : laneID_parser_ (0),
    width_parser_ (0),
    can_go_straight_parser_ (0),
    can_turn_left_parser_ (0),
    can_turn_right_parser_ (0),
    can_turn_on_red_signal_parser_ (0),
    can_change_lane_left_parser_ (0),
    can_change_lane_right_parser_ (0),
    is_road_shoulder_parser_ (0),
    is_bicycle_lane_parser_ (0),
    is_pedestrian_lane_parser_ (0),
    is_vehicle_lane_parser_ (0),
    is_standard_bus_lane_parser_ (0),
    is_whole_day_bus_lane_parser_ (0),
    is_high_occupancy_vehicle_lane_parser_ (0),
    can_freely_park_here_parser_ (0),
    can_stop_here_parser_ (0),
    is_u_turn_allowed_parser_ (0),
    PolyLine_parser_ (0)
  {
  }

  // connector_t_pskel
  //

  void connector_t_pskel::
  laneFrom_parser (::xml_schema::string_pskel& p)
  {
    this->laneFrom_parser_ = &p;
  }

  void connector_t_pskel::
  laneTo_parser (::xml_schema::string_pskel& p)
  {
    this->laneTo_parser_ = &p;
  }

  void connector_t_pskel::
  parsers (::xml_schema::string_pskel& laneFrom,
           ::xml_schema::string_pskel& laneTo)
  {
    this->laneFrom_parser_ = &laneFrom;
    this->laneTo_parser_ = &laneTo;
  }

  connector_t_pskel::
  connector_t_pskel ()
  : laneFrom_parser_ (0),
    laneTo_parser_ (0)
  {
  }

  // connectors_t_pskel
  //

  void connectors_t_pskel::
  Connector_parser (::geo::connector_t_pskel& p)
  {
    this->Connector_parser_ = &p;
  }

  void connectors_t_pskel::
  parsers (::geo::connector_t_pskel& Connector)
  {
    this->Connector_parser_ = &Connector;
  }

  connectors_t_pskel::
  connectors_t_pskel ()
  : Connector_parser_ (0)
  {
  }

  // Multi_Connector_t_pskel
  //

  void Multi_Connector_t_pskel::
  RoadSegment_parser (::xml_schema::string_pskel& p)
  {
    this->RoadSegment_parser_ = &p;
  }

  void Multi_Connector_t_pskel::
  Connectors_parser (::geo::connectors_t_pskel& p)
  {
    this->Connectors_parser_ = &p;
  }

  void Multi_Connector_t_pskel::
  parsers (::xml_schema::string_pskel& RoadSegment,
           ::geo::connectors_t_pskel& Connectors)
  {
    this->RoadSegment_parser_ = &RoadSegment;
    this->Connectors_parser_ = &Connectors;
  }

  Multi_Connector_t_pskel::
  Multi_Connector_t_pskel ()
  : RoadSegment_parser_ (0),
    Connectors_parser_ (0)
  {
  }

  // Multi_Connectors_t_pskel
  //

  void Multi_Connectors_t_pskel::
  MultiConnectors_parser (::geo::Multi_Connector_t_pskel& p)
  {
    this->MultiConnectors_parser_ = &p;
  }

  void Multi_Connectors_t_pskel::
  parsers (::geo::Multi_Connector_t_pskel& MultiConnectors)
  {
    this->MultiConnectors_parser_ = &MultiConnectors;
  }

  Multi_Connectors_t_pskel::
  Multi_Connectors_t_pskel ()
  : MultiConnectors_parser_ (0)
  {
  }

  // fwdBckSegments_t_pskel
  //

  void fwdBckSegments_t_pskel::
  Segment_parser (::geo::segment_t_pskel& p)
  {
    this->Segment_parser_ = &p;
  }

  void fwdBckSegments_t_pskel::
  parsers (::geo::segment_t_pskel& Segment)
  {
    this->Segment_parser_ = &Segment;
  }

  fwdBckSegments_t_pskel::
  fwdBckSegments_t_pskel ()
  : Segment_parser_ (0)
  {
  }

  // RoadSegmentsAt_t_pskel
  //

  void RoadSegmentsAt_t_pskel::
  segmentID_parser (::xml_schema::string_pskel& p)
  {
    this->segmentID_parser_ = &p;
  }

  void RoadSegmentsAt_t_pskel::
  parsers (::xml_schema::string_pskel& segmentID)
  {
    this->segmentID_parser_ = &segmentID;
  }

  RoadSegmentsAt_t_pskel::
  RoadSegmentsAt_t_pskel ()
  : segmentID_parser_ (0)
  {
  }

  // segment_t_pskel
  //

  void segment_t_pskel::
  segmentID_parser (::xml_schema::string_pskel& p)
  {
    this->segmentID_parser_ = &p;
  }

  void segment_t_pskel::
  startingNode_parser (::xml_schema::string_pskel& p)
  {
    this->startingNode_parser_ = &p;
  }

  void segment_t_pskel::
  endingNode_parser (::xml_schema::string_pskel& p)
  {
    this->endingNode_parser_ = &p;
  }

  void segment_t_pskel::
  maxSpeed_parser (::xml_schema::short_pskel& p)
  {
    this->maxSpeed_parser_ = &p;
  }

  void segment_t_pskel::
  Length_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->Length_parser_ = &p;
  }

  void segment_t_pskel::
  Width_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->Width_parser_ = &p;
  }

  void segment_t_pskel::
  Lanes_parser (::geo::Lanes_pskel& p)
  {
    this->Lanes_parser_ = &p;
  }

  void segment_t_pskel::
  Obstacles_parser (::geo::RoadItems_t_pskel& p)
  {
    this->Obstacles_parser_ = &p;
  }

  void segment_t_pskel::
  KurbLine_parser (::geo::PolyLine_t_pskel& p)
  {
    this->KurbLine_parser_ = &p;
  }

  void segment_t_pskel::
  parsers (::xml_schema::string_pskel& segmentID,
           ::xml_schema::string_pskel& startingNode,
           ::xml_schema::string_pskel& endingNode,
           ::xml_schema::short_pskel& maxSpeed,
           ::xml_schema::unsigned_int_pskel& Length,
           ::xml_schema::unsigned_int_pskel& Width,
           ::geo::Lanes_pskel& Lanes,
           ::geo::RoadItems_t_pskel& Obstacles,
           ::geo::PolyLine_t_pskel& KurbLine)
  {
    this->segmentID_parser_ = &segmentID;
    this->startingNode_parser_ = &startingNode;
    this->endingNode_parser_ = &endingNode;
    this->maxSpeed_parser_ = &maxSpeed;
    this->Length_parser_ = &Length;
    this->Width_parser_ = &Width;
    this->Lanes_parser_ = &Lanes;
    this->Obstacles_parser_ = &Obstacles;
    this->KurbLine_parser_ = &KurbLine;
  }

  segment_t_pskel::
  segment_t_pskel ()
  : segmentID_parser_ (0),
    startingNode_parser_ (0),
    endingNode_parser_ (0),
    maxSpeed_parser_ (0),
    Length_parser_ (0),
    Width_parser_ (0),
    Lanes_parser_ (0),
    Obstacles_parser_ (0),
    KurbLine_parser_ (0)
  {
  }

  // link_t_pskel
  //

  void link_t_pskel::
  linkID_parser (::xml_schema::string_pskel& p)
  {
    this->linkID_parser_ = &p;
  }

  void link_t_pskel::
  roadName_parser (::xml_schema::string_pskel& p)
  {
    this->roadName_parser_ = &p;
  }

  void link_t_pskel::
  StartingNode_parser (::xml_schema::string_pskel& p)
  {
    this->StartingNode_parser_ = &p;
  }

  void link_t_pskel::
  EndingNode_parser (::xml_schema::string_pskel& p)
  {
    this->EndingNode_parser_ = &p;
  }

  void link_t_pskel::
  Segments_parser (::geo::Segments_pskel& p)
  {
    this->Segments_parser_ = &p;
  }

  void link_t_pskel::
  parsers (::xml_schema::string_pskel& linkID,
           ::xml_schema::string_pskel& roadName,
           ::xml_schema::string_pskel& StartingNode,
           ::xml_schema::string_pskel& EndingNode,
           ::geo::Segments_pskel& Segments)
  {
    this->linkID_parser_ = &linkID;
    this->roadName_parser_ = &roadName;
    this->StartingNode_parser_ = &StartingNode;
    this->EndingNode_parser_ = &EndingNode;
    this->Segments_parser_ = &Segments;
  }

  link_t_pskel::
  link_t_pskel ()
  : linkID_parser_ (0),
    roadName_parser_ (0),
    StartingNode_parser_ (0),
    EndingNode_parser_ (0),
    Segments_parser_ (0)
  {
  }

  // separator_t_pskel
  //

  void separator_t_pskel::
  separator_ID_parser (::xml_schema::unsigned_short_pskel& p)
  {
    this->separator_ID_parser_ = &p;
  }

  void separator_t_pskel::
  separator_value_parser (::xml_schema::boolean_pskel& p)
  {
    this->separator_value_parser_ = &p;
  }

  void separator_t_pskel::
  parsers (::xml_schema::unsigned_short_pskel& separator_ID,
           ::xml_schema::boolean_pskel& separator_value)
  {
    this->separator_ID_parser_ = &separator_ID;
    this->separator_value_parser_ = &separator_value;
  }

  separator_t_pskel::
  separator_t_pskel ()
  : separator_ID_parser_ (0),
    separator_value_parser_ (0)
  {
  }

  // separators_t_pskel
  //

  void separators_t_pskel::
  Separator_parser (::geo::separator_t_pskel& p)
  {
    this->Separator_parser_ = &p;
  }

  void separators_t_pskel::
  parsers (::geo::separator_t_pskel& Separator)
  {
    this->Separator_parser_ = &Separator;
  }

  separators_t_pskel::
  separators_t_pskel ()
  : Separator_parser_ (0)
  {
  }

  // DomainIsland_t_pskel
  //

  void DomainIsland_t_pskel::
  domainIsland_ID_parser (::xml_schema::unsigned_short_pskel& p)
  {
    this->domainIsland_ID_parser_ = &p;
  }

  void DomainIsland_t_pskel::
  domainIsland_value_parser (::xml_schema::boolean_pskel& p)
  {
    this->domainIsland_value_parser_ = &p;
  }

  void DomainIsland_t_pskel::
  parsers (::xml_schema::unsigned_short_pskel& domainIsland_ID,
           ::xml_schema::boolean_pskel& domainIsland_value)
  {
    this->domainIsland_ID_parser_ = &domainIsland_ID;
    this->domainIsland_value_parser_ = &domainIsland_value;
  }

  DomainIsland_t_pskel::
  DomainIsland_t_pskel ()
  : domainIsland_ID_parser_ (0),
    domainIsland_value_parser_ (0)
  {
  }

  // DomainIslands_t_pskel
  //

  void DomainIslands_t_pskel::
  domainIslands_parser (::geo::DomainIsland_t_pskel& p)
  {
    this->domainIslands_parser_ = &p;
  }

  void DomainIslands_t_pskel::
  parsers (::geo::DomainIsland_t_pskel& domainIslands)
  {
    this->domainIslands_parser_ = &domainIslands;
  }

  DomainIslands_t_pskel::
  DomainIslands_t_pskel ()
  : domainIslands_parser_ (0)
  {
  }

  // offset_t_pskel
  //

  void offset_t_pskel::
  offset_ID_parser (::xml_schema::unsigned_short_pskel& p)
  {
    this->offset_ID_parser_ = &p;
  }

  void offset_t_pskel::
  offset_value_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->offset_value_parser_ = &p;
  }

  void offset_t_pskel::
  parsers (::xml_schema::unsigned_short_pskel& offset_ID,
           ::xml_schema::unsigned_int_pskel& offset_value)
  {
    this->offset_ID_parser_ = &offset_ID;
    this->offset_value_parser_ = &offset_value;
  }

  offset_t_pskel::
  offset_t_pskel ()
  : offset_ID_parser_ (0),
    offset_value_parser_ (0)
  {
  }

  // offsets_t_pskel
  //

  void offsets_t_pskel::
  offset_parser (::geo::offset_t_pskel& p)
  {
    this->offset_parser_ = &p;
  }

  void offsets_t_pskel::
  parsers (::geo::offset_t_pskel& offset)
  {
    this->offset_parser_ = &offset;
  }

  offsets_t_pskel::
  offsets_t_pskel ()
  : offset_parser_ (0)
  {
  }

  // ChunkLength_t_pskel
  //

  void ChunkLength_t_pskel::
  chunklength_ID_parser (::xml_schema::unsigned_short_pskel& p)
  {
    this->chunklength_ID_parser_ = &p;
  }

  void ChunkLength_t_pskel::
  chunklength_value_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->chunklength_value_parser_ = &p;
  }

  void ChunkLength_t_pskel::
  parsers (::xml_schema::unsigned_short_pskel& chunklength_ID,
           ::xml_schema::unsigned_int_pskel& chunklength_value)
  {
    this->chunklength_ID_parser_ = &chunklength_ID;
    this->chunklength_value_parser_ = &chunklength_value;
  }

  ChunkLength_t_pskel::
  ChunkLength_t_pskel ()
  : chunklength_ID_parser_ (0),
    chunklength_value_parser_ (0)
  {
  }

  // ChunkLengths_t_pskel
  //

  void ChunkLengths_t_pskel::
  chunklength_parser (::geo::ChunkLength_t_pskel& p)
  {
    this->chunklength_parser_ = &p;
  }

  void ChunkLengths_t_pskel::
  parsers (::geo::ChunkLength_t_pskel& chunklength)
  {
    this->chunklength_parser_ = &chunklength;
  }

  ChunkLengths_t_pskel::
  ChunkLengths_t_pskel ()
  : chunklength_parser_ (0)
  {
  }

  // LanesVector_t_pskel
  //

  void LanesVector_t_pskel::
  laneID_parser (::xml_schema::string_pskel& p)
  {
    this->laneID_parser_ = &p;
  }

  void LanesVector_t_pskel::
  parsers (::xml_schema::string_pskel& laneID)
  {
    this->laneID_parser_ = &laneID;
  }

  LanesVector_t_pskel::
  LanesVector_t_pskel ()
  : laneID_parser_ (0)
  {
  }

  // EntranceAngle_t_pskel
  //

  void EntranceAngle_t_pskel::
  entranceAngle_ID_parser (::xml_schema::unsigned_short_pskel& p)
  {
    this->entranceAngle_ID_parser_ = &p;
  }

  void EntranceAngle_t_pskel::
  entranceAngle_value_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->entranceAngle_value_parser_ = &p;
  }

  void EntranceAngle_t_pskel::
  parsers (::xml_schema::unsigned_short_pskel& entranceAngle_ID,
           ::xml_schema::unsigned_int_pskel& entranceAngle_value)
  {
    this->entranceAngle_ID_parser_ = &entranceAngle_ID;
    this->entranceAngle_value_parser_ = &entranceAngle_value;
  }

  EntranceAngle_t_pskel::
  EntranceAngle_t_pskel ()
  : entranceAngle_ID_parser_ (0),
    entranceAngle_value_parser_ (0)
  {
  }

  // EntranceAngles_t_pskel
  //

  void EntranceAngles_t_pskel::
  entranceAngle_parser (::geo::EntranceAngle_t_pskel& p)
  {
    this->entranceAngle_parser_ = &p;
  }

  void EntranceAngles_t_pskel::
  parsers (::geo::EntranceAngle_t_pskel& entranceAngle)
  {
    this->entranceAngle_parser_ = &entranceAngle;
  }

  EntranceAngles_t_pskel::
  EntranceAngles_t_pskel ()
  : entranceAngle_parser_ (0)
  {
  }

  // UniNode_t_pskel
  //

  void UniNode_t_pskel::
  nodeID_parser (::xml_schema::string_pskel& p)
  {
    this->nodeID_parser_ = &p;
  }

  void UniNode_t_pskel::
  location_parser (::geo::Point2D_t_pskel& p)
  {
    this->location_parser_ = &p;
  }

  void UniNode_t_pskel::
  Connectors_parser (::geo::connectors_t_pskel& p)
  {
    this->Connectors_parser_ = &p;
  }

  void UniNode_t_pskel::
  parsers (::xml_schema::string_pskel& nodeID,
           ::geo::Point2D_t_pskel& location,
           ::geo::connectors_t_pskel& Connectors)
  {
    this->nodeID_parser_ = &nodeID;
    this->location_parser_ = &location;
    this->Connectors_parser_ = &Connectors;
  }

  UniNode_t_pskel::
  UniNode_t_pskel ()
  : nodeID_parser_ (0),
    location_parser_ (0),
    Connectors_parser_ (0)
  {
  }

  // roundabout_t_pskel
  //

  void roundabout_t_pskel::
  nodeID_parser (::xml_schema::string_pskel& p)
  {
    this->nodeID_parser_ = &p;
  }

  void roundabout_t_pskel::
  location_parser (::geo::Point2D_t_pskel& p)
  {
    this->location_parser_ = &p;
  }

  void roundabout_t_pskel::
  roadSegmentsAt_parser (::geo::RoadSegmentsAt_t_pskel& p)
  {
    this->roadSegmentsAt_parser_ = &p;
  }

  void roundabout_t_pskel::
  Connectors_parser (::geo::Multi_Connectors_t_pskel& p)
  {
    this->Connectors_parser_ = &p;
  }

  void roundabout_t_pskel::
  ChunkLengths_parser (::geo::ChunkLengths_t_pskel& p)
  {
    this->ChunkLengths_parser_ = &p;
  }

  void roundabout_t_pskel::
  Offsets_parser (::geo::offsets_t_pskel& p)
  {
    this->Offsets_parser_ = &p;
  }

  void roundabout_t_pskel::
  Separators_parser (::geo::separators_t_pskel& p)
  {
    this->Separators_parser_ = &p;
  }

  void roundabout_t_pskel::
  addDominantLane_parser (::geo::LanesVector_t_pskel& p)
  {
    this->addDominantLane_parser_ = &p;
  }

  void roundabout_t_pskel::
  roundaboutDominantIslands_parser (::xml_schema::float_pskel& p)
  {
    this->roundaboutDominantIslands_parser_ = &p;
  }

  void roundabout_t_pskel::
  roundaboutNumberOfLanes_parser (::xml_schema::int_pskel& p)
  {
    this->roundaboutNumberOfLanes_parser_ = &p;
  }

  void roundabout_t_pskel::
  entranceAngles_parser (::geo::EntranceAngles_t_pskel& p)
  {
    this->entranceAngles_parser_ = &p;
  }

  void roundabout_t_pskel::
  parsers (::xml_schema::string_pskel& nodeID,
           ::geo::Point2D_t_pskel& location,
           ::geo::RoadSegmentsAt_t_pskel& roadSegmentsAt,
           ::geo::Multi_Connectors_t_pskel& Connectors,
           ::geo::ChunkLengths_t_pskel& ChunkLengths,
           ::geo::offsets_t_pskel& Offsets,
           ::geo::separators_t_pskel& Separators,
           ::geo::LanesVector_t_pskel& addDominantLane,
           ::xml_schema::float_pskel& roundaboutDominantIslands,
           ::xml_schema::int_pskel& roundaboutNumberOfLanes,
           ::geo::EntranceAngles_t_pskel& entranceAngles)
  {
    this->nodeID_parser_ = &nodeID;
    this->location_parser_ = &location;
    this->roadSegmentsAt_parser_ = &roadSegmentsAt;
    this->Connectors_parser_ = &Connectors;
    this->ChunkLengths_parser_ = &ChunkLengths;
    this->Offsets_parser_ = &Offsets;
    this->Separators_parser_ = &Separators;
    this->addDominantLane_parser_ = &addDominantLane;
    this->roundaboutDominantIslands_parser_ = &roundaboutDominantIslands;
    this->roundaboutNumberOfLanes_parser_ = &roundaboutNumberOfLanes;
    this->entranceAngles_parser_ = &entranceAngles;
  }

  roundabout_t_pskel::
  roundabout_t_pskel ()
  : nodeID_parser_ (0),
    location_parser_ (0),
    roadSegmentsAt_parser_ (0),
    Connectors_parser_ (0),
    ChunkLengths_parser_ (0),
    Offsets_parser_ (0),
    Separators_parser_ (0),
    addDominantLane_parser_ (0),
    roundaboutDominantIslands_parser_ (0),
    roundaboutNumberOfLanes_parser_ (0),
    entranceAngles_parser_ (0)
  {
  }

  // intersection_t_pskel
  //

  void intersection_t_pskel::
  nodeID_parser (::xml_schema::string_pskel& p)
  {
    this->nodeID_parser_ = &p;
  }

  void intersection_t_pskel::
  location_parser (::geo::Point2D_t_pskel& p)
  {
    this->location_parser_ = &p;
  }

  void intersection_t_pskel::
  roadSegmentsAt_parser (::geo::RoadSegmentsAt_t_pskel& p)
  {
    this->roadSegmentsAt_parser_ = &p;
  }

  void intersection_t_pskel::
  Connectors_parser (::geo::Multi_Connectors_t_pskel& p)
  {
    this->Connectors_parser_ = &p;
  }

  void intersection_t_pskel::
  ChunkLengths_parser (::geo::ChunkLengths_t_pskel& p)
  {
    this->ChunkLengths_parser_ = &p;
  }

  void intersection_t_pskel::
  Offsets_parser (::geo::offsets_t_pskel& p)
  {
    this->Offsets_parser_ = &p;
  }

  void intersection_t_pskel::
  Separators_parser (::geo::separators_t_pskel& p)
  {
    this->Separators_parser_ = &p;
  }

  void intersection_t_pskel::
  additionalDominantLanes_parser (::geo::LanesVector_t_pskel& p)
  {
    this->additionalDominantLanes_parser_ = &p;
  }

  void intersection_t_pskel::
  additionalSubdominantLanes_parser (::geo::LanesVector_t_pskel& p)
  {
    this->additionalSubdominantLanes_parser_ = &p;
  }

  void intersection_t_pskel::
  domainIslands_parser (::geo::DomainIslands_t_pskel& p)
  {
    this->domainIslands_parser_ = &p;
  }

  void intersection_t_pskel::
  parsers (::xml_schema::string_pskel& nodeID,
           ::geo::Point2D_t_pskel& location,
           ::geo::RoadSegmentsAt_t_pskel& roadSegmentsAt,
           ::geo::Multi_Connectors_t_pskel& Connectors,
           ::geo::ChunkLengths_t_pskel& ChunkLengths,
           ::geo::offsets_t_pskel& Offsets,
           ::geo::separators_t_pskel& Separators,
           ::geo::LanesVector_t_pskel& additionalDominantLanes,
           ::geo::LanesVector_t_pskel& additionalSubdominantLanes,
           ::geo::DomainIslands_t_pskel& domainIslands)
  {
    this->nodeID_parser_ = &nodeID;
    this->location_parser_ = &location;
    this->roadSegmentsAt_parser_ = &roadSegmentsAt;
    this->Connectors_parser_ = &Connectors;
    this->ChunkLengths_parser_ = &ChunkLengths;
    this->Offsets_parser_ = &Offsets;
    this->Separators_parser_ = &Separators;
    this->additionalDominantLanes_parser_ = &additionalDominantLanes;
    this->additionalSubdominantLanes_parser_ = &additionalSubdominantLanes;
    this->domainIslands_parser_ = &domainIslands;
  }

  intersection_t_pskel::
  intersection_t_pskel ()
  : nodeID_parser_ (0),
    location_parser_ (0),
    roadSegmentsAt_parser_ (0),
    Connectors_parser_ (0),
    ChunkLengths_parser_ (0),
    Offsets_parser_ (0),
    Separators_parser_ (0),
    additionalDominantLanes_parser_ (0),
    additionalSubdominantLanes_parser_ (0),
    domainIslands_parser_ (0)
  {
  }

  // RoadItem_No_Attr_t_pskel
  //

  void RoadItem_No_Attr_t_pskel::
  start_parser (::geo::Point2D_t_pskel& p)
  {
    this->start_parser_ = &p;
  }

  void RoadItem_No_Attr_t_pskel::
  end_parser (::geo::Point2D_t_pskel& p)
  {
    this->end_parser_ = &p;
  }

  void RoadItem_No_Attr_t_pskel::
  parsers (::geo::Point2D_t_pskel& start,
           ::geo::Point2D_t_pskel& end)
  {
    this->start_parser_ = &start;
    this->end_parser_ = &end;
  }

  RoadItem_No_Attr_t_pskel::
  RoadItem_No_Attr_t_pskel ()
  : start_parser_ (0),
    end_parser_ (0)
  {
  }

  // RoadItem_t_pskel
  //

  void RoadItem_t_pskel::
  Offset_parser (::xml_schema::unsigned_short_pskel& p)
  {
    this->Offset_parser_ = &p;
  }

  void RoadItem_t_pskel::
  start_parser (::geo::Point2D_t_pskel& p)
  {
    this->start_parser_ = &p;
  }

  void RoadItem_t_pskel::
  end_parser (::geo::Point2D_t_pskel& p)
  {
    this->end_parser_ = &p;
  }

  void RoadItem_t_pskel::
  parsers (::xml_schema::unsigned_short_pskel& Offset,
           ::geo::Point2D_t_pskel& start,
           ::geo::Point2D_t_pskel& end)
  {
    this->Offset_parser_ = &Offset;
    this->start_parser_ = &start;
    this->end_parser_ = &end;
  }

  RoadItem_t_pskel::
  RoadItem_t_pskel ()
  : Offset_parser_ (0),
    start_parser_ (0),
    end_parser_ (0)
  {
  }

  // BusStop_t_pskel
  //

  void BusStop_t_pskel::
  busStopID_parser (::xml_schema::string_pskel& p)
  {
    this->busStopID_parser_ = &p;
  }

  void BusStop_t_pskel::
  lane_location_parser (::xml_schema::string_pskel& p)
  {
    this->lane_location_parser_ = &p;
  }

  void BusStop_t_pskel::
  is_Terminal_parser (::xml_schema::boolean_pskel& p)
  {
    this->is_Terminal_parser_ = &p;
  }

  void BusStop_t_pskel::
  is_Bay_parser (::xml_schema::boolean_pskel& p)
  {
    this->is_Bay_parser_ = &p;
  }

  void BusStop_t_pskel::
  has_shelter_parser (::xml_schema::boolean_pskel& p)
  {
    this->has_shelter_parser_ = &p;
  }

  void BusStop_t_pskel::
  busCapacityAsLength_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->busCapacityAsLength_parser_ = &p;
  }

  void BusStop_t_pskel::
  parsers (::xml_schema::unsigned_short_pskel& Offset,
           ::geo::Point2D_t_pskel& start,
           ::geo::Point2D_t_pskel& end,
           ::xml_schema::string_pskel& busStopID,
           ::xml_schema::string_pskel& lane_location,
           ::xml_schema::boolean_pskel& is_Terminal,
           ::xml_schema::boolean_pskel& is_Bay,
           ::xml_schema::boolean_pskel& has_shelter,
           ::xml_schema::unsigned_int_pskel& busCapacityAsLength)
  {
    this->Offset_parser_ = &Offset;
    this->start_parser_ = &start;
    this->end_parser_ = &end;
    this->busStopID_parser_ = &busStopID;
    this->lane_location_parser_ = &lane_location;
    this->is_Terminal_parser_ = &is_Terminal;
    this->is_Bay_parser_ = &is_Bay;
    this->has_shelter_parser_ = &has_shelter;
    this->busCapacityAsLength_parser_ = &busCapacityAsLength;
  }

  BusStop_t_pskel::
  BusStop_t_pskel ()
  : busStopID_parser_ (0),
    lane_location_parser_ (0),
    is_Terminal_parser_ (0),
    is_Bay_parser_ (0),
    has_shelter_parser_ (0),
    busCapacityAsLength_parser_ (0)
  {
  }

  // ERP_Gantry_t_pskel
  //

  void ERP_Gantry_t_pskel::
  ERP_GantryID_parser (::xml_schema::string_pskel& p)
  {
    this->ERP_GantryID_parser_ = &p;
  }

  void ERP_Gantry_t_pskel::
  parsers (::xml_schema::unsigned_short_pskel& Offset,
           ::geo::Point2D_t_pskel& start,
           ::geo::Point2D_t_pskel& end,
           ::xml_schema::string_pskel& ERP_GantryID)
  {
    this->Offset_parser_ = &Offset;
    this->start_parser_ = &start;
    this->end_parser_ = &end;
    this->ERP_GantryID_parser_ = &ERP_GantryID;
  }

  ERP_Gantry_t_pskel::
  ERP_Gantry_t_pskel ()
  : ERP_GantryID_parser_ (0)
  {
  }

  // FormType_pskel
  //

  void FormType_pskel::
  TextBox_parser (::xml_schema::int_pskel& p)
  {
    this->TextBox_parser_ = &p;
  }

  void FormType_pskel::
  TextArea_parser (::xml_schema::int_pskel& p)
  {
    this->TextArea_parser_ = &p;
  }

  void FormType_pskel::
  Header_parser (::xml_schema::int_pskel& p)
  {
    this->Header_parser_ = &p;
  }

  void FormType_pskel::
  parsers (::xml_schema::int_pskel& TextBox,
           ::xml_schema::int_pskel& TextArea,
           ::xml_schema::int_pskel& Header)
  {
    this->TextBox_parser_ = &TextBox;
    this->TextArea_parser_ = &TextArea;
    this->Header_parser_ = &Header;
  }

  FormType_pskel::
  FormType_pskel ()
  : TextBox_parser_ (0),
    TextArea_parser_ (0),
    Header_parser_ (0)
  {
  }

  // PointPair_t_pskel
  //

  void PointPair_t_pskel::
  first_parser (::geo::Point2D_t_pskel& p)
  {
    this->first_parser_ = &p;
  }

  void PointPair_t_pskel::
  second_parser (::geo::Point2D_t_pskel& p)
  {
    this->second_parser_ = &p;
  }

  void PointPair_t_pskel::
  parsers (::geo::Point2D_t_pskel& first,
           ::geo::Point2D_t_pskel& second)
  {
    this->first_parser_ = &first;
    this->second_parser_ = &second;
  }

  PointPair_t_pskel::
  PointPair_t_pskel ()
  : first_parser_ (0),
    second_parser_ (0)
  {
  }

  // crossing_t_pskel
  //

  void crossing_t_pskel::
  crossingID_parser (::xml_schema::string_pskel& p)
  {
    this->crossingID_parser_ = &p;
  }

  void crossing_t_pskel::
  nearLine_parser (::geo::PointPair_t_pskel& p)
  {
    this->nearLine_parser_ = &p;
  }

  void crossing_t_pskel::
  farLine_parser (::geo::PointPair_t_pskel& p)
  {
    this->farLine_parser_ = &p;
  }

  void crossing_t_pskel::
  parsers (::xml_schema::unsigned_short_pskel& Offset,
           ::geo::Point2D_t_pskel& start,
           ::geo::Point2D_t_pskel& end,
           ::xml_schema::string_pskel& crossingID,
           ::geo::PointPair_t_pskel& nearLine,
           ::geo::PointPair_t_pskel& farLine)
  {
    this->Offset_parser_ = &Offset;
    this->start_parser_ = &start;
    this->end_parser_ = &end;
    this->crossingID_parser_ = &crossingID;
    this->nearLine_parser_ = &nearLine;
    this->farLine_parser_ = &farLine;
  }

  crossing_t_pskel::
  crossing_t_pskel ()
  : crossingID_parser_ (0),
    nearLine_parser_ (0),
    farLine_parser_ (0)
  {
  }

  // RoadBump_t_pskel
  //

  void RoadBump_t_pskel::
  roadBumpID_parser (::xml_schema::string_pskel& p)
  {
    this->roadBumpID_parser_ = &p;
  }

  void RoadBump_t_pskel::
  segmentID_parser (::xml_schema::string_pskel& p)
  {
    this->segmentID_parser_ = &p;
  }

  void RoadBump_t_pskel::
  parsers (::xml_schema::unsigned_short_pskel& Offset,
           ::geo::Point2D_t_pskel& start,
           ::geo::Point2D_t_pskel& end,
           ::xml_schema::string_pskel& roadBumpID,
           ::xml_schema::string_pskel& segmentID)
  {
    this->Offset_parser_ = &Offset;
    this->start_parser_ = &start;
    this->end_parser_ = &end;
    this->roadBumpID_parser_ = &roadBumpID;
    this->segmentID_parser_ = &segmentID;
  }

  RoadBump_t_pskel::
  RoadBump_t_pskel ()
  : roadBumpID_parser_ (0),
    segmentID_parser_ (0)
  {
  }

  // RoadNetwork_t_pskel
  //

  void RoadNetwork_t_pskel::
  Nodes_parser (::geo::Nodes_pskel& p)
  {
    this->Nodes_parser_ = &p;
  }

  void RoadNetwork_t_pskel::
  Links_parser (::geo::Links_pskel& p)
  {
    this->Links_parser_ = &p;
  }

  void RoadNetwork_t_pskel::
  parsers (::geo::Nodes_pskel& Nodes,
           ::geo::Links_pskel& Links)
  {
    this->Nodes_parser_ = &Nodes;
    this->Links_parser_ = &Links;
  }

  RoadNetwork_t_pskel::
  RoadNetwork_t_pskel ()
  : Nodes_parser_ (0),
    Links_parser_ (0)
  {
  }

  // RoadItems_t_pskel
  //

  void RoadItems_t_pskel::
  BusStop_parser (::geo::BusStop_t_pskel& p)
  {
    this->BusStop_parser_ = &p;
  }

  void RoadItems_t_pskel::
  ERP_Gantry_parser (::geo::ERP_Gantry_t_pskel& p)
  {
    this->ERP_Gantry_parser_ = &p;
  }

  void RoadItems_t_pskel::
  Crossing_parser (::geo::crossing_t_pskel& p)
  {
    this->Crossing_parser_ = &p;
  }

  void RoadItems_t_pskel::
  RoadBump_parser (::geo::RoadBump_t_pskel& p)
  {
    this->RoadBump_parser_ = &p;
  }

  void RoadItems_t_pskel::
  parsers (::geo::BusStop_t_pskel& BusStop,
           ::geo::ERP_Gantry_t_pskel& ERP_Gantry,
           ::geo::crossing_t_pskel& Crossing,
           ::geo::RoadBump_t_pskel& RoadBump)
  {
    this->BusStop_parser_ = &BusStop;
    this->ERP_Gantry_parser_ = &ERP_Gantry;
    this->Crossing_parser_ = &Crossing;
    this->RoadBump_parser_ = &RoadBump;
  }

  RoadItems_t_pskel::
  RoadItems_t_pskel ()
  : BusStop_parser_ (0),
    ERP_Gantry_parser_ (0),
    Crossing_parser_ (0),
    RoadBump_parser_ (0)
  {
  }

  // DailyTime_t_pskel
  //

  void DailyTime_t_pskel::
  timeValue_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->timeValue_parser_ = &p;
  }

  void DailyTime_t_pskel::
  base_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->base_parser_ = &p;
  }

  void DailyTime_t_pskel::
  parsers (::xml_schema::unsigned_int_pskel& timeValue,
           ::xml_schema::unsigned_int_pskel& base)
  {
    this->timeValue_parser_ = &timeValue;
    this->base_parser_ = &base;
  }

  DailyTime_t_pskel::
  DailyTime_t_pskel ()
  : timeValue_parser_ (0),
    base_parser_ (0)
  {
  }

  // SubTrip_t_pskel
  //

  void SubTrip_t_pskel::
  parentTrip_parser (::xml_schema::string_pskel& p)
  {
    this->parentTrip_parser_ = &p;
  }

  void SubTrip_t_pskel::
  mode_parser (::xml_schema::string_pskel& p)
  {
    this->mode_parser_ = &p;
  }

  void SubTrip_t_pskel::
  isPrimaryMode_parser (::xml_schema::boolean_pskel& p)
  {
    this->isPrimaryMode_parser_ = &p;
  }

  void SubTrip_t_pskel::
  ptLineId_parser (::xml_schema::string_pskel& p)
  {
    this->ptLineId_parser_ = &p;
  }

  void SubTrip_t_pskel::
  parsers (::xml_schema::string_pskel& parentTrip,
           ::xml_schema::string_pskel& mode,
           ::xml_schema::boolean_pskel& isPrimaryMode,
           ::xml_schema::string_pskel& ptLineId)
  {
    this->parentTrip_parser_ = &parentTrip;
    this->mode_parser_ = &mode;
    this->isPrimaryMode_parser_ = &isPrimaryMode;
    this->ptLineId_parser_ = &ptLineId;
  }

  SubTrip_t_pskel::
  SubTrip_t_pskel ()
  : parentTrip_parser_ (0),
    mode_parser_ (0),
    isPrimaryMode_parser_ (0),
    ptLineId_parser_ (0)
  {
  }

  // SubTrips_t_pskel
  //

  void SubTrips_t_pskel::
  SubTrip_parser (::geo::SubTrip_t_pskel& p)
  {
    this->SubTrip_parser_ = &p;
  }

  void SubTrips_t_pskel::
  parsers (::geo::SubTrip_t_pskel& SubTrip)
  {
    this->SubTrip_parser_ = &SubTrip;
  }

  SubTrips_t_pskel::
  SubTrips_t_pskel ()
  : SubTrip_parser_ (0)
  {
  }

  // TripChainItem_t_pskel
  //

  void TripChainItem_t_pskel::
  personID_parser (::xml_schema::integer_pskel& p)
  {
    this->personID_parser_ = &p;
  }

  void TripChainItem_t_pskel::
  itemType_parser (::geo::TripChainItemType_pskel& p)
  {
    this->itemType_parser_ = &p;
  }

  void TripChainItem_t_pskel::
  locationType_parser (::geo::TripChainItemLocationType_pskel& p)
  {
    this->locationType_parser_ = &p;
  }

  void TripChainItem_t_pskel::
  startTime_parser (::geo::DailyTime_t_pskel& p)
  {
    this->startTime_parser_ = &p;
  }

  void TripChainItem_t_pskel::
  endTime_parser (::geo::DailyTime_t_pskel& p)
  {
    this->endTime_parser_ = &p;
  }

  void TripChainItem_t_pskel::
  sequenceNumber_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->sequenceNumber_parser_ = &p;
  }

  void TripChainItem_t_pskel::
  parsers (::xml_schema::integer_pskel& personID,
           ::geo::TripChainItemType_pskel& itemType,
           ::geo::TripChainItemLocationType_pskel& locationType,
           ::geo::DailyTime_t_pskel& startTime,
           ::geo::DailyTime_t_pskel& endTime,
           ::xml_schema::unsigned_int_pskel& sequenceNumber)
  {
    this->personID_parser_ = &personID;
    this->itemType_parser_ = &itemType;
    this->locationType_parser_ = &locationType;
    this->startTime_parser_ = &startTime;
    this->endTime_parser_ = &endTime;
    this->sequenceNumber_parser_ = &sequenceNumber;
  }

  TripChainItem_t_pskel::
  TripChainItem_t_pskel ()
  : personID_parser_ (0),
    itemType_parser_ (0),
    locationType_parser_ (0),
    startTime_parser_ (0),
    endTime_parser_ (0),
    sequenceNumber_parser_ (0)
  {
  }

  // Trip_t_pskel
  //

  void Trip_t_pskel::
  tripId_parser (::xml_schema::integer_pskel& p)
  {
    this->tripId_parser_ = &p;
  }

  void Trip_t_pskel::
  fromLocation_parser (::xml_schema::string_pskel& p)
  {
    this->fromLocation_parser_ = &p;
  }

  void Trip_t_pskel::
  fromLocationType_parser (::geo::TripChainItemLocationType_pskel& p)
  {
    this->fromLocationType_parser_ = &p;
  }

  void Trip_t_pskel::
  toLocation_parser (::xml_schema::string_pskel& p)
  {
    this->toLocation_parser_ = &p;
  }

  void Trip_t_pskel::
  toLocationType_parser (::geo::TripChainItemLocationType_pskel& p)
  {
    this->toLocationType_parser_ = &p;
  }

  void Trip_t_pskel::
  SubTrips_parser (::geo::SubTrips_t_pskel& p)
  {
    this->SubTrips_parser_ = &p;
  }

  void Trip_t_pskel::
  parsers (::xml_schema::integer_pskel& personID,
           ::geo::TripChainItemType_pskel& itemType,
           ::geo::TripChainItemLocationType_pskel& locationType,
           ::geo::DailyTime_t_pskel& startTime,
           ::geo::DailyTime_t_pskel& endTime,
           ::xml_schema::unsigned_int_pskel& sequenceNumber,
           ::xml_schema::integer_pskel& tripId,
           ::xml_schema::string_pskel& fromLocation,
           ::geo::TripChainItemLocationType_pskel& fromLocationType,
           ::xml_schema::string_pskel& toLocation,
           ::geo::TripChainItemLocationType_pskel& toLocationType,
           ::geo::SubTrips_t_pskel& SubTrips)
  {
    this->personID_parser_ = &personID;
    this->itemType_parser_ = &itemType;
    this->locationType_parser_ = &locationType;
    this->startTime_parser_ = &startTime;
    this->endTime_parser_ = &endTime;
    this->sequenceNumber_parser_ = &sequenceNumber;
    this->tripId_parser_ = &tripId;
    this->fromLocation_parser_ = &fromLocation;
    this->fromLocationType_parser_ = &fromLocationType;
    this->toLocation_parser_ = &toLocation;
    this->toLocationType_parser_ = &toLocationType;
    this->SubTrips_parser_ = &SubTrips;
  }

  Trip_t_pskel::
  Trip_t_pskel ()
  : tripId_parser_ (0),
    fromLocation_parser_ (0),
    fromLocationType_parser_ (0),
    toLocation_parser_ (0),
    toLocationType_parser_ (0),
    SubTrips_parser_ (0)
  {
  }

  // Activity_t_pskel
  //

  void Activity_t_pskel::
  activityId_parser (::xml_schema::integer_pskel& p)
  {
    this->activityId_parser_ = &p;
  }

  void Activity_t_pskel::
  parsers (::xml_schema::integer_pskel& personID,
           ::geo::TripChainItemType_pskel& itemType,
           ::geo::TripChainItemLocationType_pskel& locationType,
           ::geo::DailyTime_t_pskel& startTime,
           ::geo::DailyTime_t_pskel& endTime,
           ::xml_schema::unsigned_int_pskel& sequenceNumber,
           ::xml_schema::integer_pskel& activityId)
  {
    this->personID_parser_ = &personID;
    this->itemType_parser_ = &itemType;
    this->locationType_parser_ = &locationType;
    this->startTime_parser_ = &startTime;
    this->endTime_parser_ = &endTime;
    this->sequenceNumber_parser_ = &sequenceNumber;
    this->activityId_parser_ = &activityId;
  }

  Activity_t_pskel::
  Activity_t_pskel ()
  : activityId_parser_ (0)
  {
  }

  // TripChain_t_pskel
  //

  void TripChain_t_pskel::
  Trip_parser (::geo::Trip_t_pskel& p)
  {
    this->Trip_parser_ = &p;
  }

  void TripChain_t_pskel::
  Activity_parser (::geo::Activity_t_pskel& p)
  {
    this->Activity_parser_ = &p;
  }

  void TripChain_t_pskel::
  parsers (::geo::Trip_t_pskel& Trip,
           ::geo::Activity_t_pskel& Activity)
  {
    this->Trip_parser_ = &Trip;
    this->Activity_parser_ = &Activity;
  }

  TripChain_t_pskel::
  TripChain_t_pskel ()
  : Trip_parser_ (0),
    Activity_parser_ (0)
  {
  }

  // TripChains_t_pskel
  //

  void TripChains_t_pskel::
  TripChain_parser (::geo::TripChain_t_pskel& p)
  {
    this->TripChain_parser_ = &p;
  }

  void TripChains_t_pskel::
  parsers (::geo::TripChain_t_pskel& TripChain)
  {
    this->TripChain_parser_ = &TripChain;
  }

  TripChains_t_pskel::
  TripChains_t_pskel ()
  : TripChain_parser_ (0)
  {
  }

  // GeoSpatial_t_pskel
  //

  void GeoSpatial_t_pskel::
  RoadNetwork_parser (::geo::RoadNetwork_t_pskel& p)
  {
    this->RoadNetwork_parser_ = &p;
  }

  void GeoSpatial_t_pskel::
  parsers (::geo::RoadNetwork_t_pskel& RoadNetwork)
  {
    this->RoadNetwork_parser_ = &RoadNetwork;
  }

  GeoSpatial_t_pskel::
  GeoSpatial_t_pskel ()
  : RoadNetwork_parser_ (0)
  {
  }

  // SimMobility_t_pskel
  //

  void SimMobility_t_pskel::
  GeoSpatial_parser (::geo::GeoSpatial_t_pskel& p)
  {
    this->GeoSpatial_parser_ = &p;
  }

  void SimMobility_t_pskel::
  TripChains_parser (::geo::TripChains_t_pskel& p)
  {
    this->TripChains_parser_ = &p;
  }

  void SimMobility_t_pskel::
  parsers (::geo::GeoSpatial_t_pskel& GeoSpatial,
           ::geo::TripChains_t_pskel& TripChains)
  {
    this->GeoSpatial_parser_ = &GeoSpatial;
    this->TripChains_parser_ = &TripChains;
  }

  SimMobility_t_pskel::
  SimMobility_t_pskel ()
  : GeoSpatial_parser_ (0),
    TripChains_parser_ (0)
  {
  }

  // Lanes_pskel
  //

  void Lanes_pskel::
  Lane_parser (::geo::lane_t_pskel& p)
  {
    this->Lane_parser_ = &p;
  }

  void Lanes_pskel::
  parsers (::geo::lane_t_pskel& Lane)
  {
    this->Lane_parser_ = &Lane;
  }

  Lanes_pskel::
  Lanes_pskel ()
  : Lane_parser_ (0)
  {
  }

  // Segments_pskel
  //

  void Segments_pskel::
  FWDSegments_parser (::geo::fwdBckSegments_t_pskel& p)
  {
    this->FWDSegments_parser_ = &p;
  }

  void Segments_pskel::
  BKDSegments_parser (::geo::fwdBckSegments_t_pskel& p)
  {
    this->BKDSegments_parser_ = &p;
  }

  void Segments_pskel::
  parsers (::geo::fwdBckSegments_t_pskel& FWDSegments,
           ::geo::fwdBckSegments_t_pskel& BKDSegments)
  {
    this->FWDSegments_parser_ = &FWDSegments;
    this->BKDSegments_parser_ = &BKDSegments;
  }

  Segments_pskel::
  Segments_pskel ()
  : FWDSegments_parser_ (0),
    BKDSegments_parser_ (0)
  {
  }

  // Nodes_pskel
  //

  void Nodes_pskel::
  UniNodes_parser (::geo::UniNodes_pskel& p)
  {
    this->UniNodes_parser_ = &p;
  }

  void Nodes_pskel::
  Intersections_parser (::geo::Intersections_pskel& p)
  {
    this->Intersections_parser_ = &p;
  }

  void Nodes_pskel::
  roundabouts_parser (::geo::roundabouts_pskel& p)
  {
    this->roundabouts_parser_ = &p;
  }

  void Nodes_pskel::
  parsers (::geo::UniNodes_pskel& UniNodes,
           ::geo::Intersections_pskel& Intersections,
           ::geo::roundabouts_pskel& roundabouts)
  {
    this->UniNodes_parser_ = &UniNodes;
    this->Intersections_parser_ = &Intersections;
    this->roundabouts_parser_ = &roundabouts;
  }

  Nodes_pskel::
  Nodes_pskel ()
  : UniNodes_parser_ (0),
    Intersections_parser_ (0),
    roundabouts_parser_ (0)
  {
  }

  // Links_pskel
  //

  void Links_pskel::
  Link_parser (::geo::link_t_pskel& p)
  {
    this->Link_parser_ = &p;
  }

  void Links_pskel::
  parsers (::geo::link_t_pskel& Link)
  {
    this->Link_parser_ = &Link;
  }

  Links_pskel::
  Links_pskel ()
  : Link_parser_ (0)
  {
  }

  // UniNodes_pskel
  //

  void UniNodes_pskel::
  UniNode_parser (::geo::UniNode_t_pskel& p)
  {
    this->UniNode_parser_ = &p;
  }

  void UniNodes_pskel::
  parsers (::geo::UniNode_t_pskel& UniNode)
  {
    this->UniNode_parser_ = &UniNode;
  }

  UniNodes_pskel::
  UniNodes_pskel ()
  : UniNode_parser_ (0)
  {
  }

  // Intersections_pskel
  //

  void Intersections_pskel::
  Intersection_parser (::geo::intersection_t_pskel& p)
  {
    this->Intersection_parser_ = &p;
  }

  void Intersections_pskel::
  parsers (::geo::intersection_t_pskel& Intersection)
  {
    this->Intersection_parser_ = &Intersection;
  }

  Intersections_pskel::
  Intersections_pskel ()
  : Intersection_parser_ (0)
  {
  }

  // roundabouts_pskel
  //

  void roundabouts_pskel::
  roundabout_parser (::geo::roundabout_t_pskel& p)
  {
    this->roundabout_parser_ = &p;
  }

  void roundabouts_pskel::
  parsers (::geo::roundabout_t_pskel& roundabout)
  {
    this->roundabout_parser_ = &roundabout;
  }

  roundabouts_pskel::
  roundabouts_pskel ()
  : roundabout_parser_ (0)
  {
  }
}

namespace geo
{
  // Point2D_t_pskel
  //

  void Point2D_t_pskel::
  xPos (unsigned int)
  {
  }

  void Point2D_t_pskel::
  yPos (unsigned int)
  {
  }

  bool Point2D_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "xPos" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->xPos_parser_;

      if (this->xPos_parser_)
        this->xPos_parser_->pre ();

      return true;
    }

    if (n == "yPos" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->yPos_parser_;

      if (this->yPos_parser_)
        this->yPos_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Point2D_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "xPos" && ns.empty ())
    {
      if (this->xPos_parser_)
        this->xPos (this->xPos_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "yPos" && ns.empty ())
    {
      if (this->yPos_parser_)
        this->yPos (this->yPos_parser_->post_unsigned_int ());

      return true;
    }

    return false;
  }

  // PolyPoint_t_pskel
  //

  void PolyPoint_t_pskel::
  pointID (const ::std::string&)
  {
  }

  void PolyPoint_t_pskel::
  location (sim_mob::Point2D)
  {
  }

  bool PolyPoint_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "pointID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->pointID_parser_;

      if (this->pointID_parser_)
        this->pointID_parser_->pre ();

      return true;
    }

    if (n == "location" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->location_parser_;

      if (this->location_parser_)
        this->location_parser_->pre ();

      return true;
    }

    return false;
  }

  bool PolyPoint_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "pointID" && ns.empty ())
    {
      if (this->pointID_parser_)
        this->pointID (this->pointID_parser_->post_string ());

      return true;
    }

    if (n == "location" && ns.empty ())
    {
      if (this->location_parser_)
        this->location (this->location_parser_->post_Point2D_t ());

      return true;
    }

    return false;
  }

  // PolyLine_t_pskel
  //

  void PolyLine_t_pskel::
  PolyPoint (sim_mob::Point2D)
  {
  }

  bool PolyLine_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "PolyPoint" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->PolyPoint_parser_;

      if (this->PolyPoint_parser_)
        this->PolyPoint_parser_->pre ();

      return true;
    }

    return false;
  }

  bool PolyLine_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "PolyPoint" && ns.empty ())
    {
      if (this->PolyPoint_parser_)
        this->PolyPoint (this->PolyPoint_parser_->post_PolyPoint_t ());

      return true;
    }

    return false;
  }

  // lane_t_pskel
  //

  void lane_t_pskel::
  laneID (const ::std::string&)
  {
  }

  void lane_t_pskel::
  width (unsigned int)
  {
  }

  void lane_t_pskel::
  can_go_straight (bool)
  {
  }

  void lane_t_pskel::
  can_turn_left (bool)
  {
  }

  void lane_t_pskel::
  can_turn_right (bool)
  {
  }

  void lane_t_pskel::
  can_turn_on_red_signal (bool)
  {
  }

  void lane_t_pskel::
  can_change_lane_left (bool)
  {
  }

  void lane_t_pskel::
  can_change_lane_right (bool)
  {
  }

  void lane_t_pskel::
  is_road_shoulder (bool)
  {
  }

  void lane_t_pskel::
  is_bicycle_lane (bool)
  {
  }

  void lane_t_pskel::
  is_pedestrian_lane (bool)
  {
  }

  void lane_t_pskel::
  is_vehicle_lane (bool)
  {
  }

  void lane_t_pskel::
  is_standard_bus_lane (bool)
  {
  }

  void lane_t_pskel::
  is_whole_day_bus_lane (bool)
  {
  }

  void lane_t_pskel::
  is_high_occupancy_vehicle_lane (bool)
  {
  }

  void lane_t_pskel::
  can_freely_park_here (bool)
  {
  }

  void lane_t_pskel::
  can_stop_here (bool)
  {
  }

  void lane_t_pskel::
  is_u_turn_allowed (bool)
  {
  }

  void lane_t_pskel::
  PolyLine (std::vector<sim_mob::Point2D>)
  {
  }

  bool lane_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "laneID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->laneID_parser_;

      if (this->laneID_parser_)
        this->laneID_parser_->pre ();

      return true;
    }

    if (n == "width" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->width_parser_;

      if (this->width_parser_)
        this->width_parser_->pre ();

      return true;
    }

    if (n == "can_go_straight" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->can_go_straight_parser_;

      if (this->can_go_straight_parser_)
        this->can_go_straight_parser_->pre ();

      return true;
    }

    if (n == "can_turn_left" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->can_turn_left_parser_;

      if (this->can_turn_left_parser_)
        this->can_turn_left_parser_->pre ();

      return true;
    }

    if (n == "can_turn_right" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->can_turn_right_parser_;

      if (this->can_turn_right_parser_)
        this->can_turn_right_parser_->pre ();

      return true;
    }

    if (n == "can_turn_on_red_signal" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->can_turn_on_red_signal_parser_;

      if (this->can_turn_on_red_signal_parser_)
        this->can_turn_on_red_signal_parser_->pre ();

      return true;
    }

    if (n == "can_change_lane_left" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->can_change_lane_left_parser_;

      if (this->can_change_lane_left_parser_)
        this->can_change_lane_left_parser_->pre ();

      return true;
    }

    if (n == "can_change_lane_right" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->can_change_lane_right_parser_;

      if (this->can_change_lane_right_parser_)
        this->can_change_lane_right_parser_->pre ();

      return true;
    }

    if (n == "is_road_shoulder" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->is_road_shoulder_parser_;

      if (this->is_road_shoulder_parser_)
        this->is_road_shoulder_parser_->pre ();

      return true;
    }

    if (n == "is_bicycle_lane" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->is_bicycle_lane_parser_;

      if (this->is_bicycle_lane_parser_)
        this->is_bicycle_lane_parser_->pre ();

      return true;
    }

    if (n == "is_pedestrian_lane" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->is_pedestrian_lane_parser_;

      if (this->is_pedestrian_lane_parser_)
        this->is_pedestrian_lane_parser_->pre ();

      return true;
    }

    if (n == "is_vehicle_lane" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->is_vehicle_lane_parser_;

      if (this->is_vehicle_lane_parser_)
        this->is_vehicle_lane_parser_->pre ();

      return true;
    }

    if (n == "is_standard_bus_lane" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->is_standard_bus_lane_parser_;

      if (this->is_standard_bus_lane_parser_)
        this->is_standard_bus_lane_parser_->pre ();

      return true;
    }

    if (n == "is_whole_day_bus_lane" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->is_whole_day_bus_lane_parser_;

      if (this->is_whole_day_bus_lane_parser_)
        this->is_whole_day_bus_lane_parser_->pre ();

      return true;
    }

    if (n == "is_high_occupancy_vehicle_lane" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->is_high_occupancy_vehicle_lane_parser_;

      if (this->is_high_occupancy_vehicle_lane_parser_)
        this->is_high_occupancy_vehicle_lane_parser_->pre ();

      return true;
    }

    if (n == "can_freely_park_here" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->can_freely_park_here_parser_;

      if (this->can_freely_park_here_parser_)
        this->can_freely_park_here_parser_->pre ();

      return true;
    }

    if (n == "can_stop_here" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->can_stop_here_parser_;

      if (this->can_stop_here_parser_)
        this->can_stop_here_parser_->pre ();

      return true;
    }

    if (n == "is_u_turn_allowed" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->is_u_turn_allowed_parser_;

      if (this->is_u_turn_allowed_parser_)
        this->is_u_turn_allowed_parser_->pre ();

      return true;
    }

    if (n == "PolyLine" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->PolyLine_parser_;

      if (this->PolyLine_parser_)
        this->PolyLine_parser_->pre ();

      return true;
    }

    return false;
  }

  bool lane_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "laneID" && ns.empty ())
    {
      if (this->laneID_parser_)
        this->laneID (this->laneID_parser_->post_string ());

      return true;
    }

    if (n == "width" && ns.empty ())
    {
      if (this->width_parser_)
        this->width (this->width_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "can_go_straight" && ns.empty ())
    {
      if (this->can_go_straight_parser_)
        this->can_go_straight (this->can_go_straight_parser_->post_boolean ());

      return true;
    }

    if (n == "can_turn_left" && ns.empty ())
    {
      if (this->can_turn_left_parser_)
        this->can_turn_left (this->can_turn_left_parser_->post_boolean ());

      return true;
    }

    if (n == "can_turn_right" && ns.empty ())
    {
      if (this->can_turn_right_parser_)
        this->can_turn_right (this->can_turn_right_parser_->post_boolean ());

      return true;
    }

    if (n == "can_turn_on_red_signal" && ns.empty ())
    {
      if (this->can_turn_on_red_signal_parser_)
        this->can_turn_on_red_signal (this->can_turn_on_red_signal_parser_->post_boolean ());

      return true;
    }

    if (n == "can_change_lane_left" && ns.empty ())
    {
      if (this->can_change_lane_left_parser_)
        this->can_change_lane_left (this->can_change_lane_left_parser_->post_boolean ());

      return true;
    }

    if (n == "can_change_lane_right" && ns.empty ())
    {
      if (this->can_change_lane_right_parser_)
        this->can_change_lane_right (this->can_change_lane_right_parser_->post_boolean ());

      return true;
    }

    if (n == "is_road_shoulder" && ns.empty ())
    {
      if (this->is_road_shoulder_parser_)
        this->is_road_shoulder (this->is_road_shoulder_parser_->post_boolean ());

      return true;
    }

    if (n == "is_bicycle_lane" && ns.empty ())
    {
      if (this->is_bicycle_lane_parser_)
        this->is_bicycle_lane (this->is_bicycle_lane_parser_->post_boolean ());

      return true;
    }

    if (n == "is_pedestrian_lane" && ns.empty ())
    {
      if (this->is_pedestrian_lane_parser_)
        this->is_pedestrian_lane (this->is_pedestrian_lane_parser_->post_boolean ());

      return true;
    }

    if (n == "is_vehicle_lane" && ns.empty ())
    {
      if (this->is_vehicle_lane_parser_)
        this->is_vehicle_lane (this->is_vehicle_lane_parser_->post_boolean ());

      return true;
    }

    if (n == "is_standard_bus_lane" && ns.empty ())
    {
      if (this->is_standard_bus_lane_parser_)
        this->is_standard_bus_lane (this->is_standard_bus_lane_parser_->post_boolean ());

      return true;
    }

    if (n == "is_whole_day_bus_lane" && ns.empty ())
    {
      if (this->is_whole_day_bus_lane_parser_)
        this->is_whole_day_bus_lane (this->is_whole_day_bus_lane_parser_->post_boolean ());

      return true;
    }

    if (n == "is_high_occupancy_vehicle_lane" && ns.empty ())
    {
      if (this->is_high_occupancy_vehicle_lane_parser_)
        this->is_high_occupancy_vehicle_lane (this->is_high_occupancy_vehicle_lane_parser_->post_boolean ());

      return true;
    }

    if (n == "can_freely_park_here" && ns.empty ())
    {
      if (this->can_freely_park_here_parser_)
        this->can_freely_park_here (this->can_freely_park_here_parser_->post_boolean ());

      return true;
    }

    if (n == "can_stop_here" && ns.empty ())
    {
      if (this->can_stop_here_parser_)
        this->can_stop_here (this->can_stop_here_parser_->post_boolean ());

      return true;
    }

    if (n == "is_u_turn_allowed" && ns.empty ())
    {
      if (this->is_u_turn_allowed_parser_)
        this->is_u_turn_allowed (this->is_u_turn_allowed_parser_->post_boolean ());

      return true;
    }

    if (n == "PolyLine" && ns.empty ())
    {
      if (this->PolyLine_parser_)
        this->PolyLine (this->PolyLine_parser_->post_PolyLine_t ());

      return true;
    }

    return false;
  }

  // connector_t_pskel
  //

  void connector_t_pskel::
  laneFrom (const ::std::string&)
  {
  }

  void connector_t_pskel::
  laneTo (const ::std::string&)
  {
  }

  bool connector_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "laneFrom" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->laneFrom_parser_;

      if (this->laneFrom_parser_)
        this->laneFrom_parser_->pre ();

      return true;
    }

    if (n == "laneTo" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->laneTo_parser_;

      if (this->laneTo_parser_)
        this->laneTo_parser_->pre ();

      return true;
    }

    return false;
  }

  bool connector_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "laneFrom" && ns.empty ())
    {
      if (this->laneFrom_parser_)
        this->laneFrom (this->laneFrom_parser_->post_string ());

      return true;
    }

    if (n == "laneTo" && ns.empty ())
    {
      if (this->laneTo_parser_)
        this->laneTo (this->laneTo_parser_->post_string ());

      return true;
    }

    return false;
  }

  // connectors_t_pskel
  //

  void connectors_t_pskel::
  Connector (std::pair<std::string,std::string>)
  {
  }

  bool connectors_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "Connector" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Connector_parser_;

      if (this->Connector_parser_)
        this->Connector_parser_->pre ();

      return true;
    }

    return false;
  }

  bool connectors_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "Connector" && ns.empty ())
    {
      if (this->Connector_parser_)
        this->Connector (this->Connector_parser_->post_connector_t ());

      return true;
    }

    return false;
  }

  // Multi_Connector_t_pskel
  //

  void Multi_Connector_t_pskel::
  RoadSegment (const ::std::string&)
  {
  }

  void Multi_Connector_t_pskel::
  Connectors (std::set<std::pair<std::string,std::string > >)
  {
  }

  bool Multi_Connector_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "RoadSegment" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->RoadSegment_parser_;

      if (this->RoadSegment_parser_)
        this->RoadSegment_parser_->pre ();

      return true;
    }

    if (n == "Connectors" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Connectors_parser_;

      if (this->Connectors_parser_)
        this->Connectors_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Multi_Connector_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "RoadSegment" && ns.empty ())
    {
      if (this->RoadSegment_parser_)
        this->RoadSegment (this->RoadSegment_parser_->post_string ());

      return true;
    }

    if (n == "Connectors" && ns.empty ())
    {
      if (this->Connectors_parser_)
        this->Connectors (this->Connectors_parser_->post_connectors_t ());

      return true;
    }

    return false;
  }

  // Multi_Connectors_t_pskel
  //

  void Multi_Connectors_t_pskel::
  MultiConnectors (const std::pair<std::string,std::set<std::pair<std::string,std::string> > >&)
  {
  }

  bool Multi_Connectors_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "MultiConnectors" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->MultiConnectors_parser_;

      if (this->MultiConnectors_parser_)
        this->MultiConnectors_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Multi_Connectors_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "MultiConnectors" && ns.empty ())
    {
      if (this->MultiConnectors_parser_)
        this->MultiConnectors (this->MultiConnectors_parser_->post_Multi_Connector_t ());

      return true;
    }

    return false;
  }

  // fwdBckSegments_t_pskel
  //

  void fwdBckSegments_t_pskel::
  Segment (sim_mob::RoadSegment*)
  {
  }

  bool fwdBckSegments_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "Segment" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Segment_parser_;

      if (this->Segment_parser_)
        this->Segment_parser_->pre ();

      return true;
    }

    return false;
  }

  bool fwdBckSegments_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "Segment" && ns.empty ())
    {
      if (this->Segment_parser_)
        this->Segment (this->Segment_parser_->post_segment_t ());

      return true;
    }

    return false;
  }

  // RoadSegmentsAt_t_pskel
  //

  void RoadSegmentsAt_t_pskel::
  segmentID (const ::std::string&)
  {
  }

  bool RoadSegmentsAt_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "segmentID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->segmentID_parser_;

      if (this->segmentID_parser_)
        this->segmentID_parser_->pre ();

      return true;
    }

    return false;
  }

  bool RoadSegmentsAt_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "segmentID" && ns.empty ())
    {
      if (this->segmentID_parser_)
        this->segmentID (this->segmentID_parser_->post_string ());

      return true;
    }

    return false;
  }

  // segment_t_pskel
  //

  void segment_t_pskel::
  segmentID (const ::std::string&)
  {
  }

  void segment_t_pskel::
  startingNode (const ::std::string&)
  {
  }

  void segment_t_pskel::
  endingNode (const ::std::string&)
  {
  }

  void segment_t_pskel::
  maxSpeed (short)
  {
  }

  void segment_t_pskel::
  Length (unsigned int)
  {
  }

  void segment_t_pskel::
  Width (unsigned int)
  {
  }

  void segment_t_pskel::
  Lanes (std::vector<sim_mob::Lane*>)
  {
  }

  void segment_t_pskel::
  Obstacles (std::map<centimeter_t,const RoadItem*>)
  {
  }

  void segment_t_pskel::
  KurbLine (std::vector<sim_mob::Point2D>)
  {
  }

  bool segment_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "segmentID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->segmentID_parser_;

      if (this->segmentID_parser_)
        this->segmentID_parser_->pre ();

      return true;
    }

    if (n == "startingNode" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->startingNode_parser_;

      if (this->startingNode_parser_)
        this->startingNode_parser_->pre ();

      return true;
    }

    if (n == "endingNode" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->endingNode_parser_;

      if (this->endingNode_parser_)
        this->endingNode_parser_->pre ();

      return true;
    }

    if (n == "maxSpeed" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->maxSpeed_parser_;

      if (this->maxSpeed_parser_)
        this->maxSpeed_parser_->pre ();

      return true;
    }

    if (n == "Length" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Length_parser_;

      if (this->Length_parser_)
        this->Length_parser_->pre ();

      return true;
    }

    if (n == "Width" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Width_parser_;

      if (this->Width_parser_)
        this->Width_parser_->pre ();

      return true;
    }

    if (n == "Lanes" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Lanes_parser_;

      if (this->Lanes_parser_)
        this->Lanes_parser_->pre ();

      return true;
    }

    if (n == "Obstacles" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Obstacles_parser_;

      if (this->Obstacles_parser_)
        this->Obstacles_parser_->pre ();

      return true;
    }

    if (n == "KurbLine" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->KurbLine_parser_;

      if (this->KurbLine_parser_)
        this->KurbLine_parser_->pre ();

      return true;
    }

    return false;
  }

  bool segment_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "segmentID" && ns.empty ())
    {
      if (this->segmentID_parser_)
        this->segmentID (this->segmentID_parser_->post_string ());

      return true;
    }

    if (n == "startingNode" && ns.empty ())
    {
      if (this->startingNode_parser_)
        this->startingNode (this->startingNode_parser_->post_string ());

      return true;
    }

    if (n == "endingNode" && ns.empty ())
    {
      if (this->endingNode_parser_)
        this->endingNode (this->endingNode_parser_->post_string ());

      return true;
    }

    if (n == "maxSpeed" && ns.empty ())
    {
      if (this->maxSpeed_parser_)
        this->maxSpeed (this->maxSpeed_parser_->post_short ());

      return true;
    }

    if (n == "Length" && ns.empty ())
    {
      if (this->Length_parser_)
        this->Length (this->Length_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "Width" && ns.empty ())
    {
      if (this->Width_parser_)
        this->Width (this->Width_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "Lanes" && ns.empty ())
    {
      if (this->Lanes_parser_)
        this->Lanes (this->Lanes_parser_->post_Lanes ());

      return true;
    }

    if (n == "Obstacles" && ns.empty ())
    {
      if (this->Obstacles_parser_)
        this->Obstacles (this->Obstacles_parser_->post_RoadItems_t ());

      return true;
    }

    if (n == "KurbLine" && ns.empty ())
    {
      if (this->KurbLine_parser_)
        this->KurbLine (this->KurbLine_parser_->post_PolyLine_t ());

      return true;
    }

    return false;
  }

  // link_t_pskel
  //

  void link_t_pskel::
  linkID (const ::std::string&)
  {
  }

  void link_t_pskel::
  roadName (const ::std::string&)
  {
  }

  void link_t_pskel::
  StartingNode (const ::std::string&)
  {
  }

  void link_t_pskel::
  EndingNode (const ::std::string&)
  {
  }

  void link_t_pskel::
  Segments (std::pair<std::vector<sim_mob::RoadSegment*>,std::vector<sim_mob::RoadSegment*> >)
  {
  }

  bool link_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "linkID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->linkID_parser_;

      if (this->linkID_parser_)
        this->linkID_parser_->pre ();

      return true;
    }

    if (n == "roadName" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->roadName_parser_;

      if (this->roadName_parser_)
        this->roadName_parser_->pre ();

      return true;
    }

    if (n == "StartingNode" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->StartingNode_parser_;

      if (this->StartingNode_parser_)
        this->StartingNode_parser_->pre ();

      return true;
    }

    if (n == "EndingNode" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->EndingNode_parser_;

      if (this->EndingNode_parser_)
        this->EndingNode_parser_->pre ();

      return true;
    }

    if (n == "Segments" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Segments_parser_;

      if (this->Segments_parser_)
        this->Segments_parser_->pre ();

      return true;
    }

    return false;
  }

  bool link_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "linkID" && ns.empty ())
    {
      if (this->linkID_parser_)
        this->linkID (this->linkID_parser_->post_string ());

      return true;
    }

    if (n == "roadName" && ns.empty ())
    {
      if (this->roadName_parser_)
        this->roadName (this->roadName_parser_->post_string ());

      return true;
    }

    if (n == "StartingNode" && ns.empty ())
    {
      if (this->StartingNode_parser_)
        this->StartingNode (this->StartingNode_parser_->post_string ());

      return true;
    }

    if (n == "EndingNode" && ns.empty ())
    {
      if (this->EndingNode_parser_)
        this->EndingNode (this->EndingNode_parser_->post_string ());

      return true;
    }

    if (n == "Segments" && ns.empty ())
    {
      if (this->Segments_parser_)
        this->Segments (this->Segments_parser_->post_Segments ());

      return true;
    }

    return false;
  }

  // separator_t_pskel
  //

  void separator_t_pskel::
  separator_ID (unsigned short)
  {
  }

  void separator_t_pskel::
  separator_value (bool)
  {
  }

  void separator_t_pskel::
  post_separator_t ()
  {
  }

  bool separator_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "separator_ID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->separator_ID_parser_;

      if (this->separator_ID_parser_)
        this->separator_ID_parser_->pre ();

      return true;
    }

    if (n == "separator_value" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->separator_value_parser_;

      if (this->separator_value_parser_)
        this->separator_value_parser_->pre ();

      return true;
    }

    return false;
  }

  bool separator_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "separator_ID" && ns.empty ())
    {
      if (this->separator_ID_parser_)
        this->separator_ID (this->separator_ID_parser_->post_unsigned_short ());

      return true;
    }

    if (n == "separator_value" && ns.empty ())
    {
      if (this->separator_value_parser_)
        this->separator_value (this->separator_value_parser_->post_boolean ());

      return true;
    }

    return false;
  }

  // separators_t_pskel
  //

  void separators_t_pskel::
  Separator ()
  {
  }

  void separators_t_pskel::
  post_separators_t ()
  {
  }

  bool separators_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "Separator" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Separator_parser_;

      if (this->Separator_parser_)
        this->Separator_parser_->pre ();

      return true;
    }

    return false;
  }

  bool separators_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "Separator" && ns.empty ())
    {
      if (this->Separator_parser_)
      {
        this->Separator_parser_->post_separator_t ();
        this->Separator ();
      }

      return true;
    }

    return false;
  }

  // DomainIsland_t_pskel
  //

  void DomainIsland_t_pskel::
  domainIsland_ID (unsigned short)
  {
  }

  void DomainIsland_t_pskel::
  domainIsland_value (bool)
  {
  }

  void DomainIsland_t_pskel::
  post_DomainIsland_t ()
  {
  }

  bool DomainIsland_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "domainIsland_ID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->domainIsland_ID_parser_;

      if (this->domainIsland_ID_parser_)
        this->domainIsland_ID_parser_->pre ();

      return true;
    }

    if (n == "domainIsland_value" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->domainIsland_value_parser_;

      if (this->domainIsland_value_parser_)
        this->domainIsland_value_parser_->pre ();

      return true;
    }

    return false;
  }

  bool DomainIsland_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "domainIsland_ID" && ns.empty ())
    {
      if (this->domainIsland_ID_parser_)
        this->domainIsland_ID (this->domainIsland_ID_parser_->post_unsigned_short ());

      return true;
    }

    if (n == "domainIsland_value" && ns.empty ())
    {
      if (this->domainIsland_value_parser_)
        this->domainIsland_value (this->domainIsland_value_parser_->post_boolean ());

      return true;
    }

    return false;
  }

  // DomainIslands_t_pskel
  //

  void DomainIslands_t_pskel::
  domainIslands ()
  {
  }

  void DomainIslands_t_pskel::
  post_DomainIslands_t ()
  {
  }

  bool DomainIslands_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "domainIslands" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->domainIslands_parser_;

      if (this->domainIslands_parser_)
        this->domainIslands_parser_->pre ();

      return true;
    }

    return false;
  }

  bool DomainIslands_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "domainIslands" && ns.empty ())
    {
      if (this->domainIslands_parser_)
      {
        this->domainIslands_parser_->post_DomainIsland_t ();
        this->domainIslands ();
      }

      return true;
    }

    return false;
  }

  // offset_t_pskel
  //

  void offset_t_pskel::
  offset_ID (unsigned short)
  {
  }

  void offset_t_pskel::
  offset_value (unsigned int)
  {
  }

  void offset_t_pskel::
  post_offset_t ()
  {
  }

  bool offset_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "offset_ID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->offset_ID_parser_;

      if (this->offset_ID_parser_)
        this->offset_ID_parser_->pre ();

      return true;
    }

    if (n == "offset_value" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->offset_value_parser_;

      if (this->offset_value_parser_)
        this->offset_value_parser_->pre ();

      return true;
    }

    return false;
  }

  bool offset_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "offset_ID" && ns.empty ())
    {
      if (this->offset_ID_parser_)
        this->offset_ID (this->offset_ID_parser_->post_unsigned_short ());

      return true;
    }

    if (n == "offset_value" && ns.empty ())
    {
      if (this->offset_value_parser_)
        this->offset_value (this->offset_value_parser_->post_unsigned_int ());

      return true;
    }

    return false;
  }

  // offsets_t_pskel
  //

  void offsets_t_pskel::
  offset ()
  {
  }

  void offsets_t_pskel::
  post_offsets_t ()
  {
  }

  bool offsets_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "offset" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->offset_parser_;

      if (this->offset_parser_)
        this->offset_parser_->pre ();

      return true;
    }

    return false;
  }

  bool offsets_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "offset" && ns.empty ())
    {
      if (this->offset_parser_)
      {
        this->offset_parser_->post_offset_t ();
        this->offset ();
      }

      return true;
    }

    return false;
  }

  // ChunkLength_t_pskel
  //

  void ChunkLength_t_pskel::
  chunklength_ID (unsigned short)
  {
  }

  void ChunkLength_t_pskel::
  chunklength_value (unsigned int)
  {
  }

  void ChunkLength_t_pskel::
  post_ChunkLength_t ()
  {
  }

  bool ChunkLength_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "chunklength_ID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->chunklength_ID_parser_;

      if (this->chunklength_ID_parser_)
        this->chunklength_ID_parser_->pre ();

      return true;
    }

    if (n == "chunklength_value" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->chunklength_value_parser_;

      if (this->chunklength_value_parser_)
        this->chunklength_value_parser_->pre ();

      return true;
    }

    return false;
  }

  bool ChunkLength_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "chunklength_ID" && ns.empty ())
    {
      if (this->chunklength_ID_parser_)
        this->chunklength_ID (this->chunklength_ID_parser_->post_unsigned_short ());

      return true;
    }

    if (n == "chunklength_value" && ns.empty ())
    {
      if (this->chunklength_value_parser_)
        this->chunklength_value (this->chunklength_value_parser_->post_unsigned_int ());

      return true;
    }

    return false;
  }

  // ChunkLengths_t_pskel
  //

  void ChunkLengths_t_pskel::
  chunklength ()
  {
  }

  void ChunkLengths_t_pskel::
  post_ChunkLengths_t ()
  {
  }

  bool ChunkLengths_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "chunklength" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->chunklength_parser_;

      if (this->chunklength_parser_)
        this->chunklength_parser_->pre ();

      return true;
    }

    return false;
  }

  bool ChunkLengths_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "chunklength" && ns.empty ())
    {
      if (this->chunklength_parser_)
      {
        this->chunklength_parser_->post_ChunkLength_t ();
        this->chunklength ();
      }

      return true;
    }

    return false;
  }

  // LanesVector_t_pskel
  //

  void LanesVector_t_pskel::
  laneID (const ::std::string&)
  {
  }

  void LanesVector_t_pskel::
  post_LanesVector_t ()
  {
  }

  bool LanesVector_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "laneID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->laneID_parser_;

      if (this->laneID_parser_)
        this->laneID_parser_->pre ();

      return true;
    }

    return false;
  }

  bool LanesVector_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "laneID" && ns.empty ())
    {
      if (this->laneID_parser_)
        this->laneID (this->laneID_parser_->post_string ());

      return true;
    }

    return false;
  }

  // EntranceAngle_t_pskel
  //

  void EntranceAngle_t_pskel::
  entranceAngle_ID (unsigned short)
  {
  }

  void EntranceAngle_t_pskel::
  entranceAngle_value (unsigned int)
  {
  }

  void EntranceAngle_t_pskel::
  post_EntranceAngle_t ()
  {
  }

  bool EntranceAngle_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "entranceAngle_ID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->entranceAngle_ID_parser_;

      if (this->entranceAngle_ID_parser_)
        this->entranceAngle_ID_parser_->pre ();

      return true;
    }

    if (n == "entranceAngle_value" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->entranceAngle_value_parser_;

      if (this->entranceAngle_value_parser_)
        this->entranceAngle_value_parser_->pre ();

      return true;
    }

    return false;
  }

  bool EntranceAngle_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "entranceAngle_ID" && ns.empty ())
    {
      if (this->entranceAngle_ID_parser_)
        this->entranceAngle_ID (this->entranceAngle_ID_parser_->post_unsigned_short ());

      return true;
    }

    if (n == "entranceAngle_value" && ns.empty ())
    {
      if (this->entranceAngle_value_parser_)
        this->entranceAngle_value (this->entranceAngle_value_parser_->post_unsigned_int ());

      return true;
    }

    return false;
  }

  // EntranceAngles_t_pskel
  //

  void EntranceAngles_t_pskel::
  entranceAngle ()
  {
  }

  void EntranceAngles_t_pskel::
  post_EntranceAngles_t ()
  {
  }

  bool EntranceAngles_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "entranceAngle" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->entranceAngle_parser_;

      if (this->entranceAngle_parser_)
        this->entranceAngle_parser_->pre ();

      return true;
    }

    return false;
  }

  bool EntranceAngles_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "entranceAngle" && ns.empty ())
    {
      if (this->entranceAngle_parser_)
      {
        this->entranceAngle_parser_->post_EntranceAngle_t ();
        this->entranceAngle ();
      }

      return true;
    }

    return false;
  }

  // UniNode_t_pskel
  //

  void UniNode_t_pskel::
  nodeID (const ::std::string&)
  {
  }

  void UniNode_t_pskel::
  location (sim_mob::Point2D)
  {
  }

  void UniNode_t_pskel::
  Connectors (std::set<std::pair<std::string,std::string > >)
  {
  }

  bool UniNode_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "nodeID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->nodeID_parser_;

      if (this->nodeID_parser_)
        this->nodeID_parser_->pre ();

      return true;
    }

    if (n == "location" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->location_parser_;

      if (this->location_parser_)
        this->location_parser_->pre ();

      return true;
    }

    if (n == "Connectors" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Connectors_parser_;

      if (this->Connectors_parser_)
        this->Connectors_parser_->pre ();

      return true;
    }

    return false;
  }

  bool UniNode_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "nodeID" && ns.empty ())
    {
      if (this->nodeID_parser_)
        this->nodeID (this->nodeID_parser_->post_string ());

      return true;
    }

    if (n == "location" && ns.empty ())
    {
      if (this->location_parser_)
        this->location (this->location_parser_->post_Point2D_t ());

      return true;
    }

    if (n == "Connectors" && ns.empty ())
    {
      if (this->Connectors_parser_)
        this->Connectors (this->Connectors_parser_->post_connectors_t ());

      return true;
    }

    return false;
  }

  // roundabout_t_pskel
  //

  void roundabout_t_pskel::
  nodeID (const ::std::string&)
  {
  }

  void roundabout_t_pskel::
  location (sim_mob::Point2D)
  {
  }

  void roundabout_t_pskel::
  roadSegmentsAt (std::set<std::string>)
  {
  }

  void roundabout_t_pskel::
  Connectors (const std::map<std::string,std::set<std::pair<std::string,std::string> > >&)
  {
  }

  void roundabout_t_pskel::
  ChunkLengths ()
  {
  }

  void roundabout_t_pskel::
  Offsets ()
  {
  }

  void roundabout_t_pskel::
  Separators ()
  {
  }

  void roundabout_t_pskel::
  addDominantLane ()
  {
  }

  void roundabout_t_pskel::
  roundaboutDominantIslands (float)
  {
  }

  void roundabout_t_pskel::
  roundaboutNumberOfLanes (int)
  {
  }

  void roundabout_t_pskel::
  entranceAngles ()
  {
  }

  bool roundabout_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "nodeID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->nodeID_parser_;

      if (this->nodeID_parser_)
        this->nodeID_parser_->pre ();

      return true;
    }

    if (n == "location" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->location_parser_;

      if (this->location_parser_)
        this->location_parser_->pre ();

      return true;
    }

    if (n == "roadSegmentsAt" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->roadSegmentsAt_parser_;

      if (this->roadSegmentsAt_parser_)
        this->roadSegmentsAt_parser_->pre ();

      return true;
    }

    if (n == "Connectors" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Connectors_parser_;

      if (this->Connectors_parser_)
        this->Connectors_parser_->pre ();

      return true;
    }

    if (n == "ChunkLengths" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->ChunkLengths_parser_;

      if (this->ChunkLengths_parser_)
        this->ChunkLengths_parser_->pre ();

      return true;
    }

    if (n == "Offsets" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Offsets_parser_;

      if (this->Offsets_parser_)
        this->Offsets_parser_->pre ();

      return true;
    }

    if (n == "Separators" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Separators_parser_;

      if (this->Separators_parser_)
        this->Separators_parser_->pre ();

      return true;
    }

    if (n == "addDominantLane" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->addDominantLane_parser_;

      if (this->addDominantLane_parser_)
        this->addDominantLane_parser_->pre ();

      return true;
    }

    if (n == "roundaboutDominantIslands" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->roundaboutDominantIslands_parser_;

      if (this->roundaboutDominantIslands_parser_)
        this->roundaboutDominantIslands_parser_->pre ();

      return true;
    }

    if (n == "roundaboutNumberOfLanes" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->roundaboutNumberOfLanes_parser_;

      if (this->roundaboutNumberOfLanes_parser_)
        this->roundaboutNumberOfLanes_parser_->pre ();

      return true;
    }

    if (n == "entranceAngles" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->entranceAngles_parser_;

      if (this->entranceAngles_parser_)
        this->entranceAngles_parser_->pre ();

      return true;
    }

    return false;
  }

  bool roundabout_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "nodeID" && ns.empty ())
    {
      if (this->nodeID_parser_)
        this->nodeID (this->nodeID_parser_->post_string ());

      return true;
    }

    if (n == "location" && ns.empty ())
    {
      if (this->location_parser_)
        this->location (this->location_parser_->post_Point2D_t ());

      return true;
    }

    if (n == "roadSegmentsAt" && ns.empty ())
    {
      if (this->roadSegmentsAt_parser_)
        this->roadSegmentsAt (this->roadSegmentsAt_parser_->post_RoadSegmentsAt_t ());

      return true;
    }

    if (n == "Connectors" && ns.empty ())
    {
      if (this->Connectors_parser_)
        this->Connectors (this->Connectors_parser_->post_Multi_Connectors_t ());

      return true;
    }

    if (n == "ChunkLengths" && ns.empty ())
    {
      if (this->ChunkLengths_parser_)
      {
        this->ChunkLengths_parser_->post_ChunkLengths_t ();
        this->ChunkLengths ();
      }

      return true;
    }

    if (n == "Offsets" && ns.empty ())
    {
      if (this->Offsets_parser_)
      {
        this->Offsets_parser_->post_offsets_t ();
        this->Offsets ();
      }

      return true;
    }

    if (n == "Separators" && ns.empty ())
    {
      if (this->Separators_parser_)
      {
        this->Separators_parser_->post_separators_t ();
        this->Separators ();
      }

      return true;
    }

    if (n == "addDominantLane" && ns.empty ())
    {
      if (this->addDominantLane_parser_)
      {
        this->addDominantLane_parser_->post_LanesVector_t ();
        this->addDominantLane ();
      }

      return true;
    }

    if (n == "roundaboutDominantIslands" && ns.empty ())
    {
      if (this->roundaboutDominantIslands_parser_)
        this->roundaboutDominantIslands (this->roundaboutDominantIslands_parser_->post_float ());

      return true;
    }

    if (n == "roundaboutNumberOfLanes" && ns.empty ())
    {
      if (this->roundaboutNumberOfLanes_parser_)
        this->roundaboutNumberOfLanes (this->roundaboutNumberOfLanes_parser_->post_int ());

      return true;
    }

    if (n == "entranceAngles" && ns.empty ())
    {
      if (this->entranceAngles_parser_)
      {
        this->entranceAngles_parser_->post_EntranceAngles_t ();
        this->entranceAngles ();
      }

      return true;
    }

    return false;
  }

  // intersection_t_pskel
  //

  void intersection_t_pskel::
  nodeID (const ::std::string&)
  {
  }

  void intersection_t_pskel::
  location (sim_mob::Point2D)
  {
  }

  void intersection_t_pskel::
  roadSegmentsAt (std::set<std::string>)
  {
  }

  void intersection_t_pskel::
  Connectors (const std::map<std::string,std::set<std::pair<std::string,std::string> > >&)
  {
  }

  void intersection_t_pskel::
  ChunkLengths ()
  {
  }

  void intersection_t_pskel::
  Offsets ()
  {
  }

  void intersection_t_pskel::
  Separators ()
  {
  }

  void intersection_t_pskel::
  additionalDominantLanes ()
  {
  }

  void intersection_t_pskel::
  additionalSubdominantLanes ()
  {
  }

  void intersection_t_pskel::
  domainIslands ()
  {
  }

  bool intersection_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "nodeID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->nodeID_parser_;

      if (this->nodeID_parser_)
        this->nodeID_parser_->pre ();

      return true;
    }

    if (n == "location" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->location_parser_;

      if (this->location_parser_)
        this->location_parser_->pre ();

      return true;
    }

    if (n == "roadSegmentsAt" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->roadSegmentsAt_parser_;

      if (this->roadSegmentsAt_parser_)
        this->roadSegmentsAt_parser_->pre ();

      return true;
    }

    if (n == "Connectors" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Connectors_parser_;

      if (this->Connectors_parser_)
        this->Connectors_parser_->pre ();

      return true;
    }

    if (n == "ChunkLengths" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->ChunkLengths_parser_;

      if (this->ChunkLengths_parser_)
        this->ChunkLengths_parser_->pre ();

      return true;
    }

    if (n == "Offsets" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Offsets_parser_;

      if (this->Offsets_parser_)
        this->Offsets_parser_->pre ();

      return true;
    }

    if (n == "Separators" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Separators_parser_;

      if (this->Separators_parser_)
        this->Separators_parser_->pre ();

      return true;
    }

    if (n == "additionalDominantLanes" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->additionalDominantLanes_parser_;

      if (this->additionalDominantLanes_parser_)
        this->additionalDominantLanes_parser_->pre ();

      return true;
    }

    if (n == "additionalSubdominantLanes" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->additionalSubdominantLanes_parser_;

      if (this->additionalSubdominantLanes_parser_)
        this->additionalSubdominantLanes_parser_->pre ();

      return true;
    }

    if (n == "domainIslands" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->domainIslands_parser_;

      if (this->domainIslands_parser_)
        this->domainIslands_parser_->pre ();

      return true;
    }

    return false;
  }

  bool intersection_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "nodeID" && ns.empty ())
    {
      if (this->nodeID_parser_)
        this->nodeID (this->nodeID_parser_->post_string ());

      return true;
    }

    if (n == "location" && ns.empty ())
    {
      if (this->location_parser_)
        this->location (this->location_parser_->post_Point2D_t ());

      return true;
    }

    if (n == "roadSegmentsAt" && ns.empty ())
    {
      if (this->roadSegmentsAt_parser_)
        this->roadSegmentsAt (this->roadSegmentsAt_parser_->post_RoadSegmentsAt_t ());

      return true;
    }

    if (n == "Connectors" && ns.empty ())
    {
      if (this->Connectors_parser_)
        this->Connectors (this->Connectors_parser_->post_Multi_Connectors_t ());

      return true;
    }

    if (n == "ChunkLengths" && ns.empty ())
    {
      if (this->ChunkLengths_parser_)
      {
        this->ChunkLengths_parser_->post_ChunkLengths_t ();
        this->ChunkLengths ();
      }

      return true;
    }

    if (n == "Offsets" && ns.empty ())
    {
      if (this->Offsets_parser_)
      {
        this->Offsets_parser_->post_offsets_t ();
        this->Offsets ();
      }

      return true;
    }

    if (n == "Separators" && ns.empty ())
    {
      if (this->Separators_parser_)
      {
        this->Separators_parser_->post_separators_t ();
        this->Separators ();
      }

      return true;
    }

    if (n == "additionalDominantLanes" && ns.empty ())
    {
      if (this->additionalDominantLanes_parser_)
      {
        this->additionalDominantLanes_parser_->post_LanesVector_t ();
        this->additionalDominantLanes ();
      }

      return true;
    }

    if (n == "additionalSubdominantLanes" && ns.empty ())
    {
      if (this->additionalSubdominantLanes_parser_)
      {
        this->additionalSubdominantLanes_parser_->post_LanesVector_t ();
        this->additionalSubdominantLanes ();
      }

      return true;
    }

    if (n == "domainIslands" && ns.empty ())
    {
      if (this->domainIslands_parser_)
      {
        this->domainIslands_parser_->post_DomainIslands_t ();
        this->domainIslands ();
      }

      return true;
    }

    return false;
  }

  // RoadItem_No_Attr_t_pskel
  //

  void RoadItem_No_Attr_t_pskel::
  start (sim_mob::Point2D)
  {
  }

  void RoadItem_No_Attr_t_pskel::
  end (sim_mob::Point2D)
  {
  }

  void RoadItem_No_Attr_t_pskel::
  post_RoadItem_No_Attr_t ()
  {
  }

  bool RoadItem_No_Attr_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "start" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->start_parser_;

      if (this->start_parser_)
        this->start_parser_->pre ();

      return true;
    }

    if (n == "end" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->end_parser_;

      if (this->end_parser_)
        this->end_parser_->pre ();

      return true;
    }

    return false;
  }

  bool RoadItem_No_Attr_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "start" && ns.empty ())
    {
      if (this->start_parser_)
        this->start (this->start_parser_->post_Point2D_t ());

      return true;
    }

    if (n == "end" && ns.empty ())
    {
      if (this->end_parser_)
        this->end (this->end_parser_->post_Point2D_t ());

      return true;
    }

    return false;
  }

  // RoadItem_t_pskel
  //

  void RoadItem_t_pskel::
  Offset (unsigned short)
  {
  }

  void RoadItem_t_pskel::
  start (sim_mob::Point2D)
  {
  }

  void RoadItem_t_pskel::
  end (sim_mob::Point2D)
  {
  }

  bool RoadItem_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "Offset" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Offset_parser_;

      if (this->Offset_parser_)
        this->Offset_parser_->pre ();

      return true;
    }

    if (n == "start" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->start_parser_;

      if (this->start_parser_)
        this->start_parser_->pre ();

      return true;
    }

    if (n == "end" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->end_parser_;

      if (this->end_parser_)
        this->end_parser_->pre ();

      return true;
    }

    return false;
  }

  bool RoadItem_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "Offset" && ns.empty ())
    {
      if (this->Offset_parser_)
        this->Offset (this->Offset_parser_->post_unsigned_short ());

      return true;
    }

    if (n == "start" && ns.empty ())
    {
      if (this->start_parser_)
        this->start (this->start_parser_->post_Point2D_t ());

      return true;
    }

    if (n == "end" && ns.empty ())
    {
      if (this->end_parser_)
        this->end (this->end_parser_->post_Point2D_t ());

      return true;
    }

    return false;
  }

  // BusStop_t_pskel
  //

  void BusStop_t_pskel::
  busStopID (const ::std::string&)
  {
  }

  void BusStop_t_pskel::
  lane_location (const ::std::string&)
  {
  }

  void BusStop_t_pskel::
  is_Terminal (bool)
  {
  }

  void BusStop_t_pskel::
  is_Bay (bool)
  {
  }

  void BusStop_t_pskel::
  has_shelter (bool)
  {
  }

  void BusStop_t_pskel::
  busCapacityAsLength (unsigned int)
  {
  }

  void BusStop_t_pskel::
  post_BusStop_t ()
  {
  }

  bool BusStop_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::geo::RoadItem_t_pskel::_start_element_impl (ns, n, t))
      return true;

    if (n == "busStopID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->busStopID_parser_;

      if (this->busStopID_parser_)
        this->busStopID_parser_->pre ();

      return true;
    }

    if (n == "lane_location" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->lane_location_parser_;

      if (this->lane_location_parser_)
        this->lane_location_parser_->pre ();

      return true;
    }

    if (n == "is_Terminal" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->is_Terminal_parser_;

      if (this->is_Terminal_parser_)
        this->is_Terminal_parser_->pre ();

      return true;
    }

    if (n == "is_Bay" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->is_Bay_parser_;

      if (this->is_Bay_parser_)
        this->is_Bay_parser_->pre ();

      return true;
    }

    if (n == "has_shelter" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->has_shelter_parser_;

      if (this->has_shelter_parser_)
        this->has_shelter_parser_->pre ();

      return true;
    }

    if (n == "busCapacityAsLength" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->busCapacityAsLength_parser_;

      if (this->busCapacityAsLength_parser_)
        this->busCapacityAsLength_parser_->pre ();

      return true;
    }

    return false;
  }

  bool BusStop_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::geo::RoadItem_t_pskel::_end_element_impl (ns, n))
      return true;

    if (n == "busStopID" && ns.empty ())
    {
      if (this->busStopID_parser_)
        this->busStopID (this->busStopID_parser_->post_string ());

      return true;
    }

    if (n == "lane_location" && ns.empty ())
    {
      if (this->lane_location_parser_)
        this->lane_location (this->lane_location_parser_->post_string ());

      return true;
    }

    if (n == "is_Terminal" && ns.empty ())
    {
      if (this->is_Terminal_parser_)
        this->is_Terminal (this->is_Terminal_parser_->post_boolean ());

      return true;
    }

    if (n == "is_Bay" && ns.empty ())
    {
      if (this->is_Bay_parser_)
        this->is_Bay (this->is_Bay_parser_->post_boolean ());

      return true;
    }

    if (n == "has_shelter" && ns.empty ())
    {
      if (this->has_shelter_parser_)
        this->has_shelter (this->has_shelter_parser_->post_boolean ());

      return true;
    }

    if (n == "busCapacityAsLength" && ns.empty ())
    {
      if (this->busCapacityAsLength_parser_)
        this->busCapacityAsLength (this->busCapacityAsLength_parser_->post_unsigned_int ());

      return true;
    }

    return false;
  }

  // ERP_Gantry_t_pskel
  //

  void ERP_Gantry_t_pskel::
  ERP_GantryID (const ::std::string&)
  {
  }

  void ERP_Gantry_t_pskel::
  post_ERP_Gantry_t ()
  {
  }

  bool ERP_Gantry_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::geo::RoadItem_t_pskel::_start_element_impl (ns, n, t))
      return true;

    if (n == "ERP_GantryID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->ERP_GantryID_parser_;

      if (this->ERP_GantryID_parser_)
        this->ERP_GantryID_parser_->pre ();

      return true;
    }

    return false;
  }

  bool ERP_Gantry_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::geo::RoadItem_t_pskel::_end_element_impl (ns, n))
      return true;

    if (n == "ERP_GantryID" && ns.empty ())
    {
      if (this->ERP_GantryID_parser_)
        this->ERP_GantryID (this->ERP_GantryID_parser_->post_string ());

      return true;
    }

    return false;
  }

  // FormType_pskel
  //

  void FormType_pskel::
  TextBox (int)
  {
  }

  void FormType_pskel::
  TextArea (int)
  {
  }

  void FormType_pskel::
  Header (int)
  {
  }

  void FormType_pskel::
  post_FormType ()
  {
  }

  bool FormType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "TextBox" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->TextBox_parser_;

      if (this->TextBox_parser_)
        this->TextBox_parser_->pre ();

      return true;
    }

    if (n == "TextArea" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->TextArea_parser_;

      if (this->TextArea_parser_)
        this->TextArea_parser_->pre ();

      return true;
    }

    if (n == "Header" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Header_parser_;

      if (this->Header_parser_)
        this->Header_parser_->pre ();

      return true;
    }

    return false;
  }

  bool FormType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "TextBox" && ns.empty ())
    {
      if (this->TextBox_parser_)
        this->TextBox (this->TextBox_parser_->post_int ());

      return true;
    }

    if (n == "TextArea" && ns.empty ())
    {
      if (this->TextArea_parser_)
        this->TextArea (this->TextArea_parser_->post_int ());

      return true;
    }

    if (n == "Header" && ns.empty ())
    {
      if (this->Header_parser_)
        this->Header (this->Header_parser_->post_int ());

      return true;
    }

    return false;
  }

  // PointPair_t_pskel
  //

  void PointPair_t_pskel::
  first (sim_mob::Point2D)
  {
  }

  void PointPair_t_pskel::
  second (sim_mob::Point2D)
  {
  }

  bool PointPair_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "first" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->first_parser_;

      if (this->first_parser_)
        this->first_parser_->pre ();

      return true;
    }

    if (n == "second" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->second_parser_;

      if (this->second_parser_)
        this->second_parser_->pre ();

      return true;
    }

    return false;
  }

  bool PointPair_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "first" && ns.empty ())
    {
      if (this->first_parser_)
        this->first (this->first_parser_->post_Point2D_t ());

      return true;
    }

    if (n == "second" && ns.empty ())
    {
      if (this->second_parser_)
        this->second (this->second_parser_->post_Point2D_t ());

      return true;
    }

    return false;
  }

  // crossing_t_pskel
  //

  void crossing_t_pskel::
  crossingID (const ::std::string&)
  {
  }

  void crossing_t_pskel::
  nearLine (std::pair<sim_mob::Point2D,sim_mob::Point2D>)
  {
  }

  void crossing_t_pskel::
  farLine (std::pair<sim_mob::Point2D,sim_mob::Point2D>)
  {
  }

  bool crossing_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::geo::RoadItem_t_pskel::_start_element_impl (ns, n, t))
      return true;

    if (n == "crossingID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->crossingID_parser_;

      if (this->crossingID_parser_)
        this->crossingID_parser_->pre ();

      return true;
    }

    if (n == "nearLine" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->nearLine_parser_;

      if (this->nearLine_parser_)
        this->nearLine_parser_->pre ();

      return true;
    }

    if (n == "farLine" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->farLine_parser_;

      if (this->farLine_parser_)
        this->farLine_parser_->pre ();

      return true;
    }

    return false;
  }

  bool crossing_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::geo::RoadItem_t_pskel::_end_element_impl (ns, n))
      return true;

    if (n == "crossingID" && ns.empty ())
    {
      if (this->crossingID_parser_)
        this->crossingID (this->crossingID_parser_->post_string ());

      return true;
    }

    if (n == "nearLine" && ns.empty ())
    {
      if (this->nearLine_parser_)
        this->nearLine (this->nearLine_parser_->post_PointPair_t ());

      return true;
    }

    if (n == "farLine" && ns.empty ())
    {
      if (this->farLine_parser_)
        this->farLine (this->farLine_parser_->post_PointPair_t ());

      return true;
    }

    return false;
  }

  // RoadBump_t_pskel
  //

  void RoadBump_t_pskel::
  roadBumpID (const ::std::string&)
  {
  }

  void RoadBump_t_pskel::
  segmentID (const ::std::string&)
  {
  }

  void RoadBump_t_pskel::
  post_RoadBump_t ()
  {
  }

  bool RoadBump_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::geo::RoadItem_t_pskel::_start_element_impl (ns, n, t))
      return true;

    if (n == "roadBumpID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->roadBumpID_parser_;

      if (this->roadBumpID_parser_)
        this->roadBumpID_parser_->pre ();

      return true;
    }

    if (n == "segmentID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->segmentID_parser_;

      if (this->segmentID_parser_)
        this->segmentID_parser_->pre ();

      return true;
    }

    return false;
  }

  bool RoadBump_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::geo::RoadItem_t_pskel::_end_element_impl (ns, n))
      return true;

    if (n == "roadBumpID" && ns.empty ())
    {
      if (this->roadBumpID_parser_)
        this->roadBumpID (this->roadBumpID_parser_->post_string ());

      return true;
    }

    if (n == "segmentID" && ns.empty ())
    {
      if (this->segmentID_parser_)
        this->segmentID (this->segmentID_parser_->post_string ());

      return true;
    }

    return false;
  }

  // RoadNetwork_t_pskel
  //

  void RoadNetwork_t_pskel::
  Nodes ()
  {
  }

  void RoadNetwork_t_pskel::
  Links (std::vector<sim_mob::Link*>)
  {
  }

  void RoadNetwork_t_pskel::
  post_RoadNetwork_t ()
  {
  }

  bool RoadNetwork_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "Nodes" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Nodes_parser_;

      if (this->Nodes_parser_)
        this->Nodes_parser_->pre ();

      return true;
    }

    if (n == "Links" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Links_parser_;

      if (this->Links_parser_)
        this->Links_parser_->pre ();

      return true;
    }

    return false;
  }

  bool RoadNetwork_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "Nodes" && ns.empty ())
    {
      if (this->Nodes_parser_)
      {
        this->Nodes_parser_->post_Nodes ();
        this->Nodes ();
      }

      return true;
    }

    if (n == "Links" && ns.empty ())
    {
      if (this->Links_parser_)
        this->Links (this->Links_parser_->post_Links ());

      return true;
    }

    return false;
  }

  // RoadItems_t_pskel
  //

  void RoadItems_t_pskel::
  BusStop ()
  {
  }

  void RoadItems_t_pskel::
  ERP_Gantry ()
  {
  }

  void RoadItems_t_pskel::
  Crossing (sim_mob::Crossing*)
  {
  }

  void RoadItems_t_pskel::
  RoadBump ()
  {
  }

  bool RoadItems_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "BusStop" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->BusStop_parser_;

      if (this->BusStop_parser_)
        this->BusStop_parser_->pre ();

      return true;
    }

    if (n == "ERP_Gantry" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->ERP_Gantry_parser_;

      if (this->ERP_Gantry_parser_)
        this->ERP_Gantry_parser_->pre ();

      return true;
    }

    if (n == "Crossing" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Crossing_parser_;

      if (this->Crossing_parser_)
        this->Crossing_parser_->pre ();

      return true;
    }

    if (n == "RoadBump" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->RoadBump_parser_;

      if (this->RoadBump_parser_)
        this->RoadBump_parser_->pre ();

      return true;
    }

    return false;
  }

  bool RoadItems_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "BusStop" && ns.empty ())
    {
      if (this->BusStop_parser_)
      {
        this->BusStop_parser_->post_BusStop_t ();
        this->BusStop ();
      }

      return true;
    }

    if (n == "ERP_Gantry" && ns.empty ())
    {
      if (this->ERP_Gantry_parser_)
      {
        this->ERP_Gantry_parser_->post_ERP_Gantry_t ();
        this->ERP_Gantry ();
      }

      return true;
    }

    if (n == "Crossing" && ns.empty ())
    {
      if (this->Crossing_parser_)
        this->Crossing (this->Crossing_parser_->post_crossing_t ());

      return true;
    }

    if (n == "RoadBump" && ns.empty ())
    {
      if (this->RoadBump_parser_)
      {
        this->RoadBump_parser_->post_RoadBump_t ();
        this->RoadBump ();
      }

      return true;
    }

    return false;
  }

  // DailyTime_t_pskel
  //

  void DailyTime_t_pskel::
  timeValue (unsigned int)
  {
  }

  void DailyTime_t_pskel::
  base (unsigned int)
  {
  }

  bool DailyTime_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "timeValue" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->timeValue_parser_;

      if (this->timeValue_parser_)
        this->timeValue_parser_->pre ();

      return true;
    }

    if (n == "base" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->base_parser_;

      if (this->base_parser_)
        this->base_parser_->pre ();

      return true;
    }

    return false;
  }

  bool DailyTime_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "timeValue" && ns.empty ())
    {
      if (this->timeValue_parser_)
        this->timeValue (this->timeValue_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "base" && ns.empty ())
    {
      if (this->base_parser_)
        this->base (this->base_parser_->post_unsigned_int ());

      return true;
    }

    return false;
  }

  // TripChainItemType_pskel
  //

  void TripChainItemType_pskel::
  post_TripChainItemType ()
  {
  }

  // TripChainItemLocationType_pskel
  //

  void TripChainItemLocationType_pskel::
  post_TripChainItemLocationType ()
  {
  }

  // SubTrip_t_pskel
  //

  void SubTrip_t_pskel::
  parentTrip (const ::std::string&)
  {
  }

  void SubTrip_t_pskel::
  mode (const ::std::string&)
  {
  }

  void SubTrip_t_pskel::
  isPrimaryMode (bool)
  {
  }

  void SubTrip_t_pskel::
  ptLineId (const ::std::string&)
  {
  }

  void SubTrip_t_pskel::
  post_SubTrip_t ()
  {
  }

  bool SubTrip_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "parentTrip" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->parentTrip_parser_;

      if (this->parentTrip_parser_)
        this->parentTrip_parser_->pre ();

      return true;
    }

    if (n == "mode" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->mode_parser_;

      if (this->mode_parser_)
        this->mode_parser_->pre ();

      return true;
    }

    if (n == "isPrimaryMode" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->isPrimaryMode_parser_;

      if (this->isPrimaryMode_parser_)
        this->isPrimaryMode_parser_->pre ();

      return true;
    }

    if (n == "ptLineId" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->ptLineId_parser_;

      if (this->ptLineId_parser_)
        this->ptLineId_parser_->pre ();

      return true;
    }

    return false;
  }

  bool SubTrip_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "parentTrip" && ns.empty ())
    {
      if (this->parentTrip_parser_)
        this->parentTrip (this->parentTrip_parser_->post_string ());

      return true;
    }

    if (n == "mode" && ns.empty ())
    {
      if (this->mode_parser_)
        this->mode (this->mode_parser_->post_string ());

      return true;
    }

    if (n == "isPrimaryMode" && ns.empty ())
    {
      if (this->isPrimaryMode_parser_)
        this->isPrimaryMode (this->isPrimaryMode_parser_->post_boolean ());

      return true;
    }

    if (n == "ptLineId" && ns.empty ())
    {
      if (this->ptLineId_parser_)
        this->ptLineId (this->ptLineId_parser_->post_string ());

      return true;
    }

    return false;
  }

  // SubTrips_t_pskel
  //

  void SubTrips_t_pskel::
  SubTrip ()
  {
  }

  void SubTrips_t_pskel::
  post_SubTrips_t ()
  {
  }

  bool SubTrips_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "SubTrip" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->SubTrip_parser_;

      if (this->SubTrip_parser_)
        this->SubTrip_parser_->pre ();

      return true;
    }

    return false;
  }

  bool SubTrips_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "SubTrip" && ns.empty ())
    {
      if (this->SubTrip_parser_)
      {
        this->SubTrip_parser_->post_SubTrip_t ();
        this->SubTrip ();
      }

      return true;
    }

    return false;
  }

  // TripChainItem_t_pskel
  //

  void TripChainItem_t_pskel::
  personID (long long)
  {
  }

  void TripChainItem_t_pskel::
  itemType ()
  {
  }

  void TripChainItem_t_pskel::
  locationType ()
  {
  }

  void TripChainItem_t_pskel::
  startTime (sim_mob::DailyTime)
  {
  }

  void TripChainItem_t_pskel::
  endTime (sim_mob::DailyTime)
  {
  }

  void TripChainItem_t_pskel::
  sequenceNumber (unsigned int)
  {
  }

  void TripChainItem_t_pskel::
  post_TripChainItem_t ()
  {
  }

  bool TripChainItem_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "personID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->personID_parser_;

      if (this->personID_parser_)
        this->personID_parser_->pre ();

      return true;
    }

    if (n == "itemType" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->itemType_parser_;

      if (this->itemType_parser_)
        this->itemType_parser_->pre ();

      return true;
    }

    if (n == "locationType" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->locationType_parser_;

      if (this->locationType_parser_)
        this->locationType_parser_->pre ();

      return true;
    }

    if (n == "startTime" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->startTime_parser_;

      if (this->startTime_parser_)
        this->startTime_parser_->pre ();

      return true;
    }

    if (n == "endTime" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->endTime_parser_;

      if (this->endTime_parser_)
        this->endTime_parser_->pre ();

      return true;
    }

    if (n == "sequenceNumber" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->sequenceNumber_parser_;

      if (this->sequenceNumber_parser_)
        this->sequenceNumber_parser_->pre ();

      return true;
    }

    return false;
  }

  bool TripChainItem_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "personID" && ns.empty ())
    {
      if (this->personID_parser_)
        this->personID (this->personID_parser_->post_integer ());

      return true;
    }

    if (n == "itemType" && ns.empty ())
    {
      if (this->itemType_parser_)
      {
        this->itemType_parser_->post_TripChainItemType ();
        this->itemType ();
      }

      return true;
    }

    if (n == "locationType" && ns.empty ())
    {
      if (this->locationType_parser_)
      {
        this->locationType_parser_->post_TripChainItemLocationType ();
        this->locationType ();
      }

      return true;
    }

    if (n == "startTime" && ns.empty ())
    {
      if (this->startTime_parser_)
        this->startTime (this->startTime_parser_->post_DailyTime_t ());

      return true;
    }

    if (n == "endTime" && ns.empty ())
    {
      if (this->endTime_parser_)
        this->endTime (this->endTime_parser_->post_DailyTime_t ());

      return true;
    }

    if (n == "sequenceNumber" && ns.empty ())
    {
      if (this->sequenceNumber_parser_)
        this->sequenceNumber (this->sequenceNumber_parser_->post_unsigned_int ());

      return true;
    }

    return false;
  }

  // Trip_t_pskel
  //

  void Trip_t_pskel::
  tripId (long long)
  {
  }

  void Trip_t_pskel::
  fromLocation (const ::std::string&)
  {
  }

  void Trip_t_pskel::
  fromLocationType ()
  {
  }

  void Trip_t_pskel::
  toLocation (const ::std::string&)
  {
  }

  void Trip_t_pskel::
  toLocationType ()
  {
  }

  void Trip_t_pskel::
  SubTrips ()
  {
  }

  bool Trip_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::geo::TripChainItem_t_pskel::_start_element_impl (ns, n, t))
      return true;

    if (n == "tripId" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->tripId_parser_;

      if (this->tripId_parser_)
        this->tripId_parser_->pre ();

      return true;
    }

    if (n == "fromLocation" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->fromLocation_parser_;

      if (this->fromLocation_parser_)
        this->fromLocation_parser_->pre ();

      return true;
    }

    if (n == "fromLocationType" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->fromLocationType_parser_;

      if (this->fromLocationType_parser_)
        this->fromLocationType_parser_->pre ();

      return true;
    }

    if (n == "toLocation" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->toLocation_parser_;

      if (this->toLocation_parser_)
        this->toLocation_parser_->pre ();

      return true;
    }

    if (n == "toLocationType" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->toLocationType_parser_;

      if (this->toLocationType_parser_)
        this->toLocationType_parser_->pre ();

      return true;
    }

    if (n == "SubTrips" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->SubTrips_parser_;

      if (this->SubTrips_parser_)
        this->SubTrips_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Trip_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::geo::TripChainItem_t_pskel::_end_element_impl (ns, n))
      return true;

    if (n == "tripId" && ns.empty ())
    {
      if (this->tripId_parser_)
        this->tripId (this->tripId_parser_->post_integer ());

      return true;
    }

    if (n == "fromLocation" && ns.empty ())
    {
      if (this->fromLocation_parser_)
        this->fromLocation (this->fromLocation_parser_->post_string ());

      return true;
    }

    if (n == "fromLocationType" && ns.empty ())
    {
      if (this->fromLocationType_parser_)
      {
        this->fromLocationType_parser_->post_TripChainItemLocationType ();
        this->fromLocationType ();
      }

      return true;
    }

    if (n == "toLocation" && ns.empty ())
    {
      if (this->toLocation_parser_)
        this->toLocation (this->toLocation_parser_->post_string ());

      return true;
    }

    if (n == "toLocationType" && ns.empty ())
    {
      if (this->toLocationType_parser_)
      {
        this->toLocationType_parser_->post_TripChainItemLocationType ();
        this->toLocationType ();
      }

      return true;
    }

    if (n == "SubTrips" && ns.empty ())
    {
      if (this->SubTrips_parser_)
      {
        this->SubTrips_parser_->post_SubTrips_t ();
        this->SubTrips ();
      }

      return true;
    }

    return false;
  }

  // Activity_t_pskel
  //

  void Activity_t_pskel::
  activityId (long long)
  {
  }

  bool Activity_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::geo::TripChainItem_t_pskel::_start_element_impl (ns, n, t))
      return true;

    if (n == "activityId" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->activityId_parser_;

      if (this->activityId_parser_)
        this->activityId_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Activity_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::geo::TripChainItem_t_pskel::_end_element_impl (ns, n))
      return true;

    if (n == "activityId" && ns.empty ())
    {
      if (this->activityId_parser_)
        this->activityId (this->activityId_parser_->post_integer ());

      return true;
    }

    return false;
  }

  // TripChain_t_pskel
  //

  void TripChain_t_pskel::
  Trip (sim_mob::TripChainItem*)
  {
  }

  void TripChain_t_pskel::
  Activity (sim_mob::TripChainItem*)
  {
  }

  bool TripChain_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "Trip" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Trip_parser_;

      if (this->Trip_parser_)
        this->Trip_parser_->pre ();

      return true;
    }

    if (n == "Activity" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Activity_parser_;

      if (this->Activity_parser_)
        this->Activity_parser_->pre ();

      return true;
    }

    return false;
  }

  bool TripChain_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "Trip" && ns.empty ())
    {
      if (this->Trip_parser_)
        this->Trip (this->Trip_parser_->post_Trip_t ());

      return true;
    }

    if (n == "Activity" && ns.empty ())
    {
      if (this->Activity_parser_)
        this->Activity (this->Activity_parser_->post_Activity_t ());

      return true;
    }

    return false;
  }

  // TripChains_t_pskel
  //

  void TripChains_t_pskel::
  TripChain (sim_mob::TripChainItem*)
  {
  }

  void TripChains_t_pskel::
  post_TripChains_t ()
  {
  }

  bool TripChains_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "TripChain" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->TripChain_parser_;

      if (this->TripChain_parser_)
        this->TripChain_parser_->pre ();

      return true;
    }

    return false;
  }

  bool TripChains_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "TripChain" && ns.empty ())
    {
      if (this->TripChain_parser_)
        this->TripChain (this->TripChain_parser_->post_TripChain_t ());

      return true;
    }

    return false;
  }

  // GeoSpatial_t_pskel
  //

  void GeoSpatial_t_pskel::
  RoadNetwork ()
  {
  }

  void GeoSpatial_t_pskel::
  post_GeoSpatial_t ()
  {
  }

  bool GeoSpatial_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "RoadNetwork" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->RoadNetwork_parser_;

      if (this->RoadNetwork_parser_)
        this->RoadNetwork_parser_->pre ();

      return true;
    }

    return false;
  }

  bool GeoSpatial_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "RoadNetwork" && ns.empty ())
    {
      if (this->RoadNetwork_parser_)
      {
        this->RoadNetwork_parser_->post_RoadNetwork_t ();
        this->RoadNetwork ();
      }

      return true;
    }

    return false;
  }

  // SimMobility_t_pskel
  //

  void SimMobility_t_pskel::
  GeoSpatial ()
  {
  }

  void SimMobility_t_pskel::
  TripChains ()
  {
  }

  void SimMobility_t_pskel::
  post_SimMobility_t ()
  {
  }

  bool SimMobility_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "GeoSpatial" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->GeoSpatial_parser_;

      if (this->GeoSpatial_parser_)
        this->GeoSpatial_parser_->pre ();

      return true;
    }

    if (n == "TripChains" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->TripChains_parser_;

      if (this->TripChains_parser_)
        this->TripChains_parser_->pre ();

      return true;
    }

    return false;
  }

  bool SimMobility_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "GeoSpatial" && ns.empty ())
    {
      if (this->GeoSpatial_parser_)
      {
        this->GeoSpatial_parser_->post_GeoSpatial_t ();
        this->GeoSpatial ();
      }

      return true;
    }

    if (n == "TripChains" && ns.empty ())
    {
      if (this->TripChains_parser_)
      {
        this->TripChains_parser_->post_TripChains_t ();
        this->TripChains ();
      }

      return true;
    }

    return false;
  }

  // Lanes_pskel
  //

  void Lanes_pskel::
  Lane (sim_mob::Lane*)
  {
  }

  bool Lanes_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "Lane" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Lane_parser_;

      if (this->Lane_parser_)
        this->Lane_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Lanes_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "Lane" && ns.empty ())
    {
      if (this->Lane_parser_)
        this->Lane (this->Lane_parser_->post_lane_t ());

      return true;
    }

    return false;
  }

  // Segments_pskel
  //

  void Segments_pskel::
  FWDSegments (std::vector<sim_mob::RoadSegment*>)
  {
  }

  void Segments_pskel::
  BKDSegments (std::vector<sim_mob::RoadSegment*>)
  {
  }

  bool Segments_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "FWDSegments" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->FWDSegments_parser_;

      if (this->FWDSegments_parser_)
        this->FWDSegments_parser_->pre ();

      return true;
    }

    if (n == "BKDSegments" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->BKDSegments_parser_;

      if (this->BKDSegments_parser_)
        this->BKDSegments_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Segments_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "FWDSegments" && ns.empty ())
    {
      if (this->FWDSegments_parser_)
        this->FWDSegments (this->FWDSegments_parser_->post_fwdBckSegments_t ());

      return true;
    }

    if (n == "BKDSegments" && ns.empty ())
    {
      if (this->BKDSegments_parser_)
        this->BKDSegments (this->BKDSegments_parser_->post_fwdBckSegments_t ());

      return true;
    }

    return false;
  }

  // Nodes_pskel
  //

  void Nodes_pskel::
  UniNodes (std::set<sim_mob::UniNode*>&)
  {
  }

  void Nodes_pskel::
  Intersections (std::vector<sim_mob::MultiNode*>&)
  {
  }

  void Nodes_pskel::
  roundabouts (std::vector<sim_mob::MultiNode*>&)
  {
  }

  void Nodes_pskel::
  post_Nodes ()
  {
  }

  bool Nodes_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "UniNodes" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->UniNodes_parser_;

      if (this->UniNodes_parser_)
        this->UniNodes_parser_->pre ();

      return true;
    }

    if (n == "Intersections" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Intersections_parser_;

      if (this->Intersections_parser_)
        this->Intersections_parser_->pre ();

      return true;
    }

    if (n == "roundabouts" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->roundabouts_parser_;

      if (this->roundabouts_parser_)
        this->roundabouts_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Nodes_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "UniNodes" && ns.empty ())
    {
      if (this->UniNodes_parser_)
        this->UniNodes (this->UniNodes_parser_->post_UniNodes ());

      return true;
    }

    if (n == "Intersections" && ns.empty ())
    {
      if (this->Intersections_parser_)
        this->Intersections (this->Intersections_parser_->post_Intersections ());

      return true;
    }

    if (n == "roundabouts" && ns.empty ())
    {
      if (this->roundabouts_parser_)
        this->roundabouts (this->roundabouts_parser_->post_roundabouts ());

      return true;
    }

    return false;
  }

  // Links_pskel
  //

  void Links_pskel::
  Link (sim_mob::Link*)
  {
  }

  bool Links_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "Link" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Link_parser_;

      if (this->Link_parser_)
        this->Link_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Links_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "Link" && ns.empty ())
    {
      if (this->Link_parser_)
        this->Link (this->Link_parser_->post_link_t ());

      return true;
    }

    return false;
  }

  // UniNodes_pskel
  //

  void UniNodes_pskel::
  UniNode (sim_mob::UniNode*)
  {
  }

  bool UniNodes_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "UniNode" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->UniNode_parser_;

      if (this->UniNode_parser_)
        this->UniNode_parser_->pre ();

      return true;
    }

    return false;
  }

  bool UniNodes_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "UniNode" && ns.empty ())
    {
      if (this->UniNode_parser_)
        this->UniNode (this->UniNode_parser_->post_UniNode_t ());

      return true;
    }

    return false;
  }

  // Intersections_pskel
  //

  void Intersections_pskel::
  Intersection (sim_mob::MultiNode*)
  {
  }

  bool Intersections_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "Intersection" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Intersection_parser_;

      if (this->Intersection_parser_)
        this->Intersection_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Intersections_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "Intersection" && ns.empty ())
    {
      if (this->Intersection_parser_)
        this->Intersection (this->Intersection_parser_->post_intersection_t ());

      return true;
    }

    return false;
  }

  // roundabouts_pskel
  //

  void roundabouts_pskel::
  roundabout (sim_mob::MultiNode*)
  {
  }

  bool roundabouts_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "roundabout" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->roundabout_parser_;

      if (this->roundabout_parser_)
        this->roundabout_parser_->pre ();

      return true;
    }

    return false;
  }

  bool roundabouts_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "roundabout" && ns.empty ())
    {
      if (this->roundabout_parser_)
        this->roundabout (this->roundabout_parser_->post_roundabout_t ());

      return true;
    }

    return false;
  }
}

// Begin epilogue.
//
//
// End epilogue.

