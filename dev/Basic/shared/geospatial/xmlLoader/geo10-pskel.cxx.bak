// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "geo10-pskel.hxx"

namespace geo
{
  // Point2D_t_pskel
  //

  void Point2D_t_pskel::
  xPos_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->xPos_parser_ = &p;
  }

  void Point2D_t_pskel::
  yPos_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->yPos_parser_ = &p;
  }

  void Point2D_t_pskel::
  parsers (::xml_schema::unsigned_int_pskel& xPos,
           ::xml_schema::unsigned_int_pskel& yPos)
  {
    this->xPos_parser_ = &xPos;
    this->yPos_parser_ = &yPos;
  }

  Point2D_t_pskel::
  Point2D_t_pskel ()
  : xPos_parser_ (0),
    yPos_parser_ (0)
  {
  }

  // PolyPoint_t_pskel
  //

  void PolyPoint_t_pskel::
  pointID_parser (::xml_schema::string_pskel& p)
  {
    this->pointID_parser_ = &p;
  }

  void PolyPoint_t_pskel::
  location_parser (::geo::Point2D_t_pskel& p)
  {
    this->location_parser_ = &p;
  }

  void PolyPoint_t_pskel::
  parsers (::xml_schema::string_pskel& pointID,
           ::geo::Point2D_t_pskel& location)
  {
    this->pointID_parser_ = &pointID;
    this->location_parser_ = &location;
  }

  PolyPoint_t_pskel::
  PolyPoint_t_pskel ()
  : pointID_parser_ (0),
    location_parser_ (0)
  {
  }

  // PolyLine_t_pskel
  //

  void PolyLine_t_pskel::
  PolyPoint_parser (::geo::PolyPoint_t_pskel& p)
  {
    this->PolyPoint_parser_ = &p;
  }

  void PolyLine_t_pskel::
  parsers (::geo::PolyPoint_t_pskel& PolyPoint)
  {
    this->PolyPoint_parser_ = &PolyPoint;
  }

  PolyLine_t_pskel::
  PolyLine_t_pskel ()
  : PolyPoint_parser_ (0)
  {
  }

  // lane_t_pskel
  //

  void lane_t_pskel::
  laneID_parser (::xml_schema::unsigned_long_pskel& p)
  {
    this->laneID_parser_ = &p;
  }

  void lane_t_pskel::
  width_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->width_parser_ = &p;
  }

  void lane_t_pskel::
  can_go_straight_parser (::xml_schema::boolean_pskel& p)
  {
    this->can_go_straight_parser_ = &p;
  }

  void lane_t_pskel::
  can_turn_left_parser (::xml_schema::boolean_pskel& p)
  {
    this->can_turn_left_parser_ = &p;
  }

  void lane_t_pskel::
  can_turn_right_parser (::xml_schema::boolean_pskel& p)
  {
    this->can_turn_right_parser_ = &p;
  }

  void lane_t_pskel::
  can_turn_on_red_signal_parser (::xml_schema::boolean_pskel& p)
  {
    this->can_turn_on_red_signal_parser_ = &p;
  }

  void lane_t_pskel::
  can_change_lane_left_parser (::xml_schema::boolean_pskel& p)
  {
    this->can_change_lane_left_parser_ = &p;
  }

  void lane_t_pskel::
  can_change_lane_right_parser (::xml_schema::boolean_pskel& p)
  {
    this->can_change_lane_right_parser_ = &p;
  }

  void lane_t_pskel::
  is_road_shoulder_parser (::xml_schema::boolean_pskel& p)
  {
    this->is_road_shoulder_parser_ = &p;
  }

  void lane_t_pskel::
  is_bicycle_lane_parser (::xml_schema::boolean_pskel& p)
  {
    this->is_bicycle_lane_parser_ = &p;
  }

  void lane_t_pskel::
  is_pedestrian_lane_parser (::xml_schema::boolean_pskel& p)
  {
    this->is_pedestrian_lane_parser_ = &p;
  }

  void lane_t_pskel::
  is_vehicle_lane_parser (::xml_schema::boolean_pskel& p)
  {
    this->is_vehicle_lane_parser_ = &p;
  }

  void lane_t_pskel::
  is_standard_bus_lane_parser (::xml_schema::boolean_pskel& p)
  {
    this->is_standard_bus_lane_parser_ = &p;
  }

  void lane_t_pskel::
  is_whole_day_bus_lane_parser (::xml_schema::boolean_pskel& p)
  {
    this->is_whole_day_bus_lane_parser_ = &p;
  }

  void lane_t_pskel::
  is_high_occupancy_vehicle_lane_parser (::xml_schema::boolean_pskel& p)
  {
    this->is_high_occupancy_vehicle_lane_parser_ = &p;
  }

  void lane_t_pskel::
  can_freely_park_here_parser (::xml_schema::boolean_pskel& p)
  {
    this->can_freely_park_here_parser_ = &p;
  }

  void lane_t_pskel::
  can_stop_here_parser (::xml_schema::boolean_pskel& p)
  {
    this->can_stop_here_parser_ = &p;
  }

  void lane_t_pskel::
  is_u_turn_allowed_parser (::xml_schema::boolean_pskel& p)
  {
    this->is_u_turn_allowed_parser_ = &p;
  }

  void lane_t_pskel::
  PolyLine_parser (::geo::PolyLine_t_pskel& p)
  {
    this->PolyLine_parser_ = &p;
  }

  void lane_t_pskel::
  parsers (::xml_schema::unsigned_long_pskel& laneID,
           ::xml_schema::unsigned_int_pskel& width,
           ::xml_schema::boolean_pskel& can_go_straight,
           ::xml_schema::boolean_pskel& can_turn_left,
           ::xml_schema::boolean_pskel& can_turn_right,
           ::xml_schema::boolean_pskel& can_turn_on_red_signal,
           ::xml_schema::boolean_pskel& can_change_lane_left,
           ::xml_schema::boolean_pskel& can_change_lane_right,
           ::xml_schema::boolean_pskel& is_road_shoulder,
           ::xml_schema::boolean_pskel& is_bicycle_lane,
           ::xml_schema::boolean_pskel& is_pedestrian_lane,
           ::xml_schema::boolean_pskel& is_vehicle_lane,
           ::xml_schema::boolean_pskel& is_standard_bus_lane,
           ::xml_schema::boolean_pskel& is_whole_day_bus_lane,
           ::xml_schema::boolean_pskel& is_high_occupancy_vehicle_lane,
           ::xml_schema::boolean_pskel& can_freely_park_here,
           ::xml_schema::boolean_pskel& can_stop_here,
           ::xml_schema::boolean_pskel& is_u_turn_allowed,
           ::geo::PolyLine_t_pskel& PolyLine)
  {
    this->laneID_parser_ = &laneID;
    this->width_parser_ = &width;
    this->can_go_straight_parser_ = &can_go_straight;
    this->can_turn_left_parser_ = &can_turn_left;
    this->can_turn_right_parser_ = &can_turn_right;
    this->can_turn_on_red_signal_parser_ = &can_turn_on_red_signal;
    this->can_change_lane_left_parser_ = &can_change_lane_left;
    this->can_change_lane_right_parser_ = &can_change_lane_right;
    this->is_road_shoulder_parser_ = &is_road_shoulder;
    this->is_bicycle_lane_parser_ = &is_bicycle_lane;
    this->is_pedestrian_lane_parser_ = &is_pedestrian_lane;
    this->is_vehicle_lane_parser_ = &is_vehicle_lane;
    this->is_standard_bus_lane_parser_ = &is_standard_bus_lane;
    this->is_whole_day_bus_lane_parser_ = &is_whole_day_bus_lane;
    this->is_high_occupancy_vehicle_lane_parser_ = &is_high_occupancy_vehicle_lane;
    this->can_freely_park_here_parser_ = &can_freely_park_here;
    this->can_stop_here_parser_ = &can_stop_here;
    this->is_u_turn_allowed_parser_ = &is_u_turn_allowed;
    this->PolyLine_parser_ = &PolyLine;
  }

  lane_t_pskel::
  lane_t_pskel ()
  : laneID_parser_ (0),
    width_parser_ (0),
    can_go_straight_parser_ (0),
    can_turn_left_parser_ (0),
    can_turn_right_parser_ (0),
    can_turn_on_red_signal_parser_ (0),
    can_change_lane_left_parser_ (0),
    can_change_lane_right_parser_ (0),
    is_road_shoulder_parser_ (0),
    is_bicycle_lane_parser_ (0),
    is_pedestrian_lane_parser_ (0),
    is_vehicle_lane_parser_ (0),
    is_standard_bus_lane_parser_ (0),
    is_whole_day_bus_lane_parser_ (0),
    is_high_occupancy_vehicle_lane_parser_ (0),
    can_freely_park_here_parser_ (0),
    can_stop_here_parser_ (0),
    is_u_turn_allowed_parser_ (0),
    PolyLine_parser_ (0)
  {
  }

  // connector_t_pskel
  //

  void connector_t_pskel::
  laneFrom_parser (::xml_schema::unsigned_long_pskel& p)
  {
    this->laneFrom_parser_ = &p;
  }

  void connector_t_pskel::
  laneTo_parser (::xml_schema::unsigned_long_pskel& p)
  {
    this->laneTo_parser_ = &p;
  }

  void connector_t_pskel::
  parsers (::xml_schema::unsigned_long_pskel& laneFrom,
           ::xml_schema::unsigned_long_pskel& laneTo)
  {
    this->laneFrom_parser_ = &laneFrom;
    this->laneTo_parser_ = &laneTo;
  }

  connector_t_pskel::
  connector_t_pskel ()
  : laneFrom_parser_ (0),
    laneTo_parser_ (0)
  {
  }

  // connectors_t_pskel
  //

  void connectors_t_pskel::
  Connector_parser (::geo::connector_t_pskel& p)
  {
    this->Connector_parser_ = &p;
  }

  void connectors_t_pskel::
  parsers (::geo::connector_t_pskel& Connector)
  {
    this->Connector_parser_ = &Connector;
  }

  connectors_t_pskel::
  connectors_t_pskel ()
  : Connector_parser_ (0)
  {
  }

  // Multi_Connector_t_pskel
  //

  void Multi_Connector_t_pskel::
  RoadSegment_parser (::xml_schema::unsigned_long_pskel& p)
  {
    this->RoadSegment_parser_ = &p;
  }

  void Multi_Connector_t_pskel::
  Connectors_parser (::geo::connectors_t_pskel& p)
  {
    this->Connectors_parser_ = &p;
  }

  void Multi_Connector_t_pskel::
  parsers (::xml_schema::unsigned_long_pskel& RoadSegment,
           ::geo::connectors_t_pskel& Connectors)
  {
    this->RoadSegment_parser_ = &RoadSegment;
    this->Connectors_parser_ = &Connectors;
  }

  Multi_Connector_t_pskel::
  Multi_Connector_t_pskel ()
  : RoadSegment_parser_ (0),
    Connectors_parser_ (0)
  {
  }

  // Multi_Connectors_t_pskel
  //

  void Multi_Connectors_t_pskel::
  MultiConnectors_parser (::geo::Multi_Connector_t_pskel& p)
  {
    this->MultiConnectors_parser_ = &p;
  }

  void Multi_Connectors_t_pskel::
  parsers (::geo::Multi_Connector_t_pskel& MultiConnectors)
  {
    this->MultiConnectors_parser_ = &MultiConnectors;
  }

  Multi_Connectors_t_pskel::
  Multi_Connectors_t_pskel ()
  : MultiConnectors_parser_ (0)
  {
  }

  // fwdBckSegments_t_pskel
  //

  void fwdBckSegments_t_pskel::
  Segment_parser (::geo::segment_t_pskel& p)
  {
    this->Segment_parser_ = &p;
  }

  void fwdBckSegments_t_pskel::
  parsers (::geo::segment_t_pskel& Segment)
  {
    this->Segment_parser_ = &Segment;
  }

  fwdBckSegments_t_pskel::
  fwdBckSegments_t_pskel ()
  : Segment_parser_ (0)
  {
  }

  // RoadSegmentsAt_t_pskel
  //

  void RoadSegmentsAt_t_pskel::
  segmentID_parser (::xml_schema::unsigned_long_pskel& p)
  {
    this->segmentID_parser_ = &p;
  }

  void RoadSegmentsAt_t_pskel::
  parsers (::xml_schema::unsigned_long_pskel& segmentID)
  {
    this->segmentID_parser_ = &segmentID;
  }

  RoadSegmentsAt_t_pskel::
  RoadSegmentsAt_t_pskel ()
  : segmentID_parser_ (0)
  {
  }

  // laneEdgePolyline_cached_t_pskel
  //

  void laneEdgePolyline_cached_t_pskel::
  laneNumber_parser (::xml_schema::short_pskel& p)
  {
    this->laneNumber_parser_ = &p;
  }

  void laneEdgePolyline_cached_t_pskel::
  polyline_parser (::geo::PolyLine_t_pskel& p)
  {
    this->polyline_parser_ = &p;
  }

  void laneEdgePolyline_cached_t_pskel::
  parsers (::xml_schema::short_pskel& laneNumber,
           ::geo::PolyLine_t_pskel& polyline)
  {
    this->laneNumber_parser_ = &laneNumber;
    this->polyline_parser_ = &polyline;
  }

  laneEdgePolyline_cached_t_pskel::
  laneEdgePolyline_cached_t_pskel ()
  : laneNumber_parser_ (0),
    polyline_parser_ (0)
  {
  }

  // laneEdgePolylines_cached_t_pskel
  //

  void laneEdgePolylines_cached_t_pskel::
  laneEdgePolyline_cached_parser (::geo::laneEdgePolyline_cached_t_pskel& p)
  {
    this->laneEdgePolyline_cached_parser_ = &p;
  }

  void laneEdgePolylines_cached_t_pskel::
  parsers (::geo::laneEdgePolyline_cached_t_pskel& laneEdgePolyline_cached)
  {
    this->laneEdgePolyline_cached_parser_ = &laneEdgePolyline_cached;
  }

  laneEdgePolylines_cached_t_pskel::
  laneEdgePolylines_cached_t_pskel ()
  : laneEdgePolyline_cached_parser_ (0)
  {
  }

  // segment_t_pskel
  //

  void segment_t_pskel::
  segmentID_parser (::xml_schema::unsigned_long_pskel& p)
  {
    this->segmentID_parser_ = &p;
  }

  void segment_t_pskel::
  startingNode_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->startingNode_parser_ = &p;
  }

  void segment_t_pskel::
  endingNode_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->endingNode_parser_ = &p;
  }

  void segment_t_pskel::
  maxSpeed_parser (::xml_schema::short_pskel& p)
  {
    this->maxSpeed_parser_ = &p;
  }

  void segment_t_pskel::
  Length_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->Length_parser_ = &p;
  }

  void segment_t_pskel::
  Width_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->Width_parser_ = &p;
  }

  void segment_t_pskel::
  originalDB_ID_parser (::xml_schema::string_pskel& p)
  {
    this->originalDB_ID_parser_ = &p;
  }

  void segment_t_pskel::
  polyline_parser (::geo::PolyLine_t_pskel& p)
  {
    this->polyline_parser_ = &p;
  }

  void segment_t_pskel::
  laneEdgePolylines_cached_parser (::geo::laneEdgePolylines_cached_t_pskel& p)
  {
    this->laneEdgePolylines_cached_parser_ = &p;
  }

  void segment_t_pskel::
  Lanes_parser (::geo::Lanes_pskel& p)
  {
    this->Lanes_parser_ = &p;
  }

  void segment_t_pskel::
  Obstacles_parser (::geo::RoadItems_t_pskel& p)
  {
    this->Obstacles_parser_ = &p;
  }

  void segment_t_pskel::
  KurbLine_parser (::geo::PolyLine_t_pskel& p)
  {
    this->KurbLine_parser_ = &p;
  }

  void segment_t_pskel::
  parsers (::xml_schema::unsigned_long_pskel& segmentID,
           ::xml_schema::unsigned_int_pskel& startingNode,
           ::xml_schema::unsigned_int_pskel& endingNode,
           ::xml_schema::short_pskel& maxSpeed,
           ::xml_schema::unsigned_int_pskel& Length,
           ::xml_schema::unsigned_int_pskel& Width,
           ::xml_schema::string_pskel& originalDB_ID,
           ::geo::PolyLine_t_pskel& polyline,
           ::geo::laneEdgePolylines_cached_t_pskel& laneEdgePolylines_cached,
           ::geo::Lanes_pskel& Lanes,
           ::geo::RoadItems_t_pskel& Obstacles,
           ::geo::PolyLine_t_pskel& KurbLine)
  {
    this->segmentID_parser_ = &segmentID;
    this->startingNode_parser_ = &startingNode;
    this->endingNode_parser_ = &endingNode;
    this->maxSpeed_parser_ = &maxSpeed;
    this->Length_parser_ = &Length;
    this->Width_parser_ = &Width;
    this->originalDB_ID_parser_ = &originalDB_ID;
    this->polyline_parser_ = &polyline;
    this->laneEdgePolylines_cached_parser_ = &laneEdgePolylines_cached;
    this->Lanes_parser_ = &Lanes;
    this->Obstacles_parser_ = &Obstacles;
    this->KurbLine_parser_ = &KurbLine;
  }

  segment_t_pskel::
  segment_t_pskel ()
  : segmentID_parser_ (0),
    startingNode_parser_ (0),
    endingNode_parser_ (0),
    maxSpeed_parser_ (0),
    Length_parser_ (0),
    Width_parser_ (0),
    originalDB_ID_parser_ (0),
    polyline_parser_ (0),
    laneEdgePolylines_cached_parser_ (0),
    Lanes_parser_ (0),
    Obstacles_parser_ (0),
    KurbLine_parser_ (0)
  {
  }

  // link_t_pskel
  //

  void link_t_pskel::
  linkID_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->linkID_parser_ = &p;
  }

  void link_t_pskel::
  roadName_parser (::xml_schema::string_pskel& p)
  {
    this->roadName_parser_ = &p;
  }

  void link_t_pskel::
  StartingNode_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->StartingNode_parser_ = &p;
  }

  void link_t_pskel::
  EndingNode_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->EndingNode_parser_ = &p;
  }

  void link_t_pskel::
  Segments_parser (::geo::Segments_pskel& p)
  {
    this->Segments_parser_ = &p;
  }

  void link_t_pskel::
  parsers (::xml_schema::unsigned_int_pskel& linkID,
           ::xml_schema::string_pskel& roadName,
           ::xml_schema::unsigned_int_pskel& StartingNode,
           ::xml_schema::unsigned_int_pskel& EndingNode,
           ::geo::Segments_pskel& Segments)
  {
    this->linkID_parser_ = &linkID;
    this->roadName_parser_ = &roadName;
    this->StartingNode_parser_ = &StartingNode;
    this->EndingNode_parser_ = &EndingNode;
    this->Segments_parser_ = &Segments;
  }

  link_t_pskel::
  link_t_pskel ()
  : linkID_parser_ (0),
    roadName_parser_ (0),
    StartingNode_parser_ (0),
    EndingNode_parser_ (0),
    Segments_parser_ (0)
  {
  }

  // separator_t_pskel
  //

  void separator_t_pskel::
  separator_ID_parser (::xml_schema::unsigned_short_pskel& p)
  {
    this->separator_ID_parser_ = &p;
  }

  void separator_t_pskel::
  separator_value_parser (::xml_schema::boolean_pskel& p)
  {
    this->separator_value_parser_ = &p;
  }

  void separator_t_pskel::
  parsers (::xml_schema::unsigned_short_pskel& separator_ID,
           ::xml_schema::boolean_pskel& separator_value)
  {
    this->separator_ID_parser_ = &separator_ID;
    this->separator_value_parser_ = &separator_value;
  }

  separator_t_pskel::
  separator_t_pskel ()
  : separator_ID_parser_ (0),
    separator_value_parser_ (0)
  {
  }

  // separators_t_pskel
  //

  void separators_t_pskel::
  Separator_parser (::geo::separator_t_pskel& p)
  {
    this->Separator_parser_ = &p;
  }

  void separators_t_pskel::
  parsers (::geo::separator_t_pskel& Separator)
  {
    this->Separator_parser_ = &Separator;
  }

  separators_t_pskel::
  separators_t_pskel ()
  : Separator_parser_ (0)
  {
  }

  // DomainIsland_t_pskel
  //

  void DomainIsland_t_pskel::
  domainIsland_ID_parser (::xml_schema::unsigned_short_pskel& p)
  {
    this->domainIsland_ID_parser_ = &p;
  }

  void DomainIsland_t_pskel::
  domainIsland_value_parser (::xml_schema::boolean_pskel& p)
  {
    this->domainIsland_value_parser_ = &p;
  }

  void DomainIsland_t_pskel::
  parsers (::xml_schema::unsigned_short_pskel& domainIsland_ID,
           ::xml_schema::boolean_pskel& domainIsland_value)
  {
    this->domainIsland_ID_parser_ = &domainIsland_ID;
    this->domainIsland_value_parser_ = &domainIsland_value;
  }

  DomainIsland_t_pskel::
  DomainIsland_t_pskel ()
  : domainIsland_ID_parser_ (0),
    domainIsland_value_parser_ (0)
  {
  }

  // DomainIslands_t_pskel
  //

  void DomainIslands_t_pskel::
  domainIslands_parser (::geo::DomainIsland_t_pskel& p)
  {
    this->domainIslands_parser_ = &p;
  }

  void DomainIslands_t_pskel::
  parsers (::geo::DomainIsland_t_pskel& domainIslands)
  {
    this->domainIslands_parser_ = &domainIslands;
  }

  DomainIslands_t_pskel::
  DomainIslands_t_pskel ()
  : domainIslands_parser_ (0)
  {
  }

  // offset_t_pskel
  //

  void offset_t_pskel::
  offset_ID_parser (::xml_schema::unsigned_short_pskel& p)
  {
    this->offset_ID_parser_ = &p;
  }

  void offset_t_pskel::
  offset_value_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->offset_value_parser_ = &p;
  }

  void offset_t_pskel::
  parsers (::xml_schema::unsigned_short_pskel& offset_ID,
           ::xml_schema::unsigned_int_pskel& offset_value)
  {
    this->offset_ID_parser_ = &offset_ID;
    this->offset_value_parser_ = &offset_value;
  }

  offset_t_pskel::
  offset_t_pskel ()
  : offset_ID_parser_ (0),
    offset_value_parser_ (0)
  {
  }

  // offsets_t_pskel
  //

  void offsets_t_pskel::
  offset_parser (::geo::offset_t_pskel& p)
  {
    this->offset_parser_ = &p;
  }

  void offsets_t_pskel::
  parsers (::geo::offset_t_pskel& offset)
  {
    this->offset_parser_ = &offset;
  }

  offsets_t_pskel::
  offsets_t_pskel ()
  : offset_parser_ (0)
  {
  }

  // ChunkLength_t_pskel
  //

  void ChunkLength_t_pskel::
  chunklength_ID_parser (::xml_schema::unsigned_short_pskel& p)
  {
    this->chunklength_ID_parser_ = &p;
  }

  void ChunkLength_t_pskel::
  chunklength_value_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->chunklength_value_parser_ = &p;
  }

  void ChunkLength_t_pskel::
  parsers (::xml_schema::unsigned_short_pskel& chunklength_ID,
           ::xml_schema::unsigned_int_pskel& chunklength_value)
  {
    this->chunklength_ID_parser_ = &chunklength_ID;
    this->chunklength_value_parser_ = &chunklength_value;
  }

  ChunkLength_t_pskel::
  ChunkLength_t_pskel ()
  : chunklength_ID_parser_ (0),
    chunklength_value_parser_ (0)
  {
  }

  // ChunkLengths_t_pskel
  //

  void ChunkLengths_t_pskel::
  chunklength_parser (::geo::ChunkLength_t_pskel& p)
  {
    this->chunklength_parser_ = &p;
  }

  void ChunkLengths_t_pskel::
  parsers (::geo::ChunkLength_t_pskel& chunklength)
  {
    this->chunklength_parser_ = &chunklength;
  }

  ChunkLengths_t_pskel::
  ChunkLengths_t_pskel ()
  : chunklength_parser_ (0)
  {
  }

  // LanesVector_t_pskel
  //

  void LanesVector_t_pskel::
  laneID_parser (::xml_schema::unsigned_long_pskel& p)
  {
    this->laneID_parser_ = &p;
  }

  void LanesVector_t_pskel::
  parsers (::xml_schema::unsigned_long_pskel& laneID)
  {
    this->laneID_parser_ = &laneID;
  }

  LanesVector_t_pskel::
  LanesVector_t_pskel ()
  : laneID_parser_ (0)
  {
  }

  // EntranceAngle_t_pskel
  //

  void EntranceAngle_t_pskel::
  entranceAngle_ID_parser (::xml_schema::unsigned_short_pskel& p)
  {
    this->entranceAngle_ID_parser_ = &p;
  }

  void EntranceAngle_t_pskel::
  entranceAngle_value_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->entranceAngle_value_parser_ = &p;
  }

  void EntranceAngle_t_pskel::
  parsers (::xml_schema::unsigned_short_pskel& entranceAngle_ID,
           ::xml_schema::unsigned_int_pskel& entranceAngle_value)
  {
    this->entranceAngle_ID_parser_ = &entranceAngle_ID;
    this->entranceAngle_value_parser_ = &entranceAngle_value;
  }

  EntranceAngle_t_pskel::
  EntranceAngle_t_pskel ()
  : entranceAngle_ID_parser_ (0),
    entranceAngle_value_parser_ (0)
  {
  }

  // EntranceAngles_t_pskel
  //

  void EntranceAngles_t_pskel::
  entranceAngle_parser (::geo::EntranceAngle_t_pskel& p)
  {
    this->entranceAngle_parser_ = &p;
  }

  void EntranceAngles_t_pskel::
  parsers (::geo::EntranceAngle_t_pskel& entranceAngle)
  {
    this->entranceAngle_parser_ = &entranceAngle;
  }

  EntranceAngles_t_pskel::
  EntranceAngles_t_pskel ()
  : entranceAngle_parser_ (0)
  {
  }

  // Node_t_pskel
  //

  void Node_t_pskel::
  nodeID_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->nodeID_parser_ = &p;
  }

  void Node_t_pskel::
  location_parser (::geo::Point2D_t_pskel& p)
  {
    this->location_parser_ = &p;
  }

  void Node_t_pskel::
  linkLoc_parser (::xml_schema::unsigned_long_pskel& p)
  {
    this->linkLoc_parser_ = &p;
  }

  void Node_t_pskel::
  originalDB_ID_parser (::xml_schema::string_pskel& p)
  {
    this->originalDB_ID_parser_ = &p;
  }

  void Node_t_pskel::
  parsers (::xml_schema::unsigned_int_pskel& nodeID,
           ::geo::Point2D_t_pskel& location,
           ::xml_schema::unsigned_long_pskel& linkLoc,
           ::xml_schema::string_pskel& originalDB_ID)
  {
    this->nodeID_parser_ = &nodeID;
    this->location_parser_ = &location;
    this->linkLoc_parser_ = &linkLoc;
    this->originalDB_ID_parser_ = &originalDB_ID;
  }

  Node_t_pskel::
  Node_t_pskel ()
  : nodeID_parser_ (0),
    location_parser_ (0),
    linkLoc_parser_ (0),
    originalDB_ID_parser_ (0)
  {
  }

  // temp_Segmetair_t_pskel
  //

  void temp_Segmetair_t_pskel::
  first_parser (::xml_schema::unsigned_long_pskel& p)
  {
    this->first_parser_ = &p;
  }

  void temp_Segmetair_t_pskel::
  second_parser (::xml_schema::unsigned_long_pskel& p)
  {
    this->second_parser_ = &p;
  }

  void temp_Segmetair_t_pskel::
  parsers (::xml_schema::unsigned_long_pskel& first,
           ::xml_schema::unsigned_long_pskel& second)
  {
    this->first_parser_ = &first;
    this->second_parser_ = &second;
  }

  temp_Segmetair_t_pskel::
  temp_Segmetair_t_pskel ()
  : first_parser_ (0),
    second_parser_ (0)
  {
  }

  // UniNode_t_pskel
  //

  void UniNode_t_pskel::
  firstPair_parser (::geo::temp_Segmetair_t_pskel& p)
  {
    this->firstPair_parser_ = &p;
  }

  void UniNode_t_pskel::
  secondPair_parser (::geo::temp_Segmetair_t_pskel& p)
  {
    this->secondPair_parser_ = &p;
  }

  void UniNode_t_pskel::
  Connectors_parser (::geo::connectors_t_pskel& p)
  {
    this->Connectors_parser_ = &p;
  }

  void UniNode_t_pskel::
  parsers (::xml_schema::unsigned_int_pskel& nodeID,
           ::geo::Point2D_t_pskel& location,
           ::xml_schema::unsigned_long_pskel& linkLoc,
           ::xml_schema::string_pskel& originalDB_ID,
           ::geo::temp_Segmetair_t_pskel& firstPair,
           ::geo::temp_Segmetair_t_pskel& secondPair,
           ::geo::connectors_t_pskel& Connectors)
  {
    this->nodeID_parser_ = &nodeID;
    this->location_parser_ = &location;
    this->linkLoc_parser_ = &linkLoc;
    this->originalDB_ID_parser_ = &originalDB_ID;
    this->firstPair_parser_ = &firstPair;
    this->secondPair_parser_ = &secondPair;
    this->Connectors_parser_ = &Connectors;
  }

  UniNode_t_pskel::
  UniNode_t_pskel ()
  : firstPair_parser_ (0),
    secondPair_parser_ (0),
    Connectors_parser_ (0)
  {
  }

  // roundabout_t_pskel
  //

  void roundabout_t_pskel::
  roadSegmentsAt_parser (::geo::RoadSegmentsAt_t_pskel& p)
  {
    this->roadSegmentsAt_parser_ = &p;
  }

  void roundabout_t_pskel::
  Connectors_parser (::geo::Multi_Connectors_t_pskel& p)
  {
    this->Connectors_parser_ = &p;
  }

  void roundabout_t_pskel::
  ChunkLengths_parser (::geo::ChunkLengths_t_pskel& p)
  {
    this->ChunkLengths_parser_ = &p;
  }

  void roundabout_t_pskel::
  Offsets_parser (::geo::offsets_t_pskel& p)
  {
    this->Offsets_parser_ = &p;
  }

  void roundabout_t_pskel::
  Separators_parser (::geo::separators_t_pskel& p)
  {
    this->Separators_parser_ = &p;
  }

  void roundabout_t_pskel::
  addDominantLane_parser (::geo::LanesVector_t_pskel& p)
  {
    this->addDominantLane_parser_ = &p;
  }

  void roundabout_t_pskel::
  roundaboutDominantIslands_parser (::xml_schema::float_pskel& p)
  {
    this->roundaboutDominantIslands_parser_ = &p;
  }

  void roundabout_t_pskel::
  roundaboutNumberOfLanes_parser (::xml_schema::int_pskel& p)
  {
    this->roundaboutNumberOfLanes_parser_ = &p;
  }

  void roundabout_t_pskel::
  entranceAngles_parser (::geo::EntranceAngles_t_pskel& p)
  {
    this->entranceAngles_parser_ = &p;
  }

  void roundabout_t_pskel::
  parsers (::xml_schema::unsigned_int_pskel& nodeID,
           ::geo::Point2D_t_pskel& location,
           ::xml_schema::unsigned_long_pskel& linkLoc,
           ::xml_schema::string_pskel& originalDB_ID,
           ::geo::RoadSegmentsAt_t_pskel& roadSegmentsAt,
           ::geo::Multi_Connectors_t_pskel& Connectors,
           ::geo::ChunkLengths_t_pskel& ChunkLengths,
           ::geo::offsets_t_pskel& Offsets,
           ::geo::separators_t_pskel& Separators,
           ::geo::LanesVector_t_pskel& addDominantLane,
           ::xml_schema::float_pskel& roundaboutDominantIslands,
           ::xml_schema::int_pskel& roundaboutNumberOfLanes,
           ::geo::EntranceAngles_t_pskel& entranceAngles)
  {
    this->nodeID_parser_ = &nodeID;
    this->location_parser_ = &location;
    this->linkLoc_parser_ = &linkLoc;
    this->originalDB_ID_parser_ = &originalDB_ID;
    this->roadSegmentsAt_parser_ = &roadSegmentsAt;
    this->Connectors_parser_ = &Connectors;
    this->ChunkLengths_parser_ = &ChunkLengths;
    this->Offsets_parser_ = &Offsets;
    this->Separators_parser_ = &Separators;
    this->addDominantLane_parser_ = &addDominantLane;
    this->roundaboutDominantIslands_parser_ = &roundaboutDominantIslands;
    this->roundaboutNumberOfLanes_parser_ = &roundaboutNumberOfLanes;
    this->entranceAngles_parser_ = &entranceAngles;
  }

  roundabout_t_pskel::
  roundabout_t_pskel ()
  : roadSegmentsAt_parser_ (0),
    Connectors_parser_ (0),
    ChunkLengths_parser_ (0),
    Offsets_parser_ (0),
    Separators_parser_ (0),
    addDominantLane_parser_ (0),
    roundaboutDominantIslands_parser_ (0),
    roundaboutNumberOfLanes_parser_ (0),
    entranceAngles_parser_ (0)
  {
  }

  // intersection_t_pskel
  //

  void intersection_t_pskel::
  roadSegmentsAt_parser (::geo::RoadSegmentsAt_t_pskel& p)
  {
    this->roadSegmentsAt_parser_ = &p;
  }

  void intersection_t_pskel::
  Connectors_parser (::geo::Multi_Connectors_t_pskel& p)
  {
    this->Connectors_parser_ = &p;
  }

  void intersection_t_pskel::
  ChunkLengths_parser (::geo::ChunkLengths_t_pskel& p)
  {
    this->ChunkLengths_parser_ = &p;
  }

  void intersection_t_pskel::
  Offsets_parser (::geo::offsets_t_pskel& p)
  {
    this->Offsets_parser_ = &p;
  }

  void intersection_t_pskel::
  Separators_parser (::geo::separators_t_pskel& p)
  {
    this->Separators_parser_ = &p;
  }

  void intersection_t_pskel::
  additionalDominantLanes_parser (::geo::LanesVector_t_pskel& p)
  {
    this->additionalDominantLanes_parser_ = &p;
  }

  void intersection_t_pskel::
  additionalSubdominantLanes_parser (::geo::LanesVector_t_pskel& p)
  {
    this->additionalSubdominantLanes_parser_ = &p;
  }

  void intersection_t_pskel::
  domainIslands_parser (::geo::DomainIslands_t_pskel& p)
  {
    this->domainIslands_parser_ = &p;
  }

  void intersection_t_pskel::
  parsers (::xml_schema::unsigned_int_pskel& nodeID,
           ::geo::Point2D_t_pskel& location,
           ::xml_schema::unsigned_long_pskel& linkLoc,
           ::xml_schema::string_pskel& originalDB_ID,
           ::geo::RoadSegmentsAt_t_pskel& roadSegmentsAt,
           ::geo::Multi_Connectors_t_pskel& Connectors,
           ::geo::ChunkLengths_t_pskel& ChunkLengths,
           ::geo::offsets_t_pskel& Offsets,
           ::geo::separators_t_pskel& Separators,
           ::geo::LanesVector_t_pskel& additionalDominantLanes,
           ::geo::LanesVector_t_pskel& additionalSubdominantLanes,
           ::geo::DomainIslands_t_pskel& domainIslands)
  {
    this->nodeID_parser_ = &nodeID;
    this->location_parser_ = &location;
    this->linkLoc_parser_ = &linkLoc;
    this->originalDB_ID_parser_ = &originalDB_ID;
    this->roadSegmentsAt_parser_ = &roadSegmentsAt;
    this->Connectors_parser_ = &Connectors;
    this->ChunkLengths_parser_ = &ChunkLengths;
    this->Offsets_parser_ = &Offsets;
    this->Separators_parser_ = &Separators;
    this->additionalDominantLanes_parser_ = &additionalDominantLanes;
    this->additionalSubdominantLanes_parser_ = &additionalSubdominantLanes;
    this->domainIslands_parser_ = &domainIslands;
  }

  intersection_t_pskel::
  intersection_t_pskel ()
  : roadSegmentsAt_parser_ (0),
    Connectors_parser_ (0),
    ChunkLengths_parser_ (0),
    Offsets_parser_ (0),
    Separators_parser_ (0),
    additionalDominantLanes_parser_ (0),
    additionalSubdominantLanes_parser_ (0),
    domainIslands_parser_ (0)
  {
  }

  // RoadItem_t_pskel
  //

  void RoadItem_t_pskel::
  id_parser (::xml_schema::unsigned_long_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void RoadItem_t_pskel::
  Offset_parser (::xml_schema::unsigned_short_pskel& p)
  {
    this->Offset_parser_ = &p;
  }

  void RoadItem_t_pskel::
  start_parser (::geo::Point2D_t_pskel& p)
  {
    this->start_parser_ = &p;
  }

  void RoadItem_t_pskel::
  end_parser (::geo::Point2D_t_pskel& p)
  {
    this->end_parser_ = &p;
  }

  void RoadItem_t_pskel::
  parsers (::xml_schema::unsigned_long_pskel& id,
           ::xml_schema::unsigned_short_pskel& Offset,
           ::geo::Point2D_t_pskel& start,
           ::geo::Point2D_t_pskel& end)
  {
    this->id_parser_ = &id;
    this->Offset_parser_ = &Offset;
    this->start_parser_ = &start;
    this->end_parser_ = &end;
  }

  RoadItem_t_pskel::
  RoadItem_t_pskel ()
  : id_parser_ (0),
    Offset_parser_ (0),
    start_parser_ (0),
    end_parser_ (0)
  {
  }

  // BusStop_t_pskel
  //

  void BusStop_t_pskel::
  lane_location_parser (::xml_schema::string_pskel& p)
  {
    this->lane_location_parser_ = &p;
  }

  void BusStop_t_pskel::
  is_Terminal_parser (::xml_schema::boolean_pskel& p)
  {
    this->is_Terminal_parser_ = &p;
  }

  void BusStop_t_pskel::
  is_Bay_parser (::xml_schema::boolean_pskel& p)
  {
    this->is_Bay_parser_ = &p;
  }

  void BusStop_t_pskel::
  has_shelter_parser (::xml_schema::boolean_pskel& p)
  {
    this->has_shelter_parser_ = &p;
  }

  void BusStop_t_pskel::
  busCapacityAsLength_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->busCapacityAsLength_parser_ = &p;
  }

  void BusStop_t_pskel::
  parsers (::xml_schema::unsigned_long_pskel& id,
           ::xml_schema::unsigned_short_pskel& Offset,
           ::geo::Point2D_t_pskel& start,
           ::geo::Point2D_t_pskel& end,
           ::xml_schema::string_pskel& lane_location,
           ::xml_schema::boolean_pskel& is_Terminal,
           ::xml_schema::boolean_pskel& is_Bay,
           ::xml_schema::boolean_pskel& has_shelter,
           ::xml_schema::unsigned_int_pskel& busCapacityAsLength)
  {
    this->id_parser_ = &id;
    this->Offset_parser_ = &Offset;
    this->start_parser_ = &start;
    this->end_parser_ = &end;
    this->lane_location_parser_ = &lane_location;
    this->is_Terminal_parser_ = &is_Terminal;
    this->is_Bay_parser_ = &is_Bay;
    this->has_shelter_parser_ = &has_shelter;
    this->busCapacityAsLength_parser_ = &busCapacityAsLength;
  }

  BusStop_t_pskel::
  BusStop_t_pskel ()
  : lane_location_parser_ (0),
    is_Terminal_parser_ (0),
    is_Bay_parser_ (0),
    has_shelter_parser_ (0),
    busCapacityAsLength_parser_ (0)
  {
  }

  // ERP_Gantry_t_pskel
  //

  void ERP_Gantry_t_pskel::
  ERP_GantryID_parser (::xml_schema::string_pskel& p)
  {
    this->ERP_GantryID_parser_ = &p;
  }

  void ERP_Gantry_t_pskel::
  parsers (::xml_schema::unsigned_long_pskel& id,
           ::xml_schema::unsigned_short_pskel& Offset,
           ::geo::Point2D_t_pskel& start,
           ::geo::Point2D_t_pskel& end,
           ::xml_schema::string_pskel& ERP_GantryID)
  {
    this->id_parser_ = &id;
    this->Offset_parser_ = &Offset;
    this->start_parser_ = &start;
    this->end_parser_ = &end;
    this->ERP_GantryID_parser_ = &ERP_GantryID;
  }

  ERP_Gantry_t_pskel::
  ERP_Gantry_t_pskel ()
  : ERP_GantryID_parser_ (0)
  {
  }

  // FormType_pskel
  //

  void FormType_pskel::
  TextBox_parser (::xml_schema::int_pskel& p)
  {
    this->TextBox_parser_ = &p;
  }

  void FormType_pskel::
  TextArea_parser (::xml_schema::int_pskel& p)
  {
    this->TextArea_parser_ = &p;
  }

  void FormType_pskel::
  Header_parser (::xml_schema::int_pskel& p)
  {
    this->Header_parser_ = &p;
  }

  void FormType_pskel::
  parsers (::xml_schema::int_pskel& TextBox,
           ::xml_schema::int_pskel& TextArea,
           ::xml_schema::int_pskel& Header)
  {
    this->TextBox_parser_ = &TextBox;
    this->TextArea_parser_ = &TextArea;
    this->Header_parser_ = &Header;
  }

  FormType_pskel::
  FormType_pskel ()
  : TextBox_parser_ (0),
    TextArea_parser_ (0),
    Header_parser_ (0)
  {
  }

  // PointPair_t_pskel
  //

  void PointPair_t_pskel::
  first_parser (::geo::Point2D_t_pskel& p)
  {
    this->first_parser_ = &p;
  }

  void PointPair_t_pskel::
  second_parser (::geo::Point2D_t_pskel& p)
  {
    this->second_parser_ = &p;
  }

  void PointPair_t_pskel::
  parsers (::geo::Point2D_t_pskel& first,
           ::geo::Point2D_t_pskel& second)
  {
    this->first_parser_ = &first;
    this->second_parser_ = &second;
  }

  PointPair_t_pskel::
  PointPair_t_pskel ()
  : first_parser_ (0),
    second_parser_ (0)
  {
  }

  // crossing_t_pskel
  //

  void crossing_t_pskel::
  nearLine_parser (::geo::PointPair_t_pskel& p)
  {
    this->nearLine_parser_ = &p;
  }

  void crossing_t_pskel::
  farLine_parser (::geo::PointPair_t_pskel& p)
  {
    this->farLine_parser_ = &p;
  }

  void crossing_t_pskel::
  parsers (::xml_schema::unsigned_long_pskel& id,
           ::xml_schema::unsigned_short_pskel& Offset,
           ::geo::Point2D_t_pskel& start,
           ::geo::Point2D_t_pskel& end,
           ::geo::PointPair_t_pskel& nearLine,
           ::geo::PointPair_t_pskel& farLine)
  {
    this->id_parser_ = &id;
    this->Offset_parser_ = &Offset;
    this->start_parser_ = &start;
    this->end_parser_ = &end;
    this->nearLine_parser_ = &nearLine;
    this->farLine_parser_ = &farLine;
  }

  crossing_t_pskel::
  crossing_t_pskel ()
  : nearLine_parser_ (0),
    farLine_parser_ (0)
  {
  }

  // RoadBump_t_pskel
  //

  void RoadBump_t_pskel::
  roadBumpID_parser (::xml_schema::string_pskel& p)
  {
    this->roadBumpID_parser_ = &p;
  }

  void RoadBump_t_pskel::
  segmentID_parser (::xml_schema::unsigned_long_pskel& p)
  {
    this->segmentID_parser_ = &p;
  }

  void RoadBump_t_pskel::
  parsers (::xml_schema::unsigned_long_pskel& id,
           ::xml_schema::unsigned_short_pskel& Offset,
           ::geo::Point2D_t_pskel& start,
           ::geo::Point2D_t_pskel& end,
           ::xml_schema::string_pskel& roadBumpID,
           ::xml_schema::unsigned_long_pskel& segmentID)
  {
    this->id_parser_ = &id;
    this->Offset_parser_ = &Offset;
    this->start_parser_ = &start;
    this->end_parser_ = &end;
    this->roadBumpID_parser_ = &roadBumpID;
    this->segmentID_parser_ = &segmentID;
  }

  RoadBump_t_pskel::
  RoadBump_t_pskel ()
  : roadBumpID_parser_ (0),
    segmentID_parser_ (0)
  {
  }

  // RoadNetwork_t_pskel
  //

  void RoadNetwork_t_pskel::
  Nodes_parser (::geo::Nodes_pskel& p)
  {
    this->Nodes_parser_ = &p;
  }

  void RoadNetwork_t_pskel::
  Links_parser (::geo::Links_pskel& p)
  {
    this->Links_parser_ = &p;
  }

  void RoadNetwork_t_pskel::
  parsers (::geo::Nodes_pskel& Nodes,
           ::geo::Links_pskel& Links)
  {
    this->Nodes_parser_ = &Nodes;
    this->Links_parser_ = &Links;
  }

  RoadNetwork_t_pskel::
  RoadNetwork_t_pskel ()
  : Nodes_parser_ (0),
    Links_parser_ (0)
  {
  }

  // RoadItems_t_pskel
  //

  void RoadItems_t_pskel::
  BusStop_parser (::geo::BusStop_t_pskel& p)
  {
    this->BusStop_parser_ = &p;
  }

  void RoadItems_t_pskel::
  ERP_Gantry_parser (::geo::ERP_Gantry_t_pskel& p)
  {
    this->ERP_Gantry_parser_ = &p;
  }

  void RoadItems_t_pskel::
  Crossing_parser (::geo::crossing_t_pskel& p)
  {
    this->Crossing_parser_ = &p;
  }

  void RoadItems_t_pskel::
  RoadBump_parser (::geo::RoadBump_t_pskel& p)
  {
    this->RoadBump_parser_ = &p;
  }

  void RoadItems_t_pskel::
  parsers (::geo::BusStop_t_pskel& BusStop,
           ::geo::ERP_Gantry_t_pskel& ERP_Gantry,
           ::geo::crossing_t_pskel& Crossing,
           ::geo::RoadBump_t_pskel& RoadBump)
  {
    this->BusStop_parser_ = &BusStop;
    this->ERP_Gantry_parser_ = &ERP_Gantry;
    this->Crossing_parser_ = &Crossing;
    this->RoadBump_parser_ = &RoadBump;
  }

  RoadItems_t_pskel::
  RoadItems_t_pskel ()
  : BusStop_parser_ (0),
    ERP_Gantry_parser_ (0),
    Crossing_parser_ (0),
    RoadBump_parser_ (0)
  {
  }

  // TripChainItem_t_pskel
  //

  void TripChainItem_t_pskel::
  personID_parser (::xml_schema::integer_pskel& p)
  {
    this->personID_parser_ = &p;
  }

  void TripChainItem_t_pskel::
  itemType_parser (::geo::TripchainItemType_pskel& p)
  {
    this->itemType_parser_ = &p;
  }

  void TripChainItem_t_pskel::
  sequenceNumber_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->sequenceNumber_parser_ = &p;
  }

  void TripChainItem_t_pskel::
  startTime_parser (::xml_schema::string_pskel& p)
  {
    this->startTime_parser_ = &p;
  }

  void TripChainItem_t_pskel::
  endTime_parser (::xml_schema::string_pskel& p)
  {
    this->endTime_parser_ = &p;
  }

  void TripChainItem_t_pskel::
  parsers (::xml_schema::integer_pskel& personID,
           ::geo::TripchainItemType_pskel& itemType,
           ::xml_schema::unsigned_int_pskel& sequenceNumber,
           ::xml_schema::string_pskel& startTime,
           ::xml_schema::string_pskel& endTime)
  {
    this->personID_parser_ = &personID;
    this->itemType_parser_ = &itemType;
    this->sequenceNumber_parser_ = &sequenceNumber;
    this->startTime_parser_ = &startTime;
    this->endTime_parser_ = &endTime;
  }

  TripChainItem_t_pskel::
  TripChainItem_t_pskel ()
  : personID_parser_ (0),
    itemType_parser_ (0),
    sequenceNumber_parser_ (0),
    startTime_parser_ (0),
    endTime_parser_ (0)
  {
  }

  // Trip_t_pskel
  //

  void Trip_t_pskel::
  tripID_parser (::xml_schema::integer_pskel& p)
  {
    this->tripID_parser_ = &p;
  }

  void Trip_t_pskel::
  fromLocation_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->fromLocation_parser_ = &p;
  }

  void Trip_t_pskel::
  fromLocationType_parser (::geo::TripchainItemLocationType_pskel& p)
  {
    this->fromLocationType_parser_ = &p;
  }

  void Trip_t_pskel::
  toLocation_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->toLocation_parser_ = &p;
  }

  void Trip_t_pskel::
  toLocationType_parser (::geo::TripchainItemLocationType_pskel& p)
  {
    this->toLocationType_parser_ = &p;
  }

  void Trip_t_pskel::
  subTrips_parser (::geo::SubTrips_t_pskel& p)
  {
    this->subTrips_parser_ = &p;
  }

  void Trip_t_pskel::
  parsers (::xml_schema::integer_pskel& personID,
           ::geo::TripchainItemType_pskel& itemType,
           ::xml_schema::unsigned_int_pskel& sequenceNumber,
           ::xml_schema::string_pskel& startTime,
           ::xml_schema::string_pskel& endTime,
           ::xml_schema::integer_pskel& tripID,
           ::xml_schema::unsigned_int_pskel& fromLocation,
           ::geo::TripchainItemLocationType_pskel& fromLocationType,
           ::xml_schema::unsigned_int_pskel& toLocation,
           ::geo::TripchainItemLocationType_pskel& toLocationType,
           ::geo::SubTrips_t_pskel& subTrips)
  {
    this->personID_parser_ = &personID;
    this->itemType_parser_ = &itemType;
    this->sequenceNumber_parser_ = &sequenceNumber;
    this->startTime_parser_ = &startTime;
    this->endTime_parser_ = &endTime;
    this->tripID_parser_ = &tripID;
    this->fromLocation_parser_ = &fromLocation;
    this->fromLocationType_parser_ = &fromLocationType;
    this->toLocation_parser_ = &toLocation;
    this->toLocationType_parser_ = &toLocationType;
    this->subTrips_parser_ = &subTrips;
  }

  Trip_t_pskel::
  Trip_t_pskel ()
  : tripID_parser_ (0),
    fromLocation_parser_ (0),
    fromLocationType_parser_ (0),
    toLocation_parser_ (0),
    toLocationType_parser_ (0),
    subTrips_parser_ (0)
  {
  }

  // SubTrip_t_pskel
  //

  void SubTrip_t_pskel::
  mode_parser (::xml_schema::string_pskel& p)
  {
    this->mode_parser_ = &p;
  }

  void SubTrip_t_pskel::
  isPrimaryMode_parser (::xml_schema::boolean_pskel& p)
  {
    this->isPrimaryMode_parser_ = &p;
  }

  void SubTrip_t_pskel::
  ptLineId_parser (::xml_schema::string_pskel& p)
  {
    this->ptLineId_parser_ = &p;
  }

  void SubTrip_t_pskel::
  parsers (::xml_schema::integer_pskel& personID,
           ::geo::TripchainItemType_pskel& itemType,
           ::xml_schema::unsigned_int_pskel& sequenceNumber,
           ::xml_schema::string_pskel& startTime,
           ::xml_schema::string_pskel& endTime,
           ::xml_schema::integer_pskel& tripID,
           ::xml_schema::unsigned_int_pskel& fromLocation,
           ::geo::TripchainItemLocationType_pskel& fromLocationType,
           ::xml_schema::unsigned_int_pskel& toLocation,
           ::geo::TripchainItemLocationType_pskel& toLocationType,
           ::geo::SubTrips_t_pskel& subTrips,
           ::xml_schema::string_pskel& mode,
           ::xml_schema::boolean_pskel& isPrimaryMode,
           ::xml_schema::string_pskel& ptLineId)
  {
    this->personID_parser_ = &personID;
    this->itemType_parser_ = &itemType;
    this->sequenceNumber_parser_ = &sequenceNumber;
    this->startTime_parser_ = &startTime;
    this->endTime_parser_ = &endTime;
    this->tripID_parser_ = &tripID;
    this->fromLocation_parser_ = &fromLocation;
    this->fromLocationType_parser_ = &fromLocationType;
    this->toLocation_parser_ = &toLocation;
    this->toLocationType_parser_ = &toLocationType;
    this->subTrips_parser_ = &subTrips;
    this->mode_parser_ = &mode;
    this->isPrimaryMode_parser_ = &isPrimaryMode;
    this->ptLineId_parser_ = &ptLineId;
  }

  SubTrip_t_pskel::
  SubTrip_t_pskel ()
  : mode_parser_ (0),
    isPrimaryMode_parser_ (0),
    ptLineId_parser_ (0)
  {
  }

  // SubTrips_t_pskel
  //

  void SubTrips_t_pskel::
  subTrip_parser (::geo::SubTrip_t_pskel& p)
  {
    this->subTrip_parser_ = &p;
  }

  void SubTrips_t_pskel::
  parsers (::geo::SubTrip_t_pskel& subTrip)
  {
    this->subTrip_parser_ = &subTrip;
  }

  SubTrips_t_pskel::
  SubTrips_t_pskel ()
  : subTrip_parser_ (0)
  {
  }

  // Activity_t_pskel
  //

  void Activity_t_pskel::
  description_parser (::xml_schema::string_pskel& p)
  {
    this->description_parser_ = &p;
  }

  void Activity_t_pskel::
  location_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->location_parser_ = &p;
  }

  void Activity_t_pskel::
  locationType_parser (::geo::TripchainItemLocationType_pskel& p)
  {
    this->locationType_parser_ = &p;
  }

  void Activity_t_pskel::
  isPrimary_parser (::xml_schema::boolean_pskel& p)
  {
    this->isPrimary_parser_ = &p;
  }

  void Activity_t_pskel::
  isFlexible_parser (::xml_schema::boolean_pskel& p)
  {
    this->isFlexible_parser_ = &p;
  }

  void Activity_t_pskel::
  isMandatory_parser (::xml_schema::boolean_pskel& p)
  {
    this->isMandatory_parser_ = &p;
  }

  void Activity_t_pskel::
  parsers (::xml_schema::integer_pskel& personID,
           ::geo::TripchainItemType_pskel& itemType,
           ::xml_schema::unsigned_int_pskel& sequenceNumber,
           ::xml_schema::string_pskel& startTime,
           ::xml_schema::string_pskel& endTime,
           ::xml_schema::string_pskel& description,
           ::xml_schema::unsigned_int_pskel& location,
           ::geo::TripchainItemLocationType_pskel& locationType,
           ::xml_schema::boolean_pskel& isPrimary,
           ::xml_schema::boolean_pskel& isFlexible,
           ::xml_schema::boolean_pskel& isMandatory)
  {
    this->personID_parser_ = &personID;
    this->itemType_parser_ = &itemType;
    this->sequenceNumber_parser_ = &sequenceNumber;
    this->startTime_parser_ = &startTime;
    this->endTime_parser_ = &endTime;
    this->description_parser_ = &description;
    this->location_parser_ = &location;
    this->locationType_parser_ = &locationType;
    this->isPrimary_parser_ = &isPrimary;
    this->isFlexible_parser_ = &isFlexible;
    this->isMandatory_parser_ = &isMandatory;
  }

  Activity_t_pskel::
  Activity_t_pskel ()
  : description_parser_ (0),
    location_parser_ (0),
    locationType_parser_ (0),
    isPrimary_parser_ (0),
    isFlexible_parser_ (0),
    isMandatory_parser_ (0)
  {
  }

  // TripChain_t_pskel
  //

  void TripChain_t_pskel::
  personID_parser (::xml_schema::integer_pskel& p)
  {
    this->personID_parser_ = &p;
  }

  void TripChain_t_pskel::
  Trip_parser (::geo::Trip_t_pskel& p)
  {
    this->Trip_parser_ = &p;
  }

  void TripChain_t_pskel::
  Activity_parser (::geo::Activity_t_pskel& p)
  {
    this->Activity_parser_ = &p;
  }

  void TripChain_t_pskel::
  parsers (::xml_schema::integer_pskel& personID,
           ::geo::Trip_t_pskel& Trip,
           ::geo::Activity_t_pskel& Activity)
  {
    this->personID_parser_ = &personID;
    this->Trip_parser_ = &Trip;
    this->Activity_parser_ = &Activity;
  }

  TripChain_t_pskel::
  TripChain_t_pskel ()
  : personID_parser_ (0),
    Trip_parser_ (0),
    Activity_parser_ (0)
  {
  }

  // TripChains_t_pskel
  //

  void TripChains_t_pskel::
  TripChain_parser (::geo::TripChain_t_pskel& p)
  {
    this->TripChain_parser_ = &p;
  }

  void TripChains_t_pskel::
  parsers (::geo::TripChain_t_pskel& TripChain)
  {
    this->TripChain_parser_ = &TripChain;
  }

  TripChains_t_pskel::
  TripChains_t_pskel ()
  : TripChain_parser_ (0)
  {
  }

  // linkAndCrossing_t_pskel
  //

  void linkAndCrossing_t_pskel::
  ID_parser (::xml_schema::unsigned_byte_pskel& p)
  {
    this->ID_parser_ = &p;
  }

  void linkAndCrossing_t_pskel::
  linkID_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->linkID_parser_ = &p;
  }

  void linkAndCrossing_t_pskel::
  crossingID_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->crossingID_parser_ = &p;
  }

  void linkAndCrossing_t_pskel::
  angle_parser (::xml_schema::unsigned_byte_pskel& p)
  {
    this->angle_parser_ = &p;
  }

  void linkAndCrossing_t_pskel::
  parsers (::xml_schema::unsigned_byte_pskel& ID,
           ::xml_schema::unsigned_int_pskel& linkID,
           ::xml_schema::unsigned_int_pskel& crossingID,
           ::xml_schema::unsigned_byte_pskel& angle)
  {
    this->ID_parser_ = &ID;
    this->linkID_parser_ = &linkID;
    this->crossingID_parser_ = &crossingID;
    this->angle_parser_ = &angle;
  }

  linkAndCrossing_t_pskel::
  linkAndCrossing_t_pskel ()
  : ID_parser_ (0),
    linkID_parser_ (0),
    crossingID_parser_ (0),
    angle_parser_ (0)
  {
  }

  // linkAndCrossings_t_pskel
  //

  void linkAndCrossings_t_pskel::
  linkAndCrossing_parser (::geo::linkAndCrossing_t_pskel& p)
  {
    this->linkAndCrossing_parser_ = &p;
  }

  void linkAndCrossings_t_pskel::
  parsers (::geo::linkAndCrossing_t_pskel& linkAndCrossing)
  {
    this->linkAndCrossing_parser_ = &linkAndCrossing;
  }

  linkAndCrossings_t_pskel::
  linkAndCrossings_t_pskel ()
  : linkAndCrossing_parser_ (0)
  {
  }

  // Plan_t_pskel
  //

  void Plan_t_pskel::
  planID_parser (::xml_schema::unsigned_byte_pskel& p)
  {
    this->planID_parser_ = &p;
  }

  void Plan_t_pskel::
  PhasePercentage_parser (::xml_schema::double_pskel& p)
  {
    this->PhasePercentage_parser_ = &p;
  }

  void Plan_t_pskel::
  parsers (::xml_schema::unsigned_byte_pskel& planID,
           ::xml_schema::double_pskel& PhasePercentage)
  {
    this->planID_parser_ = &planID;
    this->PhasePercentage_parser_ = &PhasePercentage;
  }

  Plan_t_pskel::
  Plan_t_pskel ()
  : planID_parser_ (0),
    PhasePercentage_parser_ (0)
  {
  }

  // Plans_t_pskel
  //

  void Plans_t_pskel::
  Plan_parser (::geo::Plan_t_pskel& p)
  {
    this->Plan_parser_ = &p;
  }

  void Plans_t_pskel::
  parsers (::geo::Plan_t_pskel& Plan)
  {
    this->Plan_parser_ = &Plan;
  }

  Plans_t_pskel::
  Plans_t_pskel ()
  : Plan_parser_ (0)
  {
  }

  // ColorDuration_t_pskel
  //

  void ColorDuration_t_pskel::
  TrafficColor_parser (::geo::TrafficColor_t_pskel& p)
  {
    this->TrafficColor_parser_ = &p;
  }

  void ColorDuration_t_pskel::
  Duration_parser (::xml_schema::unsigned_byte_pskel& p)
  {
    this->Duration_parser_ = &p;
  }

  void ColorDuration_t_pskel::
  parsers (::geo::TrafficColor_t_pskel& TrafficColor,
           ::xml_schema::unsigned_byte_pskel& Duration)
  {
    this->TrafficColor_parser_ = &TrafficColor;
    this->Duration_parser_ = &Duration;
  }

  ColorDuration_t_pskel::
  ColorDuration_t_pskel ()
  : TrafficColor_parser_ (0),
    Duration_parser_ (0)
  {
  }

  // ColorSequence_t_pskel
  //

  void ColorSequence_t_pskel::
  TrafficLightType_parser (::xml_schema::string_pskel& p)
  {
    this->TrafficLightType_parser_ = &p;
  }

  void ColorSequence_t_pskel::
  ColorDuration_parser (::geo::ColorDuration_t_pskel& p)
  {
    this->ColorDuration_parser_ = &p;
  }

  void ColorSequence_t_pskel::
  parsers (::xml_schema::string_pskel& TrafficLightType,
           ::geo::ColorDuration_t_pskel& ColorDuration)
  {
    this->TrafficLightType_parser_ = &TrafficLightType;
    this->ColorDuration_parser_ = &ColorDuration;
  }

  ColorSequence_t_pskel::
  ColorSequence_t_pskel ()
  : TrafficLightType_parser_ (0),
    ColorDuration_parser_ (0)
  {
  }

  // links_maps_t_pskel
  //

  void links_maps_t_pskel::
  links_map_parser (::geo::links_map_t_pskel& p)
  {
    this->links_map_parser_ = &p;
  }

  void links_maps_t_pskel::
  parsers (::geo::links_map_t_pskel& links_map)
  {
    this->links_map_parser_ = &links_map;
  }

  links_maps_t_pskel::
  links_maps_t_pskel ()
  : links_map_parser_ (0)
  {
  }

  // links_map_t_pskel
  //

  void links_map_t_pskel::
  linkFrom_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->linkFrom_parser_ = &p;
  }

  void links_map_t_pskel::
  linkTo_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->linkTo_parser_ = &p;
  }

  void links_map_t_pskel::
  SegmentFrom_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->SegmentFrom_parser_ = &p;
  }

  void links_map_t_pskel::
  SegmentTo_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->SegmentTo_parser_ = &p;
  }

  void links_map_t_pskel::
  ColorSequence_parser (::geo::ColorSequence_t_pskel& p)
  {
    this->ColorSequence_parser_ = &p;
  }

  void links_map_t_pskel::
  parsers (::xml_schema::unsigned_int_pskel& linkFrom,
           ::xml_schema::unsigned_int_pskel& linkTo,
           ::xml_schema::unsigned_int_pskel& SegmentFrom,
           ::xml_schema::unsigned_int_pskel& SegmentTo,
           ::geo::ColorSequence_t_pskel& ColorSequence)
  {
    this->linkFrom_parser_ = &linkFrom;
    this->linkTo_parser_ = &linkTo;
    this->SegmentFrom_parser_ = &SegmentFrom;
    this->SegmentTo_parser_ = &SegmentTo;
    this->ColorSequence_parser_ = &ColorSequence;
  }

  links_map_t_pskel::
  links_map_t_pskel ()
  : linkFrom_parser_ (0),
    linkTo_parser_ (0),
    SegmentFrom_parser_ (0),
    SegmentTo_parser_ (0),
    ColorSequence_parser_ (0)
  {
  }

  // Phase_t_pskel
  //

  void Phase_t_pskel::
  phaseID_parser (::xml_schema::unsigned_byte_pskel& p)
  {
    this->phaseID_parser_ = &p;
  }

  void Phase_t_pskel::
  name_parser (::xml_schema::string_pskel& p)
  {
    this->name_parser_ = &p;
  }

  void Phase_t_pskel::
  links_map_parser (::geo::links_maps_t_pskel& p)
  {
    this->links_map_parser_ = &p;
  }

  void Phase_t_pskel::
  parsers (::xml_schema::unsigned_byte_pskel& phaseID,
           ::xml_schema::string_pskel& name,
           ::geo::links_maps_t_pskel& links_map)
  {
    this->phaseID_parser_ = &phaseID;
    this->name_parser_ = &name;
    this->links_map_parser_ = &links_map;
  }

  Phase_t_pskel::
  Phase_t_pskel ()
  : phaseID_parser_ (0),
    name_parser_ (0),
    links_map_parser_ (0)
  {
  }

  // Phases_t_pskel
  //

  void Phases_t_pskel::
  Phase_parser (::geo::Phase_t_pskel& p)
  {
    this->Phase_parser_ = &p;
  }

  void Phases_t_pskel::
  parsers (::geo::Phase_t_pskel& Phase)
  {
    this->Phase_parser_ = &Phase;
  }

  Phases_t_pskel::
  Phases_t_pskel ()
  : Phase_parser_ (0)
  {
  }

  // SplitPlan_t_pskel
  //

  void SplitPlan_t_pskel::
  splitplanID_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->splitplanID_parser_ = &p;
  }

  void SplitPlan_t_pskel::
  signalAlgorithm_parser (::geo::signalAlgorithm_t_pskel& p)
  {
    this->signalAlgorithm_parser_ = &p;
  }

  void SplitPlan_t_pskel::
  cycleLength_parser (::xml_schema::unsigned_byte_pskel& p)
  {
    this->cycleLength_parser_ = &p;
  }

  void SplitPlan_t_pskel::
  offset_parser (::xml_schema::unsigned_byte_pskel& p)
  {
    this->offset_parser_ = &p;
  }

  void SplitPlan_t_pskel::
  ChoiceSet_parser (::geo::Plans_t_pskel& p)
  {
    this->ChoiceSet_parser_ = &p;
  }

  void SplitPlan_t_pskel::
  Phases_parser (::geo::Phases_t_pskel& p)
  {
    this->Phases_parser_ = &p;
  }

  void SplitPlan_t_pskel::
  parsers (::xml_schema::unsigned_int_pskel& splitplanID,
           ::geo::signalAlgorithm_t_pskel& signalAlgorithm,
           ::xml_schema::unsigned_byte_pskel& cycleLength,
           ::xml_schema::unsigned_byte_pskel& offset,
           ::geo::Plans_t_pskel& ChoiceSet,
           ::geo::Phases_t_pskel& Phases)
  {
    this->splitplanID_parser_ = &splitplanID;
    this->signalAlgorithm_parser_ = &signalAlgorithm;
    this->cycleLength_parser_ = &cycleLength;
    this->offset_parser_ = &offset;
    this->ChoiceSet_parser_ = &ChoiceSet;
    this->Phases_parser_ = &Phases;
  }

  SplitPlan_t_pskel::
  SplitPlan_t_pskel ()
  : splitplanID_parser_ (0),
    signalAlgorithm_parser_ (0),
    cycleLength_parser_ (0),
    offset_parser_ (0),
    ChoiceSet_parser_ (0),
    Phases_parser_ (0)
  {
  }

  // Signal_t_pskel
  //

  void Signal_t_pskel::
  signalID_parser (::xml_schema::unsigned_byte_pskel& p)
  {
    this->signalID_parser_ = &p;
  }

  void Signal_t_pskel::
  nodeID_parser (::xml_schema::unsigned_int_pskel& p)
  {
    this->nodeID_parser_ = &p;
  }

  void Signal_t_pskel::
  signalAlgorithm_parser (::geo::signalAlgorithm_t_pskel& p)
  {
    this->signalAlgorithm_parser_ = &p;
  }

  void Signal_t_pskel::
  linkAndCrossings_parser (::geo::linkAndCrossings_t_pskel& p)
  {
    this->linkAndCrossings_parser_ = &p;
  }

  void Signal_t_pskel::
  SplitPlan_parser (::geo::SplitPlan_t_pskel& p)
  {
    this->SplitPlan_parser_ = &p;
  }

  void Signal_t_pskel::
  parsers (::xml_schema::unsigned_byte_pskel& signalID,
           ::xml_schema::unsigned_int_pskel& nodeID,
           ::geo::signalAlgorithm_t_pskel& signalAlgorithm,
           ::geo::linkAndCrossings_t_pskel& linkAndCrossings,
           ::geo::SplitPlan_t_pskel& SplitPlan)
  {
    this->signalID_parser_ = &signalID;
    this->nodeID_parser_ = &nodeID;
    this->signalAlgorithm_parser_ = &signalAlgorithm;
    this->linkAndCrossings_parser_ = &linkAndCrossings;
    this->SplitPlan_parser_ = &SplitPlan;
  }

  Signal_t_pskel::
  Signal_t_pskel ()
  : signalID_parser_ (0),
    nodeID_parser_ (0),
    signalAlgorithm_parser_ (0),
    linkAndCrossings_parser_ (0),
    SplitPlan_parser_ (0)
  {
  }

  // Signals_t_pskel
  //

  void Signals_t_pskel::
  signal_parser (::geo::Signal_t_pskel& p)
  {
    this->signal_parser_ = &p;
  }

  void Signals_t_pskel::
  parsers (::geo::Signal_t_pskel& signal)
  {
    this->signal_parser_ = &signal;
  }

  Signals_t_pskel::
  Signals_t_pskel ()
  : signal_parser_ (0)
  {
  }

  // GeoSpatial_t_pskel
  //

  void GeoSpatial_t_pskel::
  RoadNetwork_parser (::geo::RoadNetwork_t_pskel& p)
  {
    this->RoadNetwork_parser_ = &p;
  }

  void GeoSpatial_t_pskel::
  parsers (::geo::RoadNetwork_t_pskel& RoadNetwork)
  {
    this->RoadNetwork_parser_ = &RoadNetwork;
  }

  GeoSpatial_t_pskel::
  GeoSpatial_t_pskel ()
  : RoadNetwork_parser_ (0)
  {
  }

  // SimMobility_t_pskel
  //

  void SimMobility_t_pskel::
  GeoSpatial_parser (::geo::GeoSpatial_t_pskel& p)
  {
    this->GeoSpatial_parser_ = &p;
  }

  void SimMobility_t_pskel::
  TripChains_parser (::geo::TripChains_t_pskel& p)
  {
    this->TripChains_parser_ = &p;
  }

  void SimMobility_t_pskel::
  Signals_parser (::geo::Signals_t_pskel& p)
  {
    this->Signals_parser_ = &p;
  }

  void SimMobility_t_pskel::
  parsers (::geo::GeoSpatial_t_pskel& GeoSpatial,
           ::geo::TripChains_t_pskel& TripChains,
           ::geo::Signals_t_pskel& Signals)
  {
    this->GeoSpatial_parser_ = &GeoSpatial;
    this->TripChains_parser_ = &TripChains;
    this->Signals_parser_ = &Signals;
  }

  SimMobility_t_pskel::
  SimMobility_t_pskel ()
  : GeoSpatial_parser_ (0),
    TripChains_parser_ (0),
    Signals_parser_ (0)
  {
  }

  // Lanes_pskel
  //

  void Lanes_pskel::
  Lane_parser (::geo::lane_t_pskel& p)
  {
    this->Lane_parser_ = &p;
  }

  void Lanes_pskel::
  parsers (::geo::lane_t_pskel& Lane)
  {
    this->Lane_parser_ = &Lane;
  }

  Lanes_pskel::
  Lanes_pskel ()
  : Lane_parser_ (0)
  {
  }

  // Segments_pskel
  //

  void Segments_pskel::
  FWDSegments_parser (::geo::fwdBckSegments_t_pskel& p)
  {
    this->FWDSegments_parser_ = &p;
  }

  void Segments_pskel::
  BKDSegments_parser (::geo::fwdBckSegments_t_pskel& p)
  {
    this->BKDSegments_parser_ = &p;
  }

  void Segments_pskel::
  parsers (::geo::fwdBckSegments_t_pskel& FWDSegments,
           ::geo::fwdBckSegments_t_pskel& BKDSegments)
  {
    this->FWDSegments_parser_ = &FWDSegments;
    this->BKDSegments_parser_ = &BKDSegments;
  }

  Segments_pskel::
  Segments_pskel ()
  : FWDSegments_parser_ (0),
    BKDSegments_parser_ (0)
  {
  }

  // Nodes_pskel
  //

  void Nodes_pskel::
  UniNodes_parser (::geo::UniNodes_pskel& p)
  {
    this->UniNodes_parser_ = &p;
  }

  void Nodes_pskel::
  Intersections_parser (::geo::Intersections_pskel& p)
  {
    this->Intersections_parser_ = &p;
  }

  void Nodes_pskel::
  roundabouts_parser (::geo::roundabouts_pskel& p)
  {
    this->roundabouts_parser_ = &p;
  }

  void Nodes_pskel::
  parsers (::geo::UniNodes_pskel& UniNodes,
           ::geo::Intersections_pskel& Intersections,
           ::geo::roundabouts_pskel& roundabouts)
  {
    this->UniNodes_parser_ = &UniNodes;
    this->Intersections_parser_ = &Intersections;
    this->roundabouts_parser_ = &roundabouts;
  }

  Nodes_pskel::
  Nodes_pskel ()
  : UniNodes_parser_ (0),
    Intersections_parser_ (0),
    roundabouts_parser_ (0)
  {
  }

  // Links_pskel
  //

  void Links_pskel::
  Link_parser (::geo::link_t_pskel& p)
  {
    this->Link_parser_ = &p;
  }

  void Links_pskel::
  parsers (::geo::link_t_pskel& Link)
  {
    this->Link_parser_ = &Link;
  }

  Links_pskel::
  Links_pskel ()
  : Link_parser_ (0)
  {
  }

  // UniNodes_pskel
  //

  void UniNodes_pskel::
  UniNode_parser (::geo::UniNode_t_pskel& p)
  {
    this->UniNode_parser_ = &p;
  }

  void UniNodes_pskel::
  parsers (::geo::UniNode_t_pskel& UniNode)
  {
    this->UniNode_parser_ = &UniNode;
  }

  UniNodes_pskel::
  UniNodes_pskel ()
  : UniNode_parser_ (0)
  {
  }

  // Intersections_pskel
  //

  void Intersections_pskel::
  Intersection_parser (::geo::intersection_t_pskel& p)
  {
    this->Intersection_parser_ = &p;
  }

  void Intersections_pskel::
  parsers (::geo::intersection_t_pskel& Intersection)
  {
    this->Intersection_parser_ = &Intersection;
  }

  Intersections_pskel::
  Intersections_pskel ()
  : Intersection_parser_ (0)
  {
  }

  // roundabouts_pskel
  //

  void roundabouts_pskel::
  roundabout_parser (::geo::roundabout_t_pskel& p)
  {
    this->roundabout_parser_ = &p;
  }

  void roundabouts_pskel::
  parsers (::geo::roundabout_t_pskel& roundabout)
  {
    this->roundabout_parser_ = &roundabout;
  }

  roundabouts_pskel::
  roundabouts_pskel ()
  : roundabout_parser_ (0)
  {
  }
}

namespace geo
{
  // Point2D_t_pskel
  //

  void Point2D_t_pskel::
  xPos (unsigned int)
  {
  }

  void Point2D_t_pskel::
  yPos (unsigned int)
  {
  }

  bool Point2D_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "xPos" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->xPos_parser_;

      if (this->xPos_parser_)
        this->xPos_parser_->pre ();

      return true;
    }

    if (n == "yPos" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->yPos_parser_;

      if (this->yPos_parser_)
        this->yPos_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Point2D_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "xPos" && ns.empty ())
    {
      if (this->xPos_parser_)
        this->xPos (this->xPos_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "yPos" && ns.empty ())
    {
      if (this->yPos_parser_)
        this->yPos (this->yPos_parser_->post_unsigned_int ());

      return true;
    }

    return false;
  }

  // PolyPoint_t_pskel
  //

  void PolyPoint_t_pskel::
  pointID (const ::std::string&)
  {
  }

  void PolyPoint_t_pskel::
  location (sim_mob::Point2D)
  {
  }

  bool PolyPoint_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "pointID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->pointID_parser_;

      if (this->pointID_parser_)
        this->pointID_parser_->pre ();

      return true;
    }

    if (n == "location" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->location_parser_;

      if (this->location_parser_)
        this->location_parser_->pre ();

      return true;
    }

    return false;
  }

  bool PolyPoint_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "pointID" && ns.empty ())
    {
      if (this->pointID_parser_)
        this->pointID (this->pointID_parser_->post_string ());

      return true;
    }

    if (n == "location" && ns.empty ())
    {
      if (this->location_parser_)
        this->location (this->location_parser_->post_Point2D_t ());

      return true;
    }

    return false;
  }

  // PolyLine_t_pskel
  //

  void PolyLine_t_pskel::
  PolyPoint (sim_mob::Point2D)
  {
  }

  bool PolyLine_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "PolyPoint" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->PolyPoint_parser_;

      if (this->PolyPoint_parser_)
        this->PolyPoint_parser_->pre ();

      return true;
    }

    return false;
  }

  bool PolyLine_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "PolyPoint" && ns.empty ())
    {
      if (this->PolyPoint_parser_)
        this->PolyPoint (this->PolyPoint_parser_->post_PolyPoint_t ());

      return true;
    }

    return false;
  }

  // lane_t_pskel
  //

  void lane_t_pskel::
  laneID (unsigned long long)
  {
  }

  void lane_t_pskel::
  width (unsigned int)
  {
  }

  void lane_t_pskel::
  can_go_straight (bool)
  {
  }

  void lane_t_pskel::
  can_turn_left (bool)
  {
  }

  void lane_t_pskel::
  can_turn_right (bool)
  {
  }

  void lane_t_pskel::
  can_turn_on_red_signal (bool)
  {
  }

  void lane_t_pskel::
  can_change_lane_left (bool)
  {
  }

  void lane_t_pskel::
  can_change_lane_right (bool)
  {
  }

  void lane_t_pskel::
  is_road_shoulder (bool)
  {
  }

  void lane_t_pskel::
  is_bicycle_lane (bool)
  {
  }

  void lane_t_pskel::
  is_pedestrian_lane (bool)
  {
  }

  void lane_t_pskel::
  is_vehicle_lane (bool)
  {
  }

  void lane_t_pskel::
  is_standard_bus_lane (bool)
  {
  }

  void lane_t_pskel::
  is_whole_day_bus_lane (bool)
  {
  }

  void lane_t_pskel::
  is_high_occupancy_vehicle_lane (bool)
  {
  }

  void lane_t_pskel::
  can_freely_park_here (bool)
  {
  }

  void lane_t_pskel::
  can_stop_here (bool)
  {
  }

  void lane_t_pskel::
  is_u_turn_allowed (bool)
  {
  }

  void lane_t_pskel::
  PolyLine (std::vector<sim_mob::Point2D>)
  {
  }

  bool lane_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "laneID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->laneID_parser_;

      if (this->laneID_parser_)
        this->laneID_parser_->pre ();

      return true;
    }

    if (n == "width" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->width_parser_;

      if (this->width_parser_)
        this->width_parser_->pre ();

      return true;
    }

    if (n == "can_go_straight" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->can_go_straight_parser_;

      if (this->can_go_straight_parser_)
        this->can_go_straight_parser_->pre ();

      return true;
    }

    if (n == "can_turn_left" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->can_turn_left_parser_;

      if (this->can_turn_left_parser_)
        this->can_turn_left_parser_->pre ();

      return true;
    }

    if (n == "can_turn_right" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->can_turn_right_parser_;

      if (this->can_turn_right_parser_)
        this->can_turn_right_parser_->pre ();

      return true;
    }

    if (n == "can_turn_on_red_signal" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->can_turn_on_red_signal_parser_;

      if (this->can_turn_on_red_signal_parser_)
        this->can_turn_on_red_signal_parser_->pre ();

      return true;
    }

    if (n == "can_change_lane_left" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->can_change_lane_left_parser_;

      if (this->can_change_lane_left_parser_)
        this->can_change_lane_left_parser_->pre ();

      return true;
    }

    if (n == "can_change_lane_right" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->can_change_lane_right_parser_;

      if (this->can_change_lane_right_parser_)
        this->can_change_lane_right_parser_->pre ();

      return true;
    }

    if (n == "is_road_shoulder" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->is_road_shoulder_parser_;

      if (this->is_road_shoulder_parser_)
        this->is_road_shoulder_parser_->pre ();

      return true;
    }

    if (n == "is_bicycle_lane" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->is_bicycle_lane_parser_;

      if (this->is_bicycle_lane_parser_)
        this->is_bicycle_lane_parser_->pre ();

      return true;
    }

    if (n == "is_pedestrian_lane" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->is_pedestrian_lane_parser_;

      if (this->is_pedestrian_lane_parser_)
        this->is_pedestrian_lane_parser_->pre ();

      return true;
    }

    if (n == "is_vehicle_lane" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->is_vehicle_lane_parser_;

      if (this->is_vehicle_lane_parser_)
        this->is_vehicle_lane_parser_->pre ();

      return true;
    }

    if (n == "is_standard_bus_lane" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->is_standard_bus_lane_parser_;

      if (this->is_standard_bus_lane_parser_)
        this->is_standard_bus_lane_parser_->pre ();

      return true;
    }

    if (n == "is_whole_day_bus_lane" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->is_whole_day_bus_lane_parser_;

      if (this->is_whole_day_bus_lane_parser_)
        this->is_whole_day_bus_lane_parser_->pre ();

      return true;
    }

    if (n == "is_high_occupancy_vehicle_lane" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->is_high_occupancy_vehicle_lane_parser_;

      if (this->is_high_occupancy_vehicle_lane_parser_)
        this->is_high_occupancy_vehicle_lane_parser_->pre ();

      return true;
    }

    if (n == "can_freely_park_here" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->can_freely_park_here_parser_;

      if (this->can_freely_park_here_parser_)
        this->can_freely_park_here_parser_->pre ();

      return true;
    }

    if (n == "can_stop_here" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->can_stop_here_parser_;

      if (this->can_stop_here_parser_)
        this->can_stop_here_parser_->pre ();

      return true;
    }

    if (n == "is_u_turn_allowed" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->is_u_turn_allowed_parser_;

      if (this->is_u_turn_allowed_parser_)
        this->is_u_turn_allowed_parser_->pre ();

      return true;
    }

    if (n == "PolyLine" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->PolyLine_parser_;

      if (this->PolyLine_parser_)
        this->PolyLine_parser_->pre ();

      return true;
    }

    return false;
  }

  bool lane_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "laneID" && ns.empty ())
    {
      if (this->laneID_parser_)
        this->laneID (this->laneID_parser_->post_unsigned_long ());

      return true;
    }

    if (n == "width" && ns.empty ())
    {
      if (this->width_parser_)
        this->width (this->width_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "can_go_straight" && ns.empty ())
    {
      if (this->can_go_straight_parser_)
        this->can_go_straight (this->can_go_straight_parser_->post_boolean ());

      return true;
    }

    if (n == "can_turn_left" && ns.empty ())
    {
      if (this->can_turn_left_parser_)
        this->can_turn_left (this->can_turn_left_parser_->post_boolean ());

      return true;
    }

    if (n == "can_turn_right" && ns.empty ())
    {
      if (this->can_turn_right_parser_)
        this->can_turn_right (this->can_turn_right_parser_->post_boolean ());

      return true;
    }

    if (n == "can_turn_on_red_signal" && ns.empty ())
    {
      if (this->can_turn_on_red_signal_parser_)
        this->can_turn_on_red_signal (this->can_turn_on_red_signal_parser_->post_boolean ());

      return true;
    }

    if (n == "can_change_lane_left" && ns.empty ())
    {
      if (this->can_change_lane_left_parser_)
        this->can_change_lane_left (this->can_change_lane_left_parser_->post_boolean ());

      return true;
    }

    if (n == "can_change_lane_right" && ns.empty ())
    {
      if (this->can_change_lane_right_parser_)
        this->can_change_lane_right (this->can_change_lane_right_parser_->post_boolean ());

      return true;
    }

    if (n == "is_road_shoulder" && ns.empty ())
    {
      if (this->is_road_shoulder_parser_)
        this->is_road_shoulder (this->is_road_shoulder_parser_->post_boolean ());

      return true;
    }

    if (n == "is_bicycle_lane" && ns.empty ())
    {
      if (this->is_bicycle_lane_parser_)
        this->is_bicycle_lane (this->is_bicycle_lane_parser_->post_boolean ());

      return true;
    }

    if (n == "is_pedestrian_lane" && ns.empty ())
    {
      if (this->is_pedestrian_lane_parser_)
        this->is_pedestrian_lane (this->is_pedestrian_lane_parser_->post_boolean ());

      return true;
    }

    if (n == "is_vehicle_lane" && ns.empty ())
    {
      if (this->is_vehicle_lane_parser_)
        this->is_vehicle_lane (this->is_vehicle_lane_parser_->post_boolean ());

      return true;
    }

    if (n == "is_standard_bus_lane" && ns.empty ())
    {
      if (this->is_standard_bus_lane_parser_)
        this->is_standard_bus_lane (this->is_standard_bus_lane_parser_->post_boolean ());

      return true;
    }

    if (n == "is_whole_day_bus_lane" && ns.empty ())
    {
      if (this->is_whole_day_bus_lane_parser_)
        this->is_whole_day_bus_lane (this->is_whole_day_bus_lane_parser_->post_boolean ());

      return true;
    }

    if (n == "is_high_occupancy_vehicle_lane" && ns.empty ())
    {
      if (this->is_high_occupancy_vehicle_lane_parser_)
        this->is_high_occupancy_vehicle_lane (this->is_high_occupancy_vehicle_lane_parser_->post_boolean ());

      return true;
    }

    if (n == "can_freely_park_here" && ns.empty ())
    {
      if (this->can_freely_park_here_parser_)
        this->can_freely_park_here (this->can_freely_park_here_parser_->post_boolean ());

      return true;
    }

    if (n == "can_stop_here" && ns.empty ())
    {
      if (this->can_stop_here_parser_)
        this->can_stop_here (this->can_stop_here_parser_->post_boolean ());

      return true;
    }

    if (n == "is_u_turn_allowed" && ns.empty ())
    {
      if (this->is_u_turn_allowed_parser_)
        this->is_u_turn_allowed (this->is_u_turn_allowed_parser_->post_boolean ());

      return true;
    }

    if (n == "PolyLine" && ns.empty ())
    {
      if (this->PolyLine_parser_)
        this->PolyLine (this->PolyLine_parser_->post_PolyLine_t ());

      return true;
    }

    return false;
  }

  // connector_t_pskel
  //

  void connector_t_pskel::
  laneFrom (unsigned long long)
  {
  }

  void connector_t_pskel::
  laneTo (unsigned long long)
  {
  }

  bool connector_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "laneFrom" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->laneFrom_parser_;

      if (this->laneFrom_parser_)
        this->laneFrom_parser_->pre ();

      return true;
    }

    if (n == "laneTo" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->laneTo_parser_;

      if (this->laneTo_parser_)
        this->laneTo_parser_->pre ();

      return true;
    }

    return false;
  }

  bool connector_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "laneFrom" && ns.empty ())
    {
      if (this->laneFrom_parser_)
        this->laneFrom (this->laneFrom_parser_->post_unsigned_long ());

      return true;
    }

    if (n == "laneTo" && ns.empty ())
    {
      if (this->laneTo_parser_)
        this->laneTo (this->laneTo_parser_->post_unsigned_long ());

      return true;
    }

    return false;
  }

  // connectors_t_pskel
  //

  void connectors_t_pskel::
  Connector (std::pair<unsigned long,unsigned long>)
  {
  }

  bool connectors_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "Connector" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Connector_parser_;

      if (this->Connector_parser_)
        this->Connector_parser_->pre ();

      return true;
    }

    return false;
  }

  bool connectors_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "Connector" && ns.empty ())
    {
      if (this->Connector_parser_)
        this->Connector (this->Connector_parser_->post_connector_t ());

      return true;
    }

    return false;
  }

  // Multi_Connector_t_pskel
  //

  void Multi_Connector_t_pskel::
  RoadSegment (unsigned long long)
  {
  }

  void Multi_Connector_t_pskel::
  Connectors (std::set<std::pair<unsigned long,unsigned long> >)
  {
  }

  bool Multi_Connector_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "RoadSegment" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->RoadSegment_parser_;

      if (this->RoadSegment_parser_)
        this->RoadSegment_parser_->pre ();

      return true;
    }

    if (n == "Connectors" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Connectors_parser_;

      if (this->Connectors_parser_)
        this->Connectors_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Multi_Connector_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "RoadSegment" && ns.empty ())
    {
      if (this->RoadSegment_parser_)
        this->RoadSegment (this->RoadSegment_parser_->post_unsigned_long ());

      return true;
    }

    if (n == "Connectors" && ns.empty ())
    {
      if (this->Connectors_parser_)
        this->Connectors (this->Connectors_parser_->post_connectors_t ());

      return true;
    }

    return false;
  }

  // Multi_Connectors_t_pskel
  //

  void Multi_Connectors_t_pskel::
  MultiConnectors (const std::pair<unsigned long,std::set<std::pair<unsigned long,unsigned long> > >&)
  {
  }

  bool Multi_Connectors_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "MultiConnectors" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->MultiConnectors_parser_;

      if (this->MultiConnectors_parser_)
        this->MultiConnectors_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Multi_Connectors_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "MultiConnectors" && ns.empty ())
    {
      if (this->MultiConnectors_parser_)
        this->MultiConnectors (this->MultiConnectors_parser_->post_Multi_Connector_t ());

      return true;
    }

    return false;
  }

  // fwdBckSegments_t_pskel
  //

  void fwdBckSegments_t_pskel::
  Segment (sim_mob::RoadSegment*)
  {
  }

  bool fwdBckSegments_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "Segment" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Segment_parser_;

      if (this->Segment_parser_)
        this->Segment_parser_->pre ();

      return true;
    }

    return false;
  }

  bool fwdBckSegments_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "Segment" && ns.empty ())
    {
      if (this->Segment_parser_)
        this->Segment (this->Segment_parser_->post_segment_t ());

      return true;
    }

    return false;
  }

  // RoadSegmentsAt_t_pskel
  //

  void RoadSegmentsAt_t_pskel::
  segmentID (unsigned long long)
  {
  }

  bool RoadSegmentsAt_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "segmentID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->segmentID_parser_;

      if (this->segmentID_parser_)
        this->segmentID_parser_->pre ();

      return true;
    }

    return false;
  }

  bool RoadSegmentsAt_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "segmentID" && ns.empty ())
    {
      if (this->segmentID_parser_)
        this->segmentID (this->segmentID_parser_->post_unsigned_long ());

      return true;
    }

    return false;
  }

  // laneEdgePolyline_cached_t_pskel
  //

  void laneEdgePolyline_cached_t_pskel::
  laneNumber (short)
  {
  }

  void laneEdgePolyline_cached_t_pskel::
  polyline (std::vector<sim_mob::Point2D>)
  {
  }

  bool laneEdgePolyline_cached_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "laneNumber" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->laneNumber_parser_;

      if (this->laneNumber_parser_)
        this->laneNumber_parser_->pre ();

      return true;
    }

    if (n == "polyline" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->polyline_parser_;

      if (this->polyline_parser_)
        this->polyline_parser_->pre ();

      return true;
    }

    return false;
  }

  bool laneEdgePolyline_cached_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "laneNumber" && ns.empty ())
    {
      if (this->laneNumber_parser_)
        this->laneNumber (this->laneNumber_parser_->post_short ());

      return true;
    }

    if (n == "polyline" && ns.empty ())
    {
      if (this->polyline_parser_)
        this->polyline (this->polyline_parser_->post_PolyLine_t ());

      return true;
    }

    return false;
  }

  // laneEdgePolylines_cached_t_pskel
  //

  void laneEdgePolylines_cached_t_pskel::
  laneEdgePolyline_cached (std::pair<short,std::vector<sim_mob::Point2D> >)
  {
  }

  bool laneEdgePolylines_cached_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "laneEdgePolyline_cached" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->laneEdgePolyline_cached_parser_;

      if (this->laneEdgePolyline_cached_parser_)
        this->laneEdgePolyline_cached_parser_->pre ();

      return true;
    }

    return false;
  }

  bool laneEdgePolylines_cached_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "laneEdgePolyline_cached" && ns.empty ())
    {
      if (this->laneEdgePolyline_cached_parser_)
        this->laneEdgePolyline_cached (this->laneEdgePolyline_cached_parser_->post_laneEdgePolyline_cached_t ());

      return true;
    }

    return false;
  }

  // segment_t_pskel
  //

  void segment_t_pskel::
  segmentID (unsigned long long)
  {
  }

  void segment_t_pskel::
  startingNode (unsigned int)
  {
  }

  void segment_t_pskel::
  endingNode (unsigned int)
  {
  }

  void segment_t_pskel::
  maxSpeed (short)
  {
  }

  void segment_t_pskel::
  Length (unsigned int)
  {
  }

  void segment_t_pskel::
  Width (unsigned int)
  {
  }

  void segment_t_pskel::
  originalDB_ID (const ::std::string&)
  {
  }

  void segment_t_pskel::
  polyline (std::vector<sim_mob::Point2D>)
  {
  }

  void segment_t_pskel::
  laneEdgePolylines_cached (std::vector<std::vector<sim_mob::Point2D> >)
  {
  }

  void segment_t_pskel::
  Lanes (std::vector<sim_mob::Lane*>)
  {
  }

  void segment_t_pskel::
  Obstacles (std::map<sim_mob::centimeter_t,const RoadItem*>)
  {
  }

  void segment_t_pskel::
  KurbLine (std::vector<sim_mob::Point2D>)
  {
  }

  bool segment_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "segmentID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->segmentID_parser_;

      if (this->segmentID_parser_)
        this->segmentID_parser_->pre ();

      return true;
    }

    if (n == "startingNode" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->startingNode_parser_;

      if (this->startingNode_parser_)
        this->startingNode_parser_->pre ();

      return true;
    }

    if (n == "endingNode" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->endingNode_parser_;

      if (this->endingNode_parser_)
        this->endingNode_parser_->pre ();

      return true;
    }

    if (n == "maxSpeed" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->maxSpeed_parser_;

      if (this->maxSpeed_parser_)
        this->maxSpeed_parser_->pre ();

      return true;
    }

    if (n == "Length" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Length_parser_;

      if (this->Length_parser_)
        this->Length_parser_->pre ();

      return true;
    }

    if (n == "Width" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Width_parser_;

      if (this->Width_parser_)
        this->Width_parser_->pre ();

      return true;
    }

    if (n == "originalDB_ID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->originalDB_ID_parser_;

      if (this->originalDB_ID_parser_)
        this->originalDB_ID_parser_->pre ();

      return true;
    }

    if (n == "polyline" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->polyline_parser_;

      if (this->polyline_parser_)
        this->polyline_parser_->pre ();

      return true;
    }

    if (n == "laneEdgePolylines_cached" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->laneEdgePolylines_cached_parser_;

      if (this->laneEdgePolylines_cached_parser_)
        this->laneEdgePolylines_cached_parser_->pre ();

      return true;
    }

    if (n == "Lanes" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Lanes_parser_;

      if (this->Lanes_parser_)
        this->Lanes_parser_->pre ();

      return true;
    }

    if (n == "Obstacles" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Obstacles_parser_;

      if (this->Obstacles_parser_)
        this->Obstacles_parser_->pre ();

      return true;
    }

    if (n == "KurbLine" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->KurbLine_parser_;

      if (this->KurbLine_parser_)
        this->KurbLine_parser_->pre ();

      return true;
    }

    return false;
  }

  bool segment_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "segmentID" && ns.empty ())
    {
      if (this->segmentID_parser_)
        this->segmentID (this->segmentID_parser_->post_unsigned_long ());

      return true;
    }

    if (n == "startingNode" && ns.empty ())
    {
      if (this->startingNode_parser_)
        this->startingNode (this->startingNode_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "endingNode" && ns.empty ())
    {
      if (this->endingNode_parser_)
        this->endingNode (this->endingNode_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "maxSpeed" && ns.empty ())
    {
      if (this->maxSpeed_parser_)
        this->maxSpeed (this->maxSpeed_parser_->post_short ());

      return true;
    }

    if (n == "Length" && ns.empty ())
    {
      if (this->Length_parser_)
        this->Length (this->Length_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "Width" && ns.empty ())
    {
      if (this->Width_parser_)
        this->Width (this->Width_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "originalDB_ID" && ns.empty ())
    {
      if (this->originalDB_ID_parser_)
        this->originalDB_ID (this->originalDB_ID_parser_->post_string ());

      return true;
    }

    if (n == "polyline" && ns.empty ())
    {
      if (this->polyline_parser_)
        this->polyline (this->polyline_parser_->post_PolyLine_t ());

      return true;
    }

    if (n == "laneEdgePolylines_cached" && ns.empty ())
    {
      if (this->laneEdgePolylines_cached_parser_)
        this->laneEdgePolylines_cached (this->laneEdgePolylines_cached_parser_->post_laneEdgePolylines_cached_t ());

      return true;
    }

    if (n == "Lanes" && ns.empty ())
    {
      if (this->Lanes_parser_)
        this->Lanes (this->Lanes_parser_->post_Lanes ());

      return true;
    }

    if (n == "Obstacles" && ns.empty ())
    {
      if (this->Obstacles_parser_)
        this->Obstacles (this->Obstacles_parser_->post_RoadItems_t ());

      return true;
    }

    if (n == "KurbLine" && ns.empty ())
    {
      if (this->KurbLine_parser_)
        this->KurbLine (this->KurbLine_parser_->post_PolyLine_t ());

      return true;
    }

    return false;
  }

  // link_t_pskel
  //

  void link_t_pskel::
  linkID (unsigned int)
  {
  }

  void link_t_pskel::
  roadName (const ::std::string&)
  {
  }

  void link_t_pskel::
  StartingNode (unsigned int)
  {
  }

  void link_t_pskel::
  EndingNode (unsigned int)
  {
  }

  void link_t_pskel::
  Segments (std::pair<std::vector<sim_mob::RoadSegment*>,std::vector<sim_mob::RoadSegment*> >)
  {
  }

  bool link_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "linkID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->linkID_parser_;

      if (this->linkID_parser_)
        this->linkID_parser_->pre ();

      return true;
    }

    if (n == "roadName" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->roadName_parser_;

      if (this->roadName_parser_)
        this->roadName_parser_->pre ();

      return true;
    }

    if (n == "StartingNode" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->StartingNode_parser_;

      if (this->StartingNode_parser_)
        this->StartingNode_parser_->pre ();

      return true;
    }

    if (n == "EndingNode" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->EndingNode_parser_;

      if (this->EndingNode_parser_)
        this->EndingNode_parser_->pre ();

      return true;
    }

    if (n == "Segments" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Segments_parser_;

      if (this->Segments_parser_)
        this->Segments_parser_->pre ();

      return true;
    }

    return false;
  }

  bool link_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "linkID" && ns.empty ())
    {
      if (this->linkID_parser_)
        this->linkID (this->linkID_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "roadName" && ns.empty ())
    {
      if (this->roadName_parser_)
        this->roadName (this->roadName_parser_->post_string ());

      return true;
    }

    if (n == "StartingNode" && ns.empty ())
    {
      if (this->StartingNode_parser_)
        this->StartingNode (this->StartingNode_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "EndingNode" && ns.empty ())
    {
      if (this->EndingNode_parser_)
        this->EndingNode (this->EndingNode_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "Segments" && ns.empty ())
    {
      if (this->Segments_parser_)
        this->Segments (this->Segments_parser_->post_Segments ());

      return true;
    }

    return false;
  }

  // separator_t_pskel
  //

  void separator_t_pskel::
  separator_ID (unsigned short)
  {
  }

  void separator_t_pskel::
  separator_value (bool)
  {
  }

  void separator_t_pskel::
  post_separator_t ()
  {
  }

  bool separator_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "separator_ID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->separator_ID_parser_;

      if (this->separator_ID_parser_)
        this->separator_ID_parser_->pre ();

      return true;
    }

    if (n == "separator_value" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->separator_value_parser_;

      if (this->separator_value_parser_)
        this->separator_value_parser_->pre ();

      return true;
    }

    return false;
  }

  bool separator_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "separator_ID" && ns.empty ())
    {
      if (this->separator_ID_parser_)
        this->separator_ID (this->separator_ID_parser_->post_unsigned_short ());

      return true;
    }

    if (n == "separator_value" && ns.empty ())
    {
      if (this->separator_value_parser_)
        this->separator_value (this->separator_value_parser_->post_boolean ());

      return true;
    }

    return false;
  }

  // separators_t_pskel
  //

  void separators_t_pskel::
  Separator ()
  {
  }

  void separators_t_pskel::
  post_separators_t ()
  {
  }

  bool separators_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "Separator" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Separator_parser_;

      if (this->Separator_parser_)
        this->Separator_parser_->pre ();

      return true;
    }

    return false;
  }

  bool separators_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "Separator" && ns.empty ())
    {
      if (this->Separator_parser_)
      {
        this->Separator_parser_->post_separator_t ();
        this->Separator ();
      }

      return true;
    }

    return false;
  }

  // DomainIsland_t_pskel
  //

  void DomainIsland_t_pskel::
  domainIsland_ID (unsigned short)
  {
  }

  void DomainIsland_t_pskel::
  domainIsland_value (bool)
  {
  }

  void DomainIsland_t_pskel::
  post_DomainIsland_t ()
  {
  }

  bool DomainIsland_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "domainIsland_ID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->domainIsland_ID_parser_;

      if (this->domainIsland_ID_parser_)
        this->domainIsland_ID_parser_->pre ();

      return true;
    }

    if (n == "domainIsland_value" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->domainIsland_value_parser_;

      if (this->domainIsland_value_parser_)
        this->domainIsland_value_parser_->pre ();

      return true;
    }

    return false;
  }

  bool DomainIsland_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "domainIsland_ID" && ns.empty ())
    {
      if (this->domainIsland_ID_parser_)
        this->domainIsland_ID (this->domainIsland_ID_parser_->post_unsigned_short ());

      return true;
    }

    if (n == "domainIsland_value" && ns.empty ())
    {
      if (this->domainIsland_value_parser_)
        this->domainIsland_value (this->domainIsland_value_parser_->post_boolean ());

      return true;
    }

    return false;
  }

  // DomainIslands_t_pskel
  //

  void DomainIslands_t_pskel::
  domainIslands ()
  {
  }

  void DomainIslands_t_pskel::
  post_DomainIslands_t ()
  {
  }

  bool DomainIslands_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "domainIslands" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->domainIslands_parser_;

      if (this->domainIslands_parser_)
        this->domainIslands_parser_->pre ();

      return true;
    }

    return false;
  }

  bool DomainIslands_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "domainIslands" && ns.empty ())
    {
      if (this->domainIslands_parser_)
      {
        this->domainIslands_parser_->post_DomainIsland_t ();
        this->domainIslands ();
      }

      return true;
    }

    return false;
  }

  // offset_t_pskel
  //

  void offset_t_pskel::
  offset_ID (unsigned short)
  {
  }

  void offset_t_pskel::
  offset_value (unsigned int)
  {
  }

  void offset_t_pskel::
  post_offset_t ()
  {
  }

  bool offset_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "offset_ID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->offset_ID_parser_;

      if (this->offset_ID_parser_)
        this->offset_ID_parser_->pre ();

      return true;
    }

    if (n == "offset_value" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->offset_value_parser_;

      if (this->offset_value_parser_)
        this->offset_value_parser_->pre ();

      return true;
    }

    return false;
  }

  bool offset_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "offset_ID" && ns.empty ())
    {
      if (this->offset_ID_parser_)
        this->offset_ID (this->offset_ID_parser_->post_unsigned_short ());

      return true;
    }

    if (n == "offset_value" && ns.empty ())
    {
      if (this->offset_value_parser_)
        this->offset_value (this->offset_value_parser_->post_unsigned_int ());

      return true;
    }

    return false;
  }

  // offsets_t_pskel
  //

  void offsets_t_pskel::
  offset ()
  {
  }

  void offsets_t_pskel::
  post_offsets_t ()
  {
  }

  bool offsets_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "offset" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->offset_parser_;

      if (this->offset_parser_)
        this->offset_parser_->pre ();

      return true;
    }

    return false;
  }

  bool offsets_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "offset" && ns.empty ())
    {
      if (this->offset_parser_)
      {
        this->offset_parser_->post_offset_t ();
        this->offset ();
      }

      return true;
    }

    return false;
  }

  // ChunkLength_t_pskel
  //

  void ChunkLength_t_pskel::
  chunklength_ID (unsigned short)
  {
  }

  void ChunkLength_t_pskel::
  chunklength_value (unsigned int)
  {
  }

  void ChunkLength_t_pskel::
  post_ChunkLength_t ()
  {
  }

  bool ChunkLength_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "chunklength_ID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->chunklength_ID_parser_;

      if (this->chunklength_ID_parser_)
        this->chunklength_ID_parser_->pre ();

      return true;
    }

    if (n == "chunklength_value" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->chunklength_value_parser_;

      if (this->chunklength_value_parser_)
        this->chunklength_value_parser_->pre ();

      return true;
    }

    return false;
  }

  bool ChunkLength_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "chunklength_ID" && ns.empty ())
    {
      if (this->chunklength_ID_parser_)
        this->chunklength_ID (this->chunklength_ID_parser_->post_unsigned_short ());

      return true;
    }

    if (n == "chunklength_value" && ns.empty ())
    {
      if (this->chunklength_value_parser_)
        this->chunklength_value (this->chunklength_value_parser_->post_unsigned_int ());

      return true;
    }

    return false;
  }

  // ChunkLengths_t_pskel
  //

  void ChunkLengths_t_pskel::
  chunklength ()
  {
  }

  void ChunkLengths_t_pskel::
  post_ChunkLengths_t ()
  {
  }

  bool ChunkLengths_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "chunklength" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->chunklength_parser_;

      if (this->chunklength_parser_)
        this->chunklength_parser_->pre ();

      return true;
    }

    return false;
  }

  bool ChunkLengths_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "chunklength" && ns.empty ())
    {
      if (this->chunklength_parser_)
      {
        this->chunklength_parser_->post_ChunkLength_t ();
        this->chunklength ();
      }

      return true;
    }

    return false;
  }

  // LanesVector_t_pskel
  //

  void LanesVector_t_pskel::
  laneID (unsigned long long)
  {
  }

  void LanesVector_t_pskel::
  post_LanesVector_t ()
  {
  }

  bool LanesVector_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "laneID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->laneID_parser_;

      if (this->laneID_parser_)
        this->laneID_parser_->pre ();

      return true;
    }

    return false;
  }

  bool LanesVector_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "laneID" && ns.empty ())
    {
      if (this->laneID_parser_)
        this->laneID (this->laneID_parser_->post_unsigned_long ());

      return true;
    }

    return false;
  }

  // EntranceAngle_t_pskel
  //

  void EntranceAngle_t_pskel::
  entranceAngle_ID (unsigned short)
  {
  }

  void EntranceAngle_t_pskel::
  entranceAngle_value (unsigned int)
  {
  }

  void EntranceAngle_t_pskel::
  post_EntranceAngle_t ()
  {
  }

  bool EntranceAngle_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "entranceAngle_ID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->entranceAngle_ID_parser_;

      if (this->entranceAngle_ID_parser_)
        this->entranceAngle_ID_parser_->pre ();

      return true;
    }

    if (n == "entranceAngle_value" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->entranceAngle_value_parser_;

      if (this->entranceAngle_value_parser_)
        this->entranceAngle_value_parser_->pre ();

      return true;
    }

    return false;
  }

  bool EntranceAngle_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "entranceAngle_ID" && ns.empty ())
    {
      if (this->entranceAngle_ID_parser_)
        this->entranceAngle_ID (this->entranceAngle_ID_parser_->post_unsigned_short ());

      return true;
    }

    if (n == "entranceAngle_value" && ns.empty ())
    {
      if (this->entranceAngle_value_parser_)
        this->entranceAngle_value (this->entranceAngle_value_parser_->post_unsigned_int ());

      return true;
    }

    return false;
  }

  // EntranceAngles_t_pskel
  //

  void EntranceAngles_t_pskel::
  entranceAngle ()
  {
  }

  void EntranceAngles_t_pskel::
  post_EntranceAngles_t ()
  {
  }

  bool EntranceAngles_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "entranceAngle" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->entranceAngle_parser_;

      if (this->entranceAngle_parser_)
        this->entranceAngle_parser_->pre ();

      return true;
    }

    return false;
  }

  bool EntranceAngles_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "entranceAngle" && ns.empty ())
    {
      if (this->entranceAngle_parser_)
      {
        this->entranceAngle_parser_->post_EntranceAngle_t ();
        this->entranceAngle ();
      }

      return true;
    }

    return false;
  }

  // Node_t_pskel
  //

  void Node_t_pskel::
  nodeID (unsigned int)
  {
  }

  void Node_t_pskel::
  location (sim_mob::Point2D)
  {
  }

  void Node_t_pskel::
  linkLoc (unsigned long long)
  {
  }

  void Node_t_pskel::
  originalDB_ID (const ::std::string&)
  {
  }

  bool Node_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "nodeID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->nodeID_parser_;

      if (this->nodeID_parser_)
        this->nodeID_parser_->pre ();

      return true;
    }

    if (n == "location" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->location_parser_;

      if (this->location_parser_)
        this->location_parser_->pre ();

      return true;
    }

    if (n == "linkLoc" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->linkLoc_parser_;

      if (this->linkLoc_parser_)
        this->linkLoc_parser_->pre ();

      return true;
    }

    if (n == "originalDB_ID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->originalDB_ID_parser_;

      if (this->originalDB_ID_parser_)
        this->originalDB_ID_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Node_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "nodeID" && ns.empty ())
    {
      if (this->nodeID_parser_)
        this->nodeID (this->nodeID_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "location" && ns.empty ())
    {
      if (this->location_parser_)
        this->location (this->location_parser_->post_Point2D_t ());

      return true;
    }

    if (n == "linkLoc" && ns.empty ())
    {
      if (this->linkLoc_parser_)
        this->linkLoc (this->linkLoc_parser_->post_unsigned_long ());

      return true;
    }

    if (n == "originalDB_ID" && ns.empty ())
    {
      if (this->originalDB_ID_parser_)
        this->originalDB_ID (this->originalDB_ID_parser_->post_string ());

      return true;
    }

    return false;
  }

  // temp_Segmetair_t_pskel
  //

  void temp_Segmetair_t_pskel::
  first (unsigned long long)
  {
  }

  void temp_Segmetair_t_pskel::
  second (unsigned long long)
  {
  }

  bool temp_Segmetair_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "first" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->first_parser_;

      if (this->first_parser_)
        this->first_parser_->pre ();

      return true;
    }

    if (n == "second" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->second_parser_;

      if (this->second_parser_)
        this->second_parser_->pre ();

      return true;
    }

    return false;
  }

  bool temp_Segmetair_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "first" && ns.empty ())
    {
      if (this->first_parser_)
        this->first (this->first_parser_->post_unsigned_long ());

      return true;
    }

    if (n == "second" && ns.empty ())
    {
      if (this->second_parser_)
        this->second (this->second_parser_->post_unsigned_long ());

      return true;
    }

    return false;
  }

  // UniNode_t_pskel
  //

  void UniNode_t_pskel::
  firstPair (std::pair<unsigned long,unsigned long>)
  {
  }

  void UniNode_t_pskel::
  secondPair (std::pair<unsigned long,unsigned long>)
  {
  }

  void UniNode_t_pskel::
  Connectors (std::set<std::pair<unsigned long,unsigned long> >)
  {
  }

  bool UniNode_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::geo::Node_t_pskel::_start_element_impl (ns, n, t))
      return true;

    if (n == "firstPair" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->firstPair_parser_;

      if (this->firstPair_parser_)
        this->firstPair_parser_->pre ();

      return true;
    }

    if (n == "secondPair" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->secondPair_parser_;

      if (this->secondPair_parser_)
        this->secondPair_parser_->pre ();

      return true;
    }

    if (n == "Connectors" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Connectors_parser_;

      if (this->Connectors_parser_)
        this->Connectors_parser_->pre ();

      return true;
    }

    return false;
  }

  bool UniNode_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::geo::Node_t_pskel::_end_element_impl (ns, n))
      return true;

    if (n == "firstPair" && ns.empty ())
    {
      if (this->firstPair_parser_)
        this->firstPair (this->firstPair_parser_->post_temp_Segmetair_t ());

      return true;
    }

    if (n == "secondPair" && ns.empty ())
    {
      if (this->secondPair_parser_)
        this->secondPair (this->secondPair_parser_->post_temp_Segmetair_t ());

      return true;
    }

    if (n == "Connectors" && ns.empty ())
    {
      if (this->Connectors_parser_)
        this->Connectors (this->Connectors_parser_->post_connectors_t ());

      return true;
    }

    return false;
  }

  // roundabout_t_pskel
  //

  void roundabout_t_pskel::
  roadSegmentsAt (std::set<unsigned long>)
  {
  }

  void roundabout_t_pskel::
  Connectors (const std::map<unsigned long,std::set<std::pair<unsigned long,unsigned long> > >&)
  {
  }

  void roundabout_t_pskel::
  ChunkLengths ()
  {
  }

  void roundabout_t_pskel::
  Offsets ()
  {
  }

  void roundabout_t_pskel::
  Separators ()
  {
  }

  void roundabout_t_pskel::
  addDominantLane ()
  {
  }

  void roundabout_t_pskel::
  roundaboutDominantIslands (float)
  {
  }

  void roundabout_t_pskel::
  roundaboutNumberOfLanes (int)
  {
  }

  void roundabout_t_pskel::
  entranceAngles ()
  {
  }

  bool roundabout_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::geo::Node_t_pskel::_start_element_impl (ns, n, t))
      return true;

    if (n == "roadSegmentsAt" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->roadSegmentsAt_parser_;

      if (this->roadSegmentsAt_parser_)
        this->roadSegmentsAt_parser_->pre ();

      return true;
    }

    if (n == "Connectors" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Connectors_parser_;

      if (this->Connectors_parser_)
        this->Connectors_parser_->pre ();

      return true;
    }

    if (n == "ChunkLengths" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->ChunkLengths_parser_;

      if (this->ChunkLengths_parser_)
        this->ChunkLengths_parser_->pre ();

      return true;
    }

    if (n == "Offsets" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Offsets_parser_;

      if (this->Offsets_parser_)
        this->Offsets_parser_->pre ();

      return true;
    }

    if (n == "Separators" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Separators_parser_;

      if (this->Separators_parser_)
        this->Separators_parser_->pre ();

      return true;
    }

    if (n == "addDominantLane" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->addDominantLane_parser_;

      if (this->addDominantLane_parser_)
        this->addDominantLane_parser_->pre ();

      return true;
    }

    if (n == "roundaboutDominantIslands" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->roundaboutDominantIslands_parser_;

      if (this->roundaboutDominantIslands_parser_)
        this->roundaboutDominantIslands_parser_->pre ();

      return true;
    }

    if (n == "roundaboutNumberOfLanes" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->roundaboutNumberOfLanes_parser_;

      if (this->roundaboutNumberOfLanes_parser_)
        this->roundaboutNumberOfLanes_parser_->pre ();

      return true;
    }

    if (n == "entranceAngles" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->entranceAngles_parser_;

      if (this->entranceAngles_parser_)
        this->entranceAngles_parser_->pre ();

      return true;
    }

    return false;
  }

  bool roundabout_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::geo::Node_t_pskel::_end_element_impl (ns, n))
      return true;

    if (n == "roadSegmentsAt" && ns.empty ())
    {
      if (this->roadSegmentsAt_parser_)
        this->roadSegmentsAt (this->roadSegmentsAt_parser_->post_RoadSegmentsAt_t ());

      return true;
    }

    if (n == "Connectors" && ns.empty ())
    {
      if (this->Connectors_parser_)
        this->Connectors (this->Connectors_parser_->post_Multi_Connectors_t ());

      return true;
    }

    if (n == "ChunkLengths" && ns.empty ())
    {
      if (this->ChunkLengths_parser_)
      {
        this->ChunkLengths_parser_->post_ChunkLengths_t ();
        this->ChunkLengths ();
      }

      return true;
    }

    if (n == "Offsets" && ns.empty ())
    {
      if (this->Offsets_parser_)
      {
        this->Offsets_parser_->post_offsets_t ();
        this->Offsets ();
      }

      return true;
    }

    if (n == "Separators" && ns.empty ())
    {
      if (this->Separators_parser_)
      {
        this->Separators_parser_->post_separators_t ();
        this->Separators ();
      }

      return true;
    }

    if (n == "addDominantLane" && ns.empty ())
    {
      if (this->addDominantLane_parser_)
      {
        this->addDominantLane_parser_->post_LanesVector_t ();
        this->addDominantLane ();
      }

      return true;
    }

    if (n == "roundaboutDominantIslands" && ns.empty ())
    {
      if (this->roundaboutDominantIslands_parser_)
        this->roundaboutDominantIslands (this->roundaboutDominantIslands_parser_->post_float ());

      return true;
    }

    if (n == "roundaboutNumberOfLanes" && ns.empty ())
    {
      if (this->roundaboutNumberOfLanes_parser_)
        this->roundaboutNumberOfLanes (this->roundaboutNumberOfLanes_parser_->post_int ());

      return true;
    }

    if (n == "entranceAngles" && ns.empty ())
    {
      if (this->entranceAngles_parser_)
      {
        this->entranceAngles_parser_->post_EntranceAngles_t ();
        this->entranceAngles ();
      }

      return true;
    }

    return false;
  }

  // intersection_t_pskel
  //

  void intersection_t_pskel::
  roadSegmentsAt (std::set<unsigned long>)
  {
  }

  void intersection_t_pskel::
  Connectors (const std::map<unsigned long,std::set<std::pair<unsigned long,unsigned long> > >&)
  {
  }

  void intersection_t_pskel::
  ChunkLengths ()
  {
  }

  void intersection_t_pskel::
  Offsets ()
  {
  }

  void intersection_t_pskel::
  Separators ()
  {
  }

  void intersection_t_pskel::
  additionalDominantLanes ()
  {
  }

  void intersection_t_pskel::
  additionalSubdominantLanes ()
  {
  }

  void intersection_t_pskel::
  domainIslands ()
  {
  }

  bool intersection_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::geo::Node_t_pskel::_start_element_impl (ns, n, t))
      return true;

    if (n == "roadSegmentsAt" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->roadSegmentsAt_parser_;

      if (this->roadSegmentsAt_parser_)
        this->roadSegmentsAt_parser_->pre ();

      return true;
    }

    if (n == "Connectors" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Connectors_parser_;

      if (this->Connectors_parser_)
        this->Connectors_parser_->pre ();

      return true;
    }

    if (n == "ChunkLengths" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->ChunkLengths_parser_;

      if (this->ChunkLengths_parser_)
        this->ChunkLengths_parser_->pre ();

      return true;
    }

    if (n == "Offsets" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Offsets_parser_;

      if (this->Offsets_parser_)
        this->Offsets_parser_->pre ();

      return true;
    }

    if (n == "Separators" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Separators_parser_;

      if (this->Separators_parser_)
        this->Separators_parser_->pre ();

      return true;
    }

    if (n == "additionalDominantLanes" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->additionalDominantLanes_parser_;

      if (this->additionalDominantLanes_parser_)
        this->additionalDominantLanes_parser_->pre ();

      return true;
    }

    if (n == "additionalSubdominantLanes" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->additionalSubdominantLanes_parser_;

      if (this->additionalSubdominantLanes_parser_)
        this->additionalSubdominantLanes_parser_->pre ();

      return true;
    }

    if (n == "domainIslands" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->domainIslands_parser_;

      if (this->domainIslands_parser_)
        this->domainIslands_parser_->pre ();

      return true;
    }

    return false;
  }

  bool intersection_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::geo::Node_t_pskel::_end_element_impl (ns, n))
      return true;

    if (n == "roadSegmentsAt" && ns.empty ())
    {
      if (this->roadSegmentsAt_parser_)
        this->roadSegmentsAt (this->roadSegmentsAt_parser_->post_RoadSegmentsAt_t ());

      return true;
    }

    if (n == "Connectors" && ns.empty ())
    {
      if (this->Connectors_parser_)
        this->Connectors (this->Connectors_parser_->post_Multi_Connectors_t ());

      return true;
    }

    if (n == "ChunkLengths" && ns.empty ())
    {
      if (this->ChunkLengths_parser_)
      {
        this->ChunkLengths_parser_->post_ChunkLengths_t ();
        this->ChunkLengths ();
      }

      return true;
    }

    if (n == "Offsets" && ns.empty ())
    {
      if (this->Offsets_parser_)
      {
        this->Offsets_parser_->post_offsets_t ();
        this->Offsets ();
      }

      return true;
    }

    if (n == "Separators" && ns.empty ())
    {
      if (this->Separators_parser_)
      {
        this->Separators_parser_->post_separators_t ();
        this->Separators ();
      }

      return true;
    }

    if (n == "additionalDominantLanes" && ns.empty ())
    {
      if (this->additionalDominantLanes_parser_)
      {
        this->additionalDominantLanes_parser_->post_LanesVector_t ();
        this->additionalDominantLanes ();
      }

      return true;
    }

    if (n == "additionalSubdominantLanes" && ns.empty ())
    {
      if (this->additionalSubdominantLanes_parser_)
      {
        this->additionalSubdominantLanes_parser_->post_LanesVector_t ();
        this->additionalSubdominantLanes ();
      }

      return true;
    }

    if (n == "domainIslands" && ns.empty ())
    {
      if (this->domainIslands_parser_)
      {
        this->domainIslands_parser_->post_DomainIslands_t ();
        this->domainIslands ();
      }

      return true;
    }

    return false;
  }

  // RoadItem_t_pskel
  //

  void RoadItem_t_pskel::
  id (unsigned long long)
  {
  }

  void RoadItem_t_pskel::
  Offset (unsigned short)
  {
  }

  void RoadItem_t_pskel::
  start (sim_mob::Point2D)
  {
  }

  void RoadItem_t_pskel::
  end (sim_mob::Point2D)
  {
  }

  bool RoadItem_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "id" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->id_parser_;

      if (this->id_parser_)
        this->id_parser_->pre ();

      return true;
    }

    if (n == "Offset" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Offset_parser_;

      if (this->Offset_parser_)
        this->Offset_parser_->pre ();

      return true;
    }

    if (n == "start" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->start_parser_;

      if (this->start_parser_)
        this->start_parser_->pre ();

      return true;
    }

    if (n == "end" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->end_parser_;

      if (this->end_parser_)
        this->end_parser_->pre ();

      return true;
    }

    return false;
  }

  bool RoadItem_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
        this->id (this->id_parser_->post_unsigned_long ());

      return true;
    }

    if (n == "Offset" && ns.empty ())
    {
      if (this->Offset_parser_)
        this->Offset (this->Offset_parser_->post_unsigned_short ());

      return true;
    }

    if (n == "start" && ns.empty ())
    {
      if (this->start_parser_)
        this->start (this->start_parser_->post_Point2D_t ());

      return true;
    }

    if (n == "end" && ns.empty ())
    {
      if (this->end_parser_)
        this->end (this->end_parser_->post_Point2D_t ());

      return true;
    }

    return false;
  }

  // BusStop_t_pskel
  //

  void BusStop_t_pskel::
  lane_location (const ::std::string&)
  {
  }

  void BusStop_t_pskel::
  is_Terminal (bool)
  {
  }

  void BusStop_t_pskel::
  is_Bay (bool)
  {
  }

  void BusStop_t_pskel::
  has_shelter (bool)
  {
  }

  void BusStop_t_pskel::
  busCapacityAsLength (unsigned int)
  {
  }

  void BusStop_t_pskel::
  post_BusStop_t ()
  {
  }

  bool BusStop_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::geo::RoadItem_t_pskel::_start_element_impl (ns, n, t))
      return true;

    if (n == "lane_location" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->lane_location_parser_;

      if (this->lane_location_parser_)
        this->lane_location_parser_->pre ();

      return true;
    }

    if (n == "is_Terminal" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->is_Terminal_parser_;

      if (this->is_Terminal_parser_)
        this->is_Terminal_parser_->pre ();

      return true;
    }

    if (n == "is_Bay" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->is_Bay_parser_;

      if (this->is_Bay_parser_)
        this->is_Bay_parser_->pre ();

      return true;
    }

    if (n == "has_shelter" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->has_shelter_parser_;

      if (this->has_shelter_parser_)
        this->has_shelter_parser_->pre ();

      return true;
    }

    if (n == "busCapacityAsLength" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->busCapacityAsLength_parser_;

      if (this->busCapacityAsLength_parser_)
        this->busCapacityAsLength_parser_->pre ();

      return true;
    }

    return false;
  }

  bool BusStop_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::geo::RoadItem_t_pskel::_end_element_impl (ns, n))
      return true;

    if (n == "lane_location" && ns.empty ())
    {
      if (this->lane_location_parser_)
        this->lane_location (this->lane_location_parser_->post_string ());

      return true;
    }

    if (n == "is_Terminal" && ns.empty ())
    {
      if (this->is_Terminal_parser_)
        this->is_Terminal (this->is_Terminal_parser_->post_boolean ());

      return true;
    }

    if (n == "is_Bay" && ns.empty ())
    {
      if (this->is_Bay_parser_)
        this->is_Bay (this->is_Bay_parser_->post_boolean ());

      return true;
    }

    if (n == "has_shelter" && ns.empty ())
    {
      if (this->has_shelter_parser_)
        this->has_shelter (this->has_shelter_parser_->post_boolean ());

      return true;
    }

    if (n == "busCapacityAsLength" && ns.empty ())
    {
      if (this->busCapacityAsLength_parser_)
        this->busCapacityAsLength (this->busCapacityAsLength_parser_->post_unsigned_int ());

      return true;
    }

    return false;
  }

  // ERP_Gantry_t_pskel
  //

  void ERP_Gantry_t_pskel::
  ERP_GantryID (const ::std::string&)
  {
  }

  void ERP_Gantry_t_pskel::
  post_ERP_Gantry_t ()
  {
  }

  bool ERP_Gantry_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::geo::RoadItem_t_pskel::_start_element_impl (ns, n, t))
      return true;

    if (n == "ERP_GantryID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->ERP_GantryID_parser_;

      if (this->ERP_GantryID_parser_)
        this->ERP_GantryID_parser_->pre ();

      return true;
    }

    return false;
  }

  bool ERP_Gantry_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::geo::RoadItem_t_pskel::_end_element_impl (ns, n))
      return true;

    if (n == "ERP_GantryID" && ns.empty ())
    {
      if (this->ERP_GantryID_parser_)
        this->ERP_GantryID (this->ERP_GantryID_parser_->post_string ());

      return true;
    }

    return false;
  }

  // FormType_pskel
  //

  void FormType_pskel::
  TextBox (int)
  {
  }

  void FormType_pskel::
  TextArea (int)
  {
  }

  void FormType_pskel::
  Header (int)
  {
  }

  void FormType_pskel::
  post_FormType ()
  {
  }

  bool FormType_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "TextBox" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->TextBox_parser_;

      if (this->TextBox_parser_)
        this->TextBox_parser_->pre ();

      return true;
    }

    if (n == "TextArea" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->TextArea_parser_;

      if (this->TextArea_parser_)
        this->TextArea_parser_->pre ();

      return true;
    }

    if (n == "Header" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Header_parser_;

      if (this->Header_parser_)
        this->Header_parser_->pre ();

      return true;
    }

    return false;
  }

  bool FormType_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "TextBox" && ns.empty ())
    {
      if (this->TextBox_parser_)
        this->TextBox (this->TextBox_parser_->post_int ());

      return true;
    }

    if (n == "TextArea" && ns.empty ())
    {
      if (this->TextArea_parser_)
        this->TextArea (this->TextArea_parser_->post_int ());

      return true;
    }

    if (n == "Header" && ns.empty ())
    {
      if (this->Header_parser_)
        this->Header (this->Header_parser_->post_int ());

      return true;
    }

    return false;
  }

  // PointPair_t_pskel
  //

  void PointPair_t_pskel::
  first (sim_mob::Point2D)
  {
  }

  void PointPair_t_pskel::
  second (sim_mob::Point2D)
  {
  }

  bool PointPair_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "first" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->first_parser_;

      if (this->first_parser_)
        this->first_parser_->pre ();

      return true;
    }

    if (n == "second" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->second_parser_;

      if (this->second_parser_)
        this->second_parser_->pre ();

      return true;
    }

    return false;
  }

  bool PointPair_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "first" && ns.empty ())
    {
      if (this->first_parser_)
        this->first (this->first_parser_->post_Point2D_t ());

      return true;
    }

    if (n == "second" && ns.empty ())
    {
      if (this->second_parser_)
        this->second (this->second_parser_->post_Point2D_t ());

      return true;
    }

    return false;
  }

  // crossing_t_pskel
  //

  void crossing_t_pskel::
  nearLine (std::pair<sim_mob::Point2D,sim_mob::Point2D>)
  {
  }

  void crossing_t_pskel::
  farLine (std::pair<sim_mob::Point2D,sim_mob::Point2D>)
  {
  }

  bool crossing_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::geo::RoadItem_t_pskel::_start_element_impl (ns, n, t))
      return true;

    if (n == "nearLine" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->nearLine_parser_;

      if (this->nearLine_parser_)
        this->nearLine_parser_->pre ();

      return true;
    }

    if (n == "farLine" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->farLine_parser_;

      if (this->farLine_parser_)
        this->farLine_parser_->pre ();

      return true;
    }

    return false;
  }

  bool crossing_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::geo::RoadItem_t_pskel::_end_element_impl (ns, n))
      return true;

    if (n == "nearLine" && ns.empty ())
    {
      if (this->nearLine_parser_)
        this->nearLine (this->nearLine_parser_->post_PointPair_t ());

      return true;
    }

    if (n == "farLine" && ns.empty ())
    {
      if (this->farLine_parser_)
        this->farLine (this->farLine_parser_->post_PointPair_t ());

      return true;
    }

    return false;
  }

  // RoadBump_t_pskel
  //

  void RoadBump_t_pskel::
  roadBumpID (const ::std::string&)
  {
  }

  void RoadBump_t_pskel::
  segmentID (unsigned long long)
  {
  }

  void RoadBump_t_pskel::
  post_RoadBump_t ()
  {
  }

  bool RoadBump_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::geo::RoadItem_t_pskel::_start_element_impl (ns, n, t))
      return true;

    if (n == "roadBumpID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->roadBumpID_parser_;

      if (this->roadBumpID_parser_)
        this->roadBumpID_parser_->pre ();

      return true;
    }

    if (n == "segmentID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->segmentID_parser_;

      if (this->segmentID_parser_)
        this->segmentID_parser_->pre ();

      return true;
    }

    return false;
  }

  bool RoadBump_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::geo::RoadItem_t_pskel::_end_element_impl (ns, n))
      return true;

    if (n == "roadBumpID" && ns.empty ())
    {
      if (this->roadBumpID_parser_)
        this->roadBumpID (this->roadBumpID_parser_->post_string ());

      return true;
    }

    if (n == "segmentID" && ns.empty ())
    {
      if (this->segmentID_parser_)
        this->segmentID (this->segmentID_parser_->post_unsigned_long ());

      return true;
    }

    return false;
  }

  // RoadNetwork_t_pskel
  //

  void RoadNetwork_t_pskel::
  Nodes ()
  {
  }

  void RoadNetwork_t_pskel::
  Links (std::vector<sim_mob::Link*>)
  {
  }

  void RoadNetwork_t_pskel::
  post_RoadNetwork_t ()
  {
  }

  bool RoadNetwork_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "Nodes" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Nodes_parser_;

      if (this->Nodes_parser_)
        this->Nodes_parser_->pre ();

      return true;
    }

    if (n == "Links" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Links_parser_;

      if (this->Links_parser_)
        this->Links_parser_->pre ();

      return true;
    }

    return false;
  }

  bool RoadNetwork_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "Nodes" && ns.empty ())
    {
      if (this->Nodes_parser_)
      {
        this->Nodes_parser_->post_Nodes ();
        this->Nodes ();
      }

      return true;
    }

    if (n == "Links" && ns.empty ())
    {
      if (this->Links_parser_)
        this->Links (this->Links_parser_->post_Links ());

      return true;
    }

    return false;
  }

  // RoadItems_t_pskel
  //

  void RoadItems_t_pskel::
  BusStop ()
  {
  }

  void RoadItems_t_pskel::
  ERP_Gantry ()
  {
  }

  void RoadItems_t_pskel::
  Crossing (std::pair<unsigned int,sim_mob::Crossing*>)
  {
  }

  void RoadItems_t_pskel::
  RoadBump ()
  {
  }

  bool RoadItems_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "BusStop" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->BusStop_parser_;

      if (this->BusStop_parser_)
        this->BusStop_parser_->pre ();

      return true;
    }

    if (n == "ERP_Gantry" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->ERP_Gantry_parser_;

      if (this->ERP_Gantry_parser_)
        this->ERP_Gantry_parser_->pre ();

      return true;
    }

    if (n == "Crossing" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Crossing_parser_;

      if (this->Crossing_parser_)
        this->Crossing_parser_->pre ();

      return true;
    }

    if (n == "RoadBump" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->RoadBump_parser_;

      if (this->RoadBump_parser_)
        this->RoadBump_parser_->pre ();

      return true;
    }

    return false;
  }

  bool RoadItems_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "BusStop" && ns.empty ())
    {
      if (this->BusStop_parser_)
      {
        this->BusStop_parser_->post_BusStop_t ();
        this->BusStop ();
      }

      return true;
    }

    if (n == "ERP_Gantry" && ns.empty ())
    {
      if (this->ERP_Gantry_parser_)
      {
        this->ERP_Gantry_parser_->post_ERP_Gantry_t ();
        this->ERP_Gantry ();
      }

      return true;
    }

    if (n == "Crossing" && ns.empty ())
    {
      if (this->Crossing_parser_)
        this->Crossing (this->Crossing_parser_->post_crossing_t ());

      return true;
    }

    if (n == "RoadBump" && ns.empty ())
    {
      if (this->RoadBump_parser_)
      {
        this->RoadBump_parser_->post_RoadBump_t ();
        this->RoadBump ();
      }

      return true;
    }

    return false;
  }

  // TripChainItem_t_pskel
  //

  void TripChainItem_t_pskel::
  personID (long long)
  {
  }

  void TripChainItem_t_pskel::
  itemType (std::string)
  {
  }

  void TripChainItem_t_pskel::
  sequenceNumber (unsigned int)
  {
  }

  void TripChainItem_t_pskel::
  startTime (const ::std::string&)
  {
  }

  void TripChainItem_t_pskel::
  endTime (const ::std::string&)
  {
  }

  bool TripChainItem_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "personID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->personID_parser_;

      if (this->personID_parser_)
        this->personID_parser_->pre ();

      return true;
    }

    if (n == "itemType" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->itemType_parser_;

      if (this->itemType_parser_)
        this->itemType_parser_->pre ();

      return true;
    }

    if (n == "sequenceNumber" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->sequenceNumber_parser_;

      if (this->sequenceNumber_parser_)
        this->sequenceNumber_parser_->pre ();

      return true;
    }

    if (n == "startTime" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->startTime_parser_;

      if (this->startTime_parser_)
        this->startTime_parser_->pre ();

      return true;
    }

    if (n == "endTime" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->endTime_parser_;

      if (this->endTime_parser_)
        this->endTime_parser_->pre ();

      return true;
    }

    return false;
  }

  bool TripChainItem_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "personID" && ns.empty ())
    {
      if (this->personID_parser_)
        this->personID (this->personID_parser_->post_integer ());

      return true;
    }

    if (n == "itemType" && ns.empty ())
    {
      if (this->itemType_parser_)
        this->itemType (this->itemType_parser_->post_TripchainItemType ());

      return true;
    }

    if (n == "sequenceNumber" && ns.empty ())
    {
      if (this->sequenceNumber_parser_)
        this->sequenceNumber (this->sequenceNumber_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "startTime" && ns.empty ())
    {
      if (this->startTime_parser_)
        this->startTime (this->startTime_parser_->post_string ());

      return true;
    }

    if (n == "endTime" && ns.empty ())
    {
      if (this->endTime_parser_)
        this->endTime (this->endTime_parser_->post_string ());

      return true;
    }

    return false;
  }

  // Trip_t_pskel
  //

  void Trip_t_pskel::
  tripID (long long)
  {
  }

  void Trip_t_pskel::
  fromLocation (unsigned int)
  {
  }

  void Trip_t_pskel::
  fromLocationType (std::string)
  {
  }

  void Trip_t_pskel::
  toLocation (unsigned int)
  {
  }

  void Trip_t_pskel::
  toLocationType (std::string)
  {
  }

  void Trip_t_pskel::
  subTrips (std::vector<sim_mob::SubTrip>)
  {
  }

  sim_mob::TripChainItem* Trip_t_pskel::
  post_Trip_t ()
  {
    return post_TripChainItem_t ();
  }

  bool Trip_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::geo::TripChainItem_t_pskel::_start_element_impl (ns, n, t))
      return true;

    if (n == "tripID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->tripID_parser_;

      if (this->tripID_parser_)
        this->tripID_parser_->pre ();

      return true;
    }

    if (n == "fromLocation" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->fromLocation_parser_;

      if (this->fromLocation_parser_)
        this->fromLocation_parser_->pre ();

      return true;
    }

    if (n == "fromLocationType" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->fromLocationType_parser_;

      if (this->fromLocationType_parser_)
        this->fromLocationType_parser_->pre ();

      return true;
    }

    if (n == "toLocation" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->toLocation_parser_;

      if (this->toLocation_parser_)
        this->toLocation_parser_->pre ();

      return true;
    }

    if (n == "toLocationType" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->toLocationType_parser_;

      if (this->toLocationType_parser_)
        this->toLocationType_parser_->pre ();

      return true;
    }

    if (n == "subTrips" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->subTrips_parser_;

      if (this->subTrips_parser_)
        this->subTrips_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Trip_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::geo::TripChainItem_t_pskel::_end_element_impl (ns, n))
      return true;

    if (n == "tripID" && ns.empty ())
    {
      if (this->tripID_parser_)
        this->tripID (this->tripID_parser_->post_integer ());

      return true;
    }

    if (n == "fromLocation" && ns.empty ())
    {
      if (this->fromLocation_parser_)
        this->fromLocation (this->fromLocation_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "fromLocationType" && ns.empty ())
    {
      if (this->fromLocationType_parser_)
        this->fromLocationType (this->fromLocationType_parser_->post_TripchainItemLocationType ());

      return true;
    }

    if (n == "toLocation" && ns.empty ())
    {
      if (this->toLocation_parser_)
        this->toLocation (this->toLocation_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "toLocationType" && ns.empty ())
    {
      if (this->toLocationType_parser_)
        this->toLocationType (this->toLocationType_parser_->post_TripchainItemLocationType ());

      return true;
    }

    if (n == "subTrips" && ns.empty ())
    {
      if (this->subTrips_parser_)
        this->subTrips (this->subTrips_parser_->post_SubTrips_t ());

      return true;
    }

    return false;
  }

  // SubTrip_t_pskel
  //

  void SubTrip_t_pskel::
  mode (const ::std::string&)
  {
  }

  void SubTrip_t_pskel::
  isPrimaryMode (bool)
  {
  }

  void SubTrip_t_pskel::
  ptLineId (const ::std::string&)
  {
  }

  bool SubTrip_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::geo::Trip_t_pskel::_start_element_impl (ns, n, t))
      return true;

    if (n == "mode" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->mode_parser_;

      if (this->mode_parser_)
        this->mode_parser_->pre ();

      return true;
    }

    if (n == "isPrimaryMode" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->isPrimaryMode_parser_;

      if (this->isPrimaryMode_parser_)
        this->isPrimaryMode_parser_->pre ();

      return true;
    }

    if (n == "ptLineId" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->ptLineId_parser_;

      if (this->ptLineId_parser_)
        this->ptLineId_parser_->pre ();

      return true;
    }

    return false;
  }

  bool SubTrip_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::geo::Trip_t_pskel::_end_element_impl (ns, n))
      return true;

    if (n == "mode" && ns.empty ())
    {
      if (this->mode_parser_)
        this->mode (this->mode_parser_->post_string ());

      return true;
    }

    if (n == "isPrimaryMode" && ns.empty ())
    {
      if (this->isPrimaryMode_parser_)
        this->isPrimaryMode (this->isPrimaryMode_parser_->post_boolean ());

      return true;
    }

    if (n == "ptLineId" && ns.empty ())
    {
      if (this->ptLineId_parser_)
        this->ptLineId (this->ptLineId_parser_->post_string ());

      return true;
    }

    return false;
  }

  // SubTrips_t_pskel
  //

  void SubTrips_t_pskel::
  subTrip (sim_mob::SubTrip)
  {
  }

  bool SubTrips_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "subTrip" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->subTrip_parser_;

      if (this->subTrip_parser_)
        this->subTrip_parser_->pre ();

      return true;
    }

    return false;
  }

  bool SubTrips_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "subTrip" && ns.empty ())
    {
      if (this->subTrip_parser_)
        this->subTrip (this->subTrip_parser_->post_SubTrip_t ());

      return true;
    }

    return false;
  }

  // Activity_t_pskel
  //

  void Activity_t_pskel::
  description (const ::std::string&)
  {
  }

  void Activity_t_pskel::
  location (unsigned int)
  {
  }

  void Activity_t_pskel::
  locationType (std::string)
  {
  }

  void Activity_t_pskel::
  isPrimary (bool)
  {
  }

  void Activity_t_pskel::
  isFlexible (bool)
  {
  }

  void Activity_t_pskel::
  isMandatory (bool)
  {
  }

  sim_mob::TripChainItem* Activity_t_pskel::
  post_Activity_t ()
  {
    return post_TripChainItem_t ();
  }

  bool Activity_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::geo::TripChainItem_t_pskel::_start_element_impl (ns, n, t))
      return true;

    if (n == "description" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->description_parser_;

      if (this->description_parser_)
        this->description_parser_->pre ();

      return true;
    }

    if (n == "location" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->location_parser_;

      if (this->location_parser_)
        this->location_parser_->pre ();

      return true;
    }

    if (n == "locationType" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->locationType_parser_;

      if (this->locationType_parser_)
        this->locationType_parser_->pre ();

      return true;
    }

    if (n == "isPrimary" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->isPrimary_parser_;

      if (this->isPrimary_parser_)
        this->isPrimary_parser_->pre ();

      return true;
    }

    if (n == "isFlexible" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->isFlexible_parser_;

      if (this->isFlexible_parser_)
        this->isFlexible_parser_->pre ();

      return true;
    }

    if (n == "isMandatory" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->isMandatory_parser_;

      if (this->isMandatory_parser_)
        this->isMandatory_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Activity_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::geo::TripChainItem_t_pskel::_end_element_impl (ns, n))
      return true;

    if (n == "description" && ns.empty ())
    {
      if (this->description_parser_)
        this->description (this->description_parser_->post_string ());

      return true;
    }

    if (n == "location" && ns.empty ())
    {
      if (this->location_parser_)
        this->location (this->location_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "locationType" && ns.empty ())
    {
      if (this->locationType_parser_)
        this->locationType (this->locationType_parser_->post_TripchainItemLocationType ());

      return true;
    }

    if (n == "isPrimary" && ns.empty ())
    {
      if (this->isPrimary_parser_)
        this->isPrimary (this->isPrimary_parser_->post_boolean ());

      return true;
    }

    if (n == "isFlexible" && ns.empty ())
    {
      if (this->isFlexible_parser_)
        this->isFlexible (this->isFlexible_parser_->post_boolean ());

      return true;
    }

    if (n == "isMandatory" && ns.empty ())
    {
      if (this->isMandatory_parser_)
        this->isMandatory (this->isMandatory_parser_->post_boolean ());

      return true;
    }

    return false;
  }

  // TripChain_t_pskel
  //

  void TripChain_t_pskel::
  personID (long long)
  {
  }

  void TripChain_t_pskel::
  Trip (sim_mob::TripChainItem*)
  {
  }

  void TripChain_t_pskel::
  Activity (sim_mob::TripChainItem*)
  {
  }

  bool TripChain_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "personID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->personID_parser_;

      if (this->personID_parser_)
        this->personID_parser_->pre ();

      return true;
    }

    if (n == "Trip" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Trip_parser_;

      if (this->Trip_parser_)
        this->Trip_parser_->pre ();

      return true;
    }

    if (n == "Activity" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Activity_parser_;

      if (this->Activity_parser_)
        this->Activity_parser_->pre ();

      return true;
    }

    return false;
  }

  bool TripChain_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "personID" && ns.empty ())
    {
      if (this->personID_parser_)
        this->personID (this->personID_parser_->post_integer ());

      return true;
    }

    if (n == "Trip" && ns.empty ())
    {
      if (this->Trip_parser_)
        this->Trip (this->Trip_parser_->post_Trip_t ());

      return true;
    }

    if (n == "Activity" && ns.empty ())
    {
      if (this->Activity_parser_)
        this->Activity (this->Activity_parser_->post_Activity_t ());

      return true;
    }

    return false;
  }

  // TripChains_t_pskel
  //

  void TripChains_t_pskel::
  TripChain (std::pair<unsigned long, std::vector<sim_mob::TripChainItem*> >)
  {
  }

  void TripChains_t_pskel::
  post_TripChains_t ()
  {
  }

  bool TripChains_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "TripChain" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->TripChain_parser_;

      if (this->TripChain_parser_)
        this->TripChain_parser_->pre ();

      return true;
    }

    return false;
  }

  bool TripChains_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "TripChain" && ns.empty ())
    {
      if (this->TripChain_parser_)
        this->TripChain (this->TripChain_parser_->post_TripChain_t ());

      return true;
    }

    return false;
  }

  // linkAndCrossing_t_pskel
  //

  void linkAndCrossing_t_pskel::
  ID (unsigned char)
  {
  }

  void linkAndCrossing_t_pskel::
  linkID (unsigned int)
  {
  }

  void linkAndCrossing_t_pskel::
  crossingID (unsigned int)
  {
  }

  void linkAndCrossing_t_pskel::
  angle (unsigned char)
  {
  }

  bool linkAndCrossing_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "ID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->ID_parser_;

      if (this->ID_parser_)
        this->ID_parser_->pre ();

      return true;
    }

    if (n == "linkID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->linkID_parser_;

      if (this->linkID_parser_)
        this->linkID_parser_->pre ();

      return true;
    }

    if (n == "crossingID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->crossingID_parser_;

      if (this->crossingID_parser_)
        this->crossingID_parser_->pre ();

      return true;
    }

    if (n == "angle" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->angle_parser_;

      if (this->angle_parser_)
        this->angle_parser_->pre ();

      return true;
    }

    return false;
  }

  bool linkAndCrossing_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "ID" && ns.empty ())
    {
      if (this->ID_parser_)
        this->ID (this->ID_parser_->post_unsigned_byte ());

      return true;
    }

    if (n == "linkID" && ns.empty ())
    {
      if (this->linkID_parser_)
        this->linkID (this->linkID_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "crossingID" && ns.empty ())
    {
      if (this->crossingID_parser_)
        this->crossingID (this->crossingID_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "angle" && ns.empty ())
    {
      if (this->angle_parser_)
        this->angle (this->angle_parser_->post_unsigned_byte ());

      return true;
    }

    return false;
  }

  // linkAndCrossings_t_pskel
  //

  void linkAndCrossings_t_pskel::
  linkAndCrossing (sim_mob::LinkAndCrossing)
  {
  }

  bool linkAndCrossings_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "linkAndCrossing" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->linkAndCrossing_parser_;

      if (this->linkAndCrossing_parser_)
        this->linkAndCrossing_parser_->pre ();

      return true;
    }

    return false;
  }

  bool linkAndCrossings_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "linkAndCrossing" && ns.empty ())
    {
      if (this->linkAndCrossing_parser_)
        this->linkAndCrossing (this->linkAndCrossing_parser_->post_linkAndCrossing_t ());

      return true;
    }

    return false;
  }

  // signalAlgorithm_t_pskel
  //

  void signalAlgorithm_t_pskel::
  post_signalAlgorithm_t ()
  {
  }

  // Plan_t_pskel
  //

  void Plan_t_pskel::
  planID (unsigned char)
  {
  }

  void Plan_t_pskel::
  PhasePercentage (double)
  {
  }

  void Plan_t_pskel::
  post_Plan_t ()
  {
  }

  bool Plan_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "planID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->planID_parser_;

      if (this->planID_parser_)
        this->planID_parser_->pre ();

      return true;
    }

    if (n == "PhasePercentage" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->PhasePercentage_parser_;

      if (this->PhasePercentage_parser_)
        this->PhasePercentage_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Plan_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "planID" && ns.empty ())
    {
      if (this->planID_parser_)
        this->planID (this->planID_parser_->post_unsigned_byte ());

      return true;
    }

    if (n == "PhasePercentage" && ns.empty ())
    {
      if (this->PhasePercentage_parser_)
        this->PhasePercentage (this->PhasePercentage_parser_->post_double ());

      return true;
    }

    return false;
  }

  // Plans_t_pskel
  //

  void Plans_t_pskel::
  Plan ()
  {
  }

  void Plans_t_pskel::
  post_Plans_t ()
  {
  }

  bool Plans_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "Plan" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Plan_parser_;

      if (this->Plan_parser_)
        this->Plan_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Plans_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "Plan" && ns.empty ())
    {
      if (this->Plan_parser_)
      {
        this->Plan_parser_->post_Plan_t ();
        this->Plan ();
      }

      return true;
    }

    return false;
  }

  // TrafficColor_t_pskel
  //

  void TrafficColor_t_pskel::
  post_TrafficColor_t ()
  {
  }

  // ColorDuration_t_pskel
  //

  void ColorDuration_t_pskel::
  TrafficColor ()
  {
  }

  void ColorDuration_t_pskel::
  Duration (unsigned char)
  {
  }

  bool ColorDuration_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "TrafficColor" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->TrafficColor_parser_;

      if (this->TrafficColor_parser_)
        this->TrafficColor_parser_->pre ();

      return true;
    }

    if (n == "Duration" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Duration_parser_;

      if (this->Duration_parser_)
        this->Duration_parser_->pre ();

      return true;
    }

    return false;
  }

  bool ColorDuration_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "TrafficColor" && ns.empty ())
    {
      if (this->TrafficColor_parser_)
      {
        this->TrafficColor_parser_->post_TrafficColor_t ();
        this->TrafficColor ();
      }

      return true;
    }

    if (n == "Duration" && ns.empty ())
    {
      if (this->Duration_parser_)
        this->Duration (this->Duration_parser_->post_unsigned_byte ());

      return true;
    }

    return false;
  }

  // ColorSequence_t_pskel
  //

  void ColorSequence_t_pskel::
  TrafficLightType (const ::std::string&)
  {
  }

  void ColorSequence_t_pskel::
  ColorDuration (std::pair<sim_mob::TrafficColor,std::size_t>)
  {
  }

  bool ColorSequence_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "TrafficLightType" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->TrafficLightType_parser_;

      if (this->TrafficLightType_parser_)
        this->TrafficLightType_parser_->pre ();

      return true;
    }

    if (n == "ColorDuration" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->ColorDuration_parser_;

      if (this->ColorDuration_parser_)
        this->ColorDuration_parser_->pre ();

      return true;
    }

    return false;
  }

  bool ColorSequence_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "TrafficLightType" && ns.empty ())
    {
      if (this->TrafficLightType_parser_)
        this->TrafficLightType (this->TrafficLightType_parser_->post_string ());

      return true;
    }

    if (n == "ColorDuration" && ns.empty ())
    {
      if (this->ColorDuration_parser_)
        this->ColorDuration (this->ColorDuration_parser_->post_ColorDuration_t ());

      return true;
    }

    return false;
  }

  // links_maps_t_pskel
  //

  void links_maps_t_pskel::
  links_map (std::pair<sim_mob::Link*,sim_mob::linkToLink>)
  {
  }

  bool links_maps_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "links_map" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->links_map_parser_;

      if (this->links_map_parser_)
        this->links_map_parser_->pre ();

      return true;
    }

    return false;
  }

  bool links_maps_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "links_map" && ns.empty ())
    {
      if (this->links_map_parser_)
        this->links_map (this->links_map_parser_->post_links_map_t ());

      return true;
    }

    return false;
  }

  // links_map_t_pskel
  //

  void links_map_t_pskel::
  linkFrom (unsigned int)
  {
  }

  void links_map_t_pskel::
  linkTo (unsigned int)
  {
  }

  void links_map_t_pskel::
  SegmentFrom (unsigned int)
  {
  }

  void links_map_t_pskel::
  SegmentTo (unsigned int)
  {
  }

  void links_map_t_pskel::
  ColorSequence (std::pair<std::string,std::vector<std::pair<TrafficColor,std::size_t> > >)
  {
  }

  bool links_map_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "linkFrom" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->linkFrom_parser_;

      if (this->linkFrom_parser_)
        this->linkFrom_parser_->pre ();

      return true;
    }

    if (n == "linkTo" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->linkTo_parser_;

      if (this->linkTo_parser_)
        this->linkTo_parser_->pre ();

      return true;
    }

    if (n == "SegmentFrom" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->SegmentFrom_parser_;

      if (this->SegmentFrom_parser_)
        this->SegmentFrom_parser_->pre ();

      return true;
    }

    if (n == "SegmentTo" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->SegmentTo_parser_;

      if (this->SegmentTo_parser_)
        this->SegmentTo_parser_->pre ();

      return true;
    }

    if (n == "ColorSequence" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->ColorSequence_parser_;

      if (this->ColorSequence_parser_)
        this->ColorSequence_parser_->pre ();

      return true;
    }

    return false;
  }

  bool links_map_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "linkFrom" && ns.empty ())
    {
      if (this->linkFrom_parser_)
        this->linkFrom (this->linkFrom_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "linkTo" && ns.empty ())
    {
      if (this->linkTo_parser_)
        this->linkTo (this->linkTo_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "SegmentFrom" && ns.empty ())
    {
      if (this->SegmentFrom_parser_)
        this->SegmentFrom (this->SegmentFrom_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "SegmentTo" && ns.empty ())
    {
      if (this->SegmentTo_parser_)
        this->SegmentTo (this->SegmentTo_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "ColorSequence" && ns.empty ())
    {
      if (this->ColorSequence_parser_)
        this->ColorSequence (this->ColorSequence_parser_->post_ColorSequence_t ());

      return true;
    }

    return false;
  }

  // Phase_t_pskel
  //

  void Phase_t_pskel::
  phaseID (unsigned char)
  {
  }

  void Phase_t_pskel::
  name (const ::std::string&)
  {
  }

  void Phase_t_pskel::
  links_map (std::multimap<sim_mob::Link*,sim_mob::linkToLink>)
  {
  }

  void Phase_t_pskel::
  post_Phase_t ()
  {
  }

  bool Phase_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "phaseID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->phaseID_parser_;

      if (this->phaseID_parser_)
        this->phaseID_parser_->pre ();

      return true;
    }

    if (n == "name" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->name_parser_;

      if (this->name_parser_)
        this->name_parser_->pre ();

      return true;
    }

    if (n == "links_map" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->links_map_parser_;

      if (this->links_map_parser_)
        this->links_map_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Phase_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "phaseID" && ns.empty ())
    {
      if (this->phaseID_parser_)
        this->phaseID (this->phaseID_parser_->post_unsigned_byte ());

      return true;
    }

    if (n == "name" && ns.empty ())
    {
      if (this->name_parser_)
        this->name (this->name_parser_->post_string ());

      return true;
    }

    if (n == "links_map" && ns.empty ())
    {
      if (this->links_map_parser_)
        this->links_map (this->links_map_parser_->post_links_maps_t ());

      return true;
    }

    return false;
  }

  // Phases_t_pskel
  //

  void Phases_t_pskel::
  Phase ()
  {
  }

  void Phases_t_pskel::
  post_Phases_t ()
  {
  }

  bool Phases_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "Phase" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Phase_parser_;

      if (this->Phase_parser_)
        this->Phase_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Phases_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "Phase" && ns.empty ())
    {
      if (this->Phase_parser_)
      {
        this->Phase_parser_->post_Phase_t ();
        this->Phase ();
      }

      return true;
    }

    return false;
  }

  // SplitPlan_t_pskel
  //

  void SplitPlan_t_pskel::
  splitplanID (unsigned int)
  {
  }

  void SplitPlan_t_pskel::
  signalAlgorithm ()
  {
  }

  void SplitPlan_t_pskel::
  cycleLength (unsigned char)
  {
  }

  void SplitPlan_t_pskel::
  offset (unsigned char)
  {
  }

  void SplitPlan_t_pskel::
  ChoiceSet ()
  {
  }

  void SplitPlan_t_pskel::
  Phases ()
  {
  }

  bool SplitPlan_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "splitplanID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->splitplanID_parser_;

      if (this->splitplanID_parser_)
        this->splitplanID_parser_->pre ();

      return true;
    }

    if (n == "signalAlgorithm" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->signalAlgorithm_parser_;

      if (this->signalAlgorithm_parser_)
        this->signalAlgorithm_parser_->pre ();

      return true;
    }

    if (n == "cycleLength" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->cycleLength_parser_;

      if (this->cycleLength_parser_)
        this->cycleLength_parser_->pre ();

      return true;
    }

    if (n == "offset" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->offset_parser_;

      if (this->offset_parser_)
        this->offset_parser_->pre ();

      return true;
    }

    if (n == "ChoiceSet" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->ChoiceSet_parser_;

      if (this->ChoiceSet_parser_)
        this->ChoiceSet_parser_->pre ();

      return true;
    }

    if (n == "Phases" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Phases_parser_;

      if (this->Phases_parser_)
        this->Phases_parser_->pre ();

      return true;
    }

    return false;
  }

  bool SplitPlan_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "splitplanID" && ns.empty ())
    {
      if (this->splitplanID_parser_)
        this->splitplanID (this->splitplanID_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "signalAlgorithm" && ns.empty ())
    {
      if (this->signalAlgorithm_parser_)
      {
        this->signalAlgorithm_parser_->post_signalAlgorithm_t ();
        this->signalAlgorithm ();
      }

      return true;
    }

    if (n == "cycleLength" && ns.empty ())
    {
      if (this->cycleLength_parser_)
        this->cycleLength (this->cycleLength_parser_->post_unsigned_byte ());

      return true;
    }

    if (n == "offset" && ns.empty ())
    {
      if (this->offset_parser_)
        this->offset (this->offset_parser_->post_unsigned_byte ());

      return true;
    }

    if (n == "ChoiceSet" && ns.empty ())
    {
      if (this->ChoiceSet_parser_)
      {
        this->ChoiceSet_parser_->post_Plans_t ();
        this->ChoiceSet ();
      }

      return true;
    }

    if (n == "Phases" && ns.empty ())
    {
      if (this->Phases_parser_)
      {
        this->Phases_parser_->post_Phases_t ();
        this->Phases ();
      }

      return true;
    }

    return false;
  }

  // Signal_t_pskel
  //

  void Signal_t_pskel::
  signalID (unsigned char)
  {
  }

  void Signal_t_pskel::
  nodeID (unsigned int)
  {
  }

  void Signal_t_pskel::
  signalAlgorithm ()
  {
  }

  void Signal_t_pskel::
  linkAndCrossings (sim_mob::LinkAndCrossingC)
  {
  }

  void Signal_t_pskel::
  SplitPlan (sim_mob::SplitPlan)
  {
  }

  bool Signal_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "signalID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->signalID_parser_;

      if (this->signalID_parser_)
        this->signalID_parser_->pre ();

      return true;
    }

    if (n == "nodeID" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->nodeID_parser_;

      if (this->nodeID_parser_)
        this->nodeID_parser_->pre ();

      return true;
    }

    if (n == "signalAlgorithm" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->signalAlgorithm_parser_;

      if (this->signalAlgorithm_parser_)
        this->signalAlgorithm_parser_->pre ();

      return true;
    }

    if (n == "linkAndCrossings" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->linkAndCrossings_parser_;

      if (this->linkAndCrossings_parser_)
        this->linkAndCrossings_parser_->pre ();

      return true;
    }

    if (n == "SplitPlan" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->SplitPlan_parser_;

      if (this->SplitPlan_parser_)
        this->SplitPlan_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Signal_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "signalID" && ns.empty ())
    {
      if (this->signalID_parser_)
        this->signalID (this->signalID_parser_->post_unsigned_byte ());

      return true;
    }

    if (n == "nodeID" && ns.empty ())
    {
      if (this->nodeID_parser_)
        this->nodeID (this->nodeID_parser_->post_unsigned_int ());

      return true;
    }

    if (n == "signalAlgorithm" && ns.empty ())
    {
      if (this->signalAlgorithm_parser_)
      {
        this->signalAlgorithm_parser_->post_signalAlgorithm_t ();
        this->signalAlgorithm ();
      }

      return true;
    }

    if (n == "linkAndCrossings" && ns.empty ())
    {
      if (this->linkAndCrossings_parser_)
        this->linkAndCrossings (this->linkAndCrossings_parser_->post_linkAndCrossings_t ());

      return true;
    }

    if (n == "SplitPlan" && ns.empty ())
    {
      if (this->SplitPlan_parser_)
        this->SplitPlan (this->SplitPlan_parser_->post_SplitPlan_t ());

      return true;
    }

    return false;
  }

  // Signals_t_pskel
  //

  void Signals_t_pskel::
  signal (sim_mob::Signal*)
  {
  }

  void Signals_t_pskel::
  post_Signals_t ()
  {
  }

  bool Signals_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "signal" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->signal_parser_;

      if (this->signal_parser_)
        this->signal_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Signals_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "signal" && ns.empty ())
    {
      if (this->signal_parser_)
        this->signal (this->signal_parser_->post_Signal_t ());

      return true;
    }

    return false;
  }

  // GeoSpatial_t_pskel
  //

  void GeoSpatial_t_pskel::
  RoadNetwork ()
  {
  }

  void GeoSpatial_t_pskel::
  post_GeoSpatial_t ()
  {
  }

  bool GeoSpatial_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "RoadNetwork" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->RoadNetwork_parser_;

      if (this->RoadNetwork_parser_)
        this->RoadNetwork_parser_->pre ();

      return true;
    }

    return false;
  }

  bool GeoSpatial_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "RoadNetwork" && ns.empty ())
    {
      if (this->RoadNetwork_parser_)
      {
        this->RoadNetwork_parser_->post_RoadNetwork_t ();
        this->RoadNetwork ();
      }

      return true;
    }

    return false;
  }

  // SimMobility_t_pskel
  //

  void SimMobility_t_pskel::
  GeoSpatial ()
  {
  }

  void SimMobility_t_pskel::
  TripChains ()
  {
  }

  void SimMobility_t_pskel::
  Signals ()
  {
  }

  void SimMobility_t_pskel::
  post_SimMobility_t ()
  {
  }

  bool SimMobility_t_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "GeoSpatial" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->GeoSpatial_parser_;

      if (this->GeoSpatial_parser_)
        this->GeoSpatial_parser_->pre ();

      return true;
    }

    if (n == "TripChains" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->TripChains_parser_;

      if (this->TripChains_parser_)
        this->TripChains_parser_->pre ();

      return true;
    }

    if (n == "Signals" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Signals_parser_;

      if (this->Signals_parser_)
        this->Signals_parser_->pre ();

      return true;
    }

    return false;
  }

  bool SimMobility_t_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "GeoSpatial" && ns.empty ())
    {
      if (this->GeoSpatial_parser_)
      {
        this->GeoSpatial_parser_->post_GeoSpatial_t ();
        this->GeoSpatial ();
      }

      return true;
    }

    if (n == "TripChains" && ns.empty ())
    {
      if (this->TripChains_parser_)
      {
        this->TripChains_parser_->post_TripChains_t ();
        this->TripChains ();
      }

      return true;
    }

    if (n == "Signals" && ns.empty ())
    {
      if (this->Signals_parser_)
      {
        this->Signals_parser_->post_Signals_t ();
        this->Signals ();
      }

      return true;
    }

    return false;
  }

  // Lanes_pskel
  //

  void Lanes_pskel::
  Lane (sim_mob::Lane*)
  {
  }

  bool Lanes_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "Lane" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Lane_parser_;

      if (this->Lane_parser_)
        this->Lane_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Lanes_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "Lane" && ns.empty ())
    {
      if (this->Lane_parser_)
        this->Lane (this->Lane_parser_->post_lane_t ());

      return true;
    }

    return false;
  }

  // Segments_pskel
  //

  void Segments_pskel::
  FWDSegments (std::vector<sim_mob::RoadSegment*>)
  {
  }

  void Segments_pskel::
  BKDSegments (std::vector<sim_mob::RoadSegment*>)
  {
  }

  bool Segments_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "FWDSegments" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->FWDSegments_parser_;

      if (this->FWDSegments_parser_)
        this->FWDSegments_parser_->pre ();

      return true;
    }

    if (n == "BKDSegments" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->BKDSegments_parser_;

      if (this->BKDSegments_parser_)
        this->BKDSegments_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Segments_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "FWDSegments" && ns.empty ())
    {
      if (this->FWDSegments_parser_)
        this->FWDSegments (this->FWDSegments_parser_->post_fwdBckSegments_t ());

      return true;
    }

    if (n == "BKDSegments" && ns.empty ())
    {
      if (this->BKDSegments_parser_)
        this->BKDSegments (this->BKDSegments_parser_->post_fwdBckSegments_t ());

      return true;
    }

    return false;
  }

  // Nodes_pskel
  //

  void Nodes_pskel::
  UniNodes (std::set<sim_mob::UniNode*>&)
  {
  }

  void Nodes_pskel::
  Intersections (std::vector<sim_mob::MultiNode*>&)
  {
  }

  void Nodes_pskel::
  roundabouts (std::vector<sim_mob::MultiNode*>&)
  {
  }

  void Nodes_pskel::
  post_Nodes ()
  {
  }

  bool Nodes_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "UniNodes" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->UniNodes_parser_;

      if (this->UniNodes_parser_)
        this->UniNodes_parser_->pre ();

      return true;
    }

    if (n == "Intersections" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Intersections_parser_;

      if (this->Intersections_parser_)
        this->Intersections_parser_->pre ();

      return true;
    }

    if (n == "roundabouts" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->roundabouts_parser_;

      if (this->roundabouts_parser_)
        this->roundabouts_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Nodes_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "UniNodes" && ns.empty ())
    {
      if (this->UniNodes_parser_)
        this->UniNodes (this->UniNodes_parser_->post_UniNodes ());

      return true;
    }

    if (n == "Intersections" && ns.empty ())
    {
      if (this->Intersections_parser_)
        this->Intersections (this->Intersections_parser_->post_Intersections ());

      return true;
    }

    if (n == "roundabouts" && ns.empty ())
    {
      if (this->roundabouts_parser_)
        this->roundabouts (this->roundabouts_parser_->post_roundabouts ());

      return true;
    }

    return false;
  }

  // Links_pskel
  //

  void Links_pskel::
  Link (sim_mob::Link*)
  {
  }

  bool Links_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "Link" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Link_parser_;

      if (this->Link_parser_)
        this->Link_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Links_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "Link" && ns.empty ())
    {
      if (this->Link_parser_)
        this->Link (this->Link_parser_->post_link_t ());

      return true;
    }

    return false;
  }

  // UniNodes_pskel
  //

  void UniNodes_pskel::
  UniNode (sim_mob::UniNode*)
  {
  }

  bool UniNodes_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "UniNode" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->UniNode_parser_;

      if (this->UniNode_parser_)
        this->UniNode_parser_->pre ();

      return true;
    }

    return false;
  }

  bool UniNodes_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "UniNode" && ns.empty ())
    {
      if (this->UniNode_parser_)
        this->UniNode (this->UniNode_parser_->post_UniNode_t ());

      return true;
    }

    return false;
  }

  // Intersections_pskel
  //

  void Intersections_pskel::
  Intersection (sim_mob::MultiNode*)
  {
  }

  bool Intersections_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "Intersection" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->Intersection_parser_;

      if (this->Intersection_parser_)
        this->Intersection_parser_->pre ();

      return true;
    }

    return false;
  }

  bool Intersections_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "Intersection" && ns.empty ())
    {
      if (this->Intersection_parser_)
        this->Intersection (this->Intersection_parser_->post_intersection_t ());

      return true;
    }

    return false;
  }

  // roundabouts_pskel
  //

  void roundabouts_pskel::
  roundabout (sim_mob::MultiNode*)
  {
  }

  bool roundabouts_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
      return true;

    if (n == "roundabout" && ns.empty ())
    {
      this->::xml_schema::complex_content::context_.top ().parser_ = this->roundabout_parser_;

      if (this->roundabout_parser_)
        this->roundabout_parser_->pre ();

      return true;
    }

    return false;
  }

  bool roundabouts_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    if (this->::xml_schema::complex_content::_end_element_impl (ns, n))
      return true;

    if (n == "roundabout" && ns.empty ())
    {
      if (this->roundabout_parser_)
        this->roundabout (this->roundabout_parser_->post_roundabout_t ());

      return true;
    }

    return false;
  }
}

// Begin epilogue.
//
//
// End epilogue.

