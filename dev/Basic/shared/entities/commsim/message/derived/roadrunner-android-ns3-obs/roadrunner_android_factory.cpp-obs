/*
 * RRMSGFactory.cpp
 *
 *  Created on: May 13, 2013
 *      Author: vahid
 */

#include "roadrunner_android_factory.hpp"
#include <boost/assign/list_of.hpp> // for 'map_list_of()'
#include <json/json.h>
#include <stdexcept>
#include "logging/Log.hpp"

namespace sim_mob {
namespace rr_android_ns3 {
/***************************************************************************************************************************************************
 *****************************   ANDROID   ************************************************************************************************************
 **************************************************************************************************************************************************/
RR_Android_Factory::RR_Android_Factory() {
	// TODO Auto-generated constructor stub
	MessageMap = boost::assign::map_list_of("MULTICAST", MULTICAST)("UNICAST", UNICAST)("CLIENT_MESSAGES_DONE",CLIENT_MESSAGES_DONE);

}
RR_Android_Factory::~RR_Android_Factory() {}
void RR_Android_Factory::push_back(std::vector<msg_ptr>& output, msg_ptr&msg){
	boost::unique_lock<boost::mutex> lock(mutex_);
	output.push_back(msg);
}
//gets a handler either from a chche or by creating a new one
hdlr_ptr  RR_Android_Factory::getHandler(MessageType type){
	hdlr_ptr handler;
	//if handler is already registered && the registered handler is not null
	std::map<MessageType, hdlr_ptr >::iterator it = HandlerMap.find(type);
	if((it != HandlerMap.end())&&((*it).second!= 0))
	{
		//get the handler ...
		handler = (*it).second;
	}
	else
	{
		//else, create a cache entry ...
		bool typeFound = true;
		switch(type)
		{
		case MULTICAST:
			handler.reset(new sim_mob::rr_android_ns3::ANDROID_HDL_MULTICAST());
			break;
		case UNICAST:
			handler.reset(new sim_mob::rr_android_ns3::ANDROID_HDL_UNICAST());
			break;
		default:
			typeFound = false;
		}
		//register this baby
		if(typeFound)
		{
			HandlerMap[type] = handler;
		}
	}

	return handler;
}
void RR_Android_Factory::cookMessage(Json::Value & jMsg, std::vector<msg_ptr>& output){
	msg_header messageHeader;
	if (!sim_mob::JsonParser::parseMessageHeader(jMsg, messageHeader)) {
		return;
	}
	msg_data_t & curr_json = jMsg;
	switch (MessageMap[messageHeader.msg_type]) {
	case MULTICAST:{
		//create a message
		msg_ptr msg(new sim_mob::rr_android_ns3::ANDROID_MSG_MULTICAST(curr_json));
		//... and then assign the handler pointer to message's member
		msg->setHandler(getHandler(MULTICAST));
		push_back(output,msg);
		break;
	}
	case UNICAST:{
		//create a message
		msg_ptr msg(new sim_mob::rr_android_ns3::ANDROID_MSG_UNICAST(curr_json));
		//... and then assign the handler pointer to message's member
		msg->setHandler(getHandler(UNICAST));
		push_back(output,msg);
		break;
	}
	case CLIENT_MESSAGES_DONE:{
		//create a message
		msg_ptr msg(new sim_mob::rr_android_ns3::MSG_CLIENTDONE(curr_json));
		//... and then assign the handler pointer to message's member
//			msg->setHandler(getHandler()); no handler!
		push_back(output,msg);
		break;
	}


	default:
		WarnOut("RR_Factory::createMessage() - Unhandled message type.");
	}

}
//creates a message with correct format + assigns correct handler
//todo improve the function to handle array of messages stored in the input string
 bool RR_Android_Factory::createMessage(std::string &input, std::vector<msg_ptr>& output)
{
//	std::vector<msg_t> result;
//	 Print() << "inside RR_Android_Factory::createMessage" << std::endl;
	std::string type, data;
	Json::Value root;
	sim_mob::pckt_header packetHeader;
	if(!sim_mob::JsonParser::parsePacketHeader(input, packetHeader, root))
	{
		return false;
	}
	if(!sim_mob::JsonParser::getPacketMessages(input,root))
	{
		return false;
	}
  	//use a number of threads to ,supposedly, speed up the process
	boost::thread_group threads;
	int num_threads = ( root.size() > MAX_THREAD_GROUP_SIZE ? MAX_THREAD_GROUP_SIZE : root.size() );
	int rounds = root.size() / num_threads;
	int cnt = 0;
	while (cnt < rounds) {
		int begin = cnt * rounds * num_threads;
		int end = (
				begin + num_threads <= root.size() ?
						begin + num_threads : begin + root.size() % num_threads);

		for (int i = begin; i < end; i++) {
			threads.create_thread(
					boost::bind(&RR_Android_Factory::cookMessage, this, boost::ref(root[i]), boost::ref(output)));
		}
		threads.join_all();
	}

	return true;
}
 /***************************************************************************************************************************************************
  *****************************   NS3   ************************************************************************************************************
  **************************************************************************************************************************************************/

 RR_NS3_Factory::RR_NS3_Factory() {
 	// TODO Auto-generated constructor stub
 	MessageMap = boost::assign::map_list_of("MULTICAST", MULTICAST)("UNICAST", UNICAST)("CLIENT_MESSAGES_DONE",CLIENT_MESSAGES_DONE);

 }
 RR_NS3_Factory::~RR_NS3_Factory() {}
 void RR_NS3_Factory::push_back(std::vector<msg_ptr>& output, msg_ptr&msg){
 	boost::unique_lock<boost::mutex> lock(mutex_);
 	output.push_back(msg);
 }
 //gets a handler either from a chche or by creating a new one
 hdlr_ptr  RR_NS3_Factory::getHandler(MessageType type){
 	hdlr_ptr handler;
 	//if handler is already registered && the registered handler is not null
 	std::map<MessageType, hdlr_ptr >::iterator it = HandlerMap.find(type);
 	if((it != HandlerMap.end())&&((*it).second!= 0))
 	{
 		//get the handler ...
 		handler = (*it).second;
 	}
 	else
 	{
 		//else, create a cache entry ...
 		bool typeFound = true;
 		switch(type)
 		{
 		case MULTICAST:
 			handler.reset(new sim_mob::rr_android_ns3::NS3_HDL_MULTICAST());
 			break;
 		case UNICAST:
 			handler.reset(new sim_mob::rr_android_ns3::NS3_HDL_UNICAST());
 			break;
 		default:
 			typeFound = false;
 		}
 		//register this baby
 		if(typeFound)
 		{
 			HandlerMap[type] = handler;
 		}
 	}

 	return handler;
 }


 void RR_NS3_Factory::cookMessage(Json::Value & jMsg, std::vector<msg_ptr>& output){
		msg_header messageHeader;
//		std::string  msgStr;// =  /*const_cast<std::string&>*/(root[index].asString());
		if (!sim_mob::JsonParser::parseMessageHeader(jMsg, messageHeader)) {
			return;
		}
		msg_data_t & curr_json = jMsg;
		switch (MessageMap[messageHeader.msg_type]) {
		case MULTICAST:{
			//create a message
			msg_ptr msg(new sim_mob::rr_android_ns3::NS3_MSG_MULTICAST(curr_json));
			//... and then assign the handler pointer to message's member
			msg->setHandler(getHandler(MULTICAST));
			push_back(output,msg);
			break;
		}
		case UNICAST:{
			//create a message
			msg_ptr msg(new sim_mob::rr_android_ns3::NS3_MSG_UNICAST(curr_json));
			//... and then assign the handler pointer to message's member
			msg->setHandler(getHandler(UNICAST));
			push_back(output,msg);
			break;
		}
		case CLIENT_MESSAGES_DONE:{
			//create a message
			msg_ptr msg(new sim_mob::rr_android_ns3::MSG_CLIENTDONE(curr_json));
			//... and then assign the handler pointer to message's member
//			msg->setHandler(getHandler()); no handler!
			push_back(output,msg);
			break;
		}


		default:
			WarnOut("RR_Factory::createMessage() - Unhandled message type.");
		}

 }

 //creates a message with correct format + assigns correct handler
 //todo improve the function to handle array of messages stored in the input string
  bool RR_NS3_Factory::createMessage(std::string &input, std::vector<msg_ptr>& output)
 {
	  //	std::vector<msg_t> result;
	  //	 Print() << "inside RR_Android_Factory::createMessage" << std::endl;
	  	std::string type, data;
	  	Json::Value root;
	  	sim_mob::pckt_header packetHeader;
	  	if(!sim_mob::JsonParser::parsePacketHeader(input, packetHeader, root))
	  	{
	  		return false;
	  	}
	  	if(!sim_mob::JsonParser::getPacketMessages(input,root))
	  	{
	  		return false;
	  	}
	  	//use a number of threads to ,supposedly, speed up the process
	  	boost::thread_group threads;
	  	int num_threads = ( root.size() > MAX_THREAD_GROUP_SIZE ? MAX_THREAD_GROUP_SIZE : root.size() );
	  	int rounds = root.size() / num_threads;
	  	int cnt = 0;
	  	while (cnt < rounds) {
	  		int begin = cnt * rounds * num_threads;
	  		int end = (
	  				begin + num_threads <= root.size() ?
	  						begin + num_threads : begin + root.size() % num_threads);

	  		for (int i = begin; i < end; i++) {
	  			threads.create_thread(
	  					boost::bind(&RR_NS3_Factory::cookMessage, this, boost::ref(root[i]), boost::ref(output)));
	  		}
	  		threads.join_all();
	  	}

 	return true;
 }
} /* namespace rr_android_ns3 */
} /* namespace sim_mob */
