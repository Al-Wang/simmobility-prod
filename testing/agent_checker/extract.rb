#This script will take a profile generated by Sim Mobility and extract timing information to help identify performance bottlenecks.
#Consider the Worker START and END timings; the time between these (added up across all Workers) represents the actual (minimum) processing
# time required per time tick. (We ignore Signals and other low-resolution time ticks for now, since they don't really impact performance.)
#We can check this assumption by running in "single threaded" mode, and ensuring that the times are similar.
#
#Now, aggregating the Worker ticks, we have:
# [---------------]......[---------------]......
#...where the [--]'s represent entire time ticks (minimum start time of any Worker in that tick, up to the maximum end time of any Worker in that tick)
#and the the ....'s represent waiting time (buffering, locking, etc.) that is essentially wasted. 
#The start of each time tick looks like this:
# [111--
# [-22--
# [33--
#...where 1, 2, and 3 represent active Workers 1, 2, and 3, and '-' represents wasted time.
#Any wasted time that occurs *before* a thread starts is termed "pre_tick" waiting time, and will be very close to zero if the number of Workers is 
# less than or equal to the number of cores. 
#Similarly, the end of each tick will have different threads finishing first, and then waiting. This waiting time is referred to as "post_tick" waiting time,
#  and indicates workload imbalances in the Workers. post_tick waiting times may subtract pre_tick to get an estimate of actual load imbalances (wth infinite cores).
#  Added together, the pre_tick and post_tick represent the total "internal" waiting time.
#
#For each time tick (consisting of the "tick" and the "wait" immediately following it), we ouput the following (in a file)
#   tick_id   num_workers   tick_length(ms)   total_work_time(ms)   internal_waiting_time(ms)   external_waiting_time(ms)
#Ideally, (total_work+internal_waiting) / num_workers == tick_length, and external_waiting == 0
#
#For each worker in each tick, we output the following (in a different file), organized like so:
#             worker_id(1)                                                   worker_id(2)
#   tick_id   pre_tick_waiting(ms)   work_time(ms)   post_tick_waiting(ms)   ...(next)
#
#Note that this script re-uses a lot of code from main.rb, so there may be duplicate code in places.
#Also note that we exclude the very last time tick.
#

#Regexes for parsing log lines, which are built like so:
#  {"key":"value",...}
LL_Key = '\"([^"]+)\"'
LL_Value = '\"([^"]+)\"'
LL_Property = " *#{LL_Key} *: *#{LL_Value},? *"
LL_Line = "{(?:#{LL_Property})+}"
LogPropRegex = Regexp.new(LL_Property)
LogLineRegex = Regexp.new(LL_Line)

#For parsing times:
#(sec,X),(nano,Y)
LogTimeRegex = /\( *sec *, *([0-9]+) *\) *, *\( *nano *, *([0-9]+) *\)/


#####################
# Data-only classes.
#####################

class FrameTick
  attr_reader   :tickID
  attr_accessor :minStartTime
  attr_accessor :maxEndTime
  attr_accessor :workers

  def initialize(id)
    @tickID = id

    #Defines the frame's boundaries
    @minStartTime = nil
    @maxEndTime = nil
    @workers = {}   #workerID => Worker
  end
end


class Worker
  attr_reader   :workerID
  attr_accessor :startTime
  attr_accessor :endTime

  def initialize(id)
    @workerID = id
    @startTime = nil
    @endTime = nil
  end
end



#####################
# Various helper functions.
#####################


#Helper function to deal with ms without losing (too much) accuracy.
def conv_subsec_to_ms(subsec)
  #This should work for both Rationals and FixNums
  return (subsec * 1000).to_f
end

#Helper function to calculate the difference between two time values in
#  milliseconds. We were losing too much accuracy with endTime - startTime (which returns seconds)
def time_diff_ms(startTime, endTime)
  res = (endTime.tv_sec - startTime.tv_sec) * 1000.0          #Convert seconds
  res += (conv_subsec_to_ms(endTime.subsec) - conv_subsec_to_ms(startTime.subsec)) #Convert sub-seconds
  return res
end


#####################
# Parser functions
#####################
  #Retrieve a property; return nil if not required and not found, else throw an error.
  def get_property(props, key, req)
    return props[key] if props.has_key? key
    return nil unless req
    raise "Error: Log line missing mandatory property: #{key}"
  end

  #Parse a "time" property.
  def parse_time(timeStr)
    m = LogTimeRegex.match(timeStr)
    raise "Invalid time: #{timeStr}" unless m
    return Time.at(m[1].to_i, m[2].to_i/1000)
  end

  #Dispatch a line of parsed text to its relevant parser.
  def dispatch_line(timeticks, properties)
    type = get_property(properties, "action", true)
    time = get_property(properties, "real-time", true)

    if type=="worker-update-begin"
      dispatch_worker_startupdate(timeticks, properties, time)
    elsif type=="worker-update-end"
      dispatch_worker_endupdate(timeticks, properties, time)
    end
  end

  def dispatch_worker_startupdate(timeticks, properties, time)
    time = parse_time(time)
    worker = create_path_to_worker_and_update_bounds(properties, timeticks, time)
    worker.startTime = time
  end

  def dispatch_worker_endupdate(timeticks, properties, time)
    time = parse_time(time)
    worker = create_path_to_worker_and_update_bounds(properties, timeticks, time)
    worker.endTime = time
  end

  def create_path_to_worker_and_update_bounds(properties, timeticks, time)
    worker = get_property(properties, "worker", true)
    tick = get_property(properties, "tick", true)

    #Expand the bounds of the timetick (also, add it)
    timeticks[tick] = FrameTick.new(tick) unless timeticks.has_key? tick
    tick = timeticks[tick]
    tick.minStartTime = [time, tick.minStartTime].compact.min
    tick.maxEndTime = [time, tick.maxEndTime].compact.max

    #Add worker, return
    tick.workers[worker] = Worker.new(worker) unless tick.workers.has_key? worker
    return tick.workers[worker]
  end


#####################
# Main parsing function.
#####################

def read_trace_file(fileName, ticks)
  File.open(fileName).each { |line|
    #Skip comments, empty lines
    line.strip!
    next if line.empty? or line.start_with? '#'

    #Parse
    if line =~ LogLineRegex
      props = {}
      line.scan(LogPropRegex) {|propRes|
        key = propRes[0]
        val = propRes[1]
        raise "Duplicate property: #{key}=>#{val}" if props.has_key? key
        props[key] = val
      }
      dispatch_line(ticks, props)
    else
      puts "Skipped: #{line}"
    end
  }
end



def write_tick_file(outFileName, ticks)
  File.open(outFileName, 'w') {|f|
    #Write the header.
    f.write("tick_id\tnum_workers\ttick_length(ms)\ttotal_work_time(ms)\tinternal_waiting_time(ms)\texternal_waiting_time(ms)\n")

    #Now, accumulate (be careful of low-latency time ticks, like for signals).
    sorted_keys = ticks.keys.sort{|t1, t2| t1.to_i <=> t2.to_i }  #to_i needed to avoid "12" > "100"
    sorted_keys.each{|tickI|
      next unless ticks.has_key?((tickI.to_i+1).to_s) #Always skip the last tick.
      tick = ticks[tickI.to_s]

      #Aggregate some statistics
      numWorkers = 0
      totalWorkTime = 0
      internalWaitTime = 0
      externalWaitTime = 0
      tick.workers.each{|id,wrk|
        #An easy way to check for low-latency workers is to see if they appear in the next tick.
        next unless ticks[(tickI.to_i+1).to_s].workers.has_key?(wrk.workerID)
        numWorkers += 1

        #Just add it up (make sure to use our accurate "diff" functions)
        totalWorkTime += time_diff_ms(wrk.startTime, wrk.endTime)
        internalWaitTime += time_diff_ms(tick.minStartTime, wrk.startTime)
        externalWaitTime += time_diff_ms(wrk.endTime, tick.maxEndTime)
      }

      #Output
      tickLength = time_diff_ms(tick.minStartTime, tick.maxEndTime)
      f.write("#{tickI}\t#{numWorkers}\t#{tickLength}\t#{totalWorkTime}\t#{internalWaitTime}\t#{externalWaitTime}\n")
    }
  }
end


def run_main()
  #Simple
  if ARGV.length < 1
    puts 'Usage:'
    puts "#{__FILE__}  <prof_file.txt>"
    puts '  <prof_file.txt> => The profiling file generated by sim mobility.'
    exit
  end

  #Read our time ticks into a temporary hash.
  ticks = {}  #tickID=>FrameTick
  read_trace_file(ARGV[0], ticks)

  #Output the first file.
  write_tick_file('timeticks.csv', ticks)
end


if __FILE__ == $PROGRAM_NAME
  run_main()
end


